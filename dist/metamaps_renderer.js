//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

//     Backbone.js 1.0.0

//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `exports`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both the browser and the server.
  var Backbone;
  if (typeof exports !== 'undefined') {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.0.0';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var defaults;
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    _.extend(this, _.pick(options, modelOptions));
    if (options.parse) attrs = this.parse(attrs, options) || {};
    if (defaults = _.result(this, 'defaults')) {
      attrs = _.defaults({}, attrs, defaults);
    }
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // A list of options to be attached directly to the model, if provided.
  var modelOptions = ['url', 'urlRoot', 'collection'];

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = true;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
      if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;

      options = _.extend({validate: true}, options);

      // Do not persist invalid models.
      if (!this._validate(attrs, options)) return false;

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.url) this.url = options.url;
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, merge: false, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.defaults(options || {}, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      models = _.isArray(models) ? models.slice() : [models];
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults(options || {}, setOptions);
      if (options.parse) models = this.parse(models, options);
      if (!_.isArray(models)) models = models ? [models] : [];
      var i, l, model, attrs, existing, sort;
      var at = options.at;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        if (!(model = this._prepareModel(models[i], options))) continue;

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(model)) {
          if (options.remove) modelMap[existing.cid] = true;
          if (options.merge) {
            existing.set(model.attributes, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }

        // This is a new model, push it to the `toAdd` list.
        } else if (options.add) {
          toAdd.push(model);

          // Listen to added models' events, and index models for lookup by
          // `id` and by `cid`.
          model.on('all', this._onModelEvent, this);
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
        }
      }

      // Remove nonexistent models if appropriate.
      if (options.remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          splice.apply(this.models, [at, 0].concat(toAdd));
        } else {
          push.apply(this.models, toAdd);
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      if (options.silent) return this;

      // Trigger `add` events.
      for (i = 0, l = toAdd.length; i < l; i++) {
        (model = toAdd[i]).trigger('add', model, this, options);
      }

      // Trigger `sort` if the collection was sorted.
      if (sort) this.trigger('sort', this, options);
      return this;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      options.previousModels = this.models;
      this._reset();
      this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: this.length}, options));
      return model;
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: 0}, options));
      return model;
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function(begin, end) {
      return this.models.slice(begin, end);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj.id != null ? obj.id : obj.cid || obj];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Figure out the smallest index at which a model should be inserted so as
    // to maintain order.
    sortedIndex: function(model, value, context) {
      value || (value = this.comparator);
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _.sortedIndex(this.models, model, iterator, context);
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options || (options = {});
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model._validate(attrs, options)) {
        this.trigger('invalid', this, attrs, options);
        return false;
      }
      return model;
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',
    'isEmpty', 'chain'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be prefered to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save'
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Performs the initial configuration of a View with a set of options.
    // Keys with special meaning *(e.g. model, collection, id, className)* are
    // attached directly to the view.  See `viewOptions` for an exhaustive
    // list.
    _configure: function(options) {
      if (this.options) options = _.extend({}, _.result(this, 'options'), options);
      _.extend(this, _.pick(options, viewOptions));
      this.options = options;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && window.ActiveXObject &&
          !(window.external && window.external.msActiveXFilteringEnabled)) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        callback && callback.apply(router, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional){
                     return optional ? match : '([^\/]+)';
                   })
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param) {
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = this.location.pathname;
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({}, {root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;
      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
        this.fragment = this.getFragment(null, true);
        this.location.replace(this.root + this.location.search + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl() || this.loadUrl(this.getHash());
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: options};
      fragment = this.getFragment(fragment || '');
      if (this.fragment === fragment) return;
      this.fragment = fragment;
      var url = this.root + fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function (model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

}).call(this);

/**
 * Note: For the purpose of this internal documentation, arguments of the type
 * {Nodes} are to be interpreted as either {NodeList} or {Element}.
 */

;(function (global) {
  'use strict'

  /**
   * @private
   *
   * `_liveElements` holds all elements that have the live-counting
   * functionality bound to them.
   *
   * `_event` holds the event to handle the live counting, based on the
   * browser's capabilities.
   */

  var _liveElements = [],
      _event = 'oninput' in document ? 'input' : 'keyup'

  /**
   * IE9 is a special case. It does not fire an 'input' event when
   * characters are deleted (via DEL key, BACKSPACE key, and CUT).
   * If we want support for those actions we need to use the 'keyup'
   * event instead.
   * more info: http://www.matts411.com/post/internet-explorer-9-oninput/
   */

  if (navigator.userAgent.match(/MSIE 9.0/)) {
    _event = 'keyup'
  }

  /**
   * `String.trim()` polyfill for non-supporting browsers. This is the
   * recommended polyfill on MDN.
   *
   * @see     <http://goo.gl/uYveB>
   * @see     <http://goo.gl/xjIxJ>
   *
   * @return  {String}  The original string with leading and trailing
   *                    whitespace removed.
   */

  if (!String.prototype.trim) {
    String.prototype.trim = function () {
      return this.replace(/^\s+|\s+$/g, '')
    }
  }

  /**
   * `ucs2decode` function from the punycode.js library.
   *
   * Creates an array containing the decimal code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally, this
   * function will convert a pair of surrogate halves (each of which UCS-2
   * exposes as separate characters) into a single code point, matching
   * UTF-16.
   *
   * @see     <http://goo.gl/8M09r>
   * @see     <http://goo.gl/u4UUC>
   *
   * @param   {String}  string   The Unicode input string (UCS-2).
   *
   * @return  {Array}   The new array of code points.
   */

  function _decode (string) {
    var output = [],
        counter = 0,
        length = string.length,
        value, extra

    while (counter < length) {
      value = string.charCodeAt(counter++)

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // High surrogate, and there is a next character.
        extra = string.charCodeAt(counter++)

        if ((extra & 0xFC00) == 0xDC00) {
          // Low surrogate.
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000)
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value, extra)
          counter--
        }
      } else {
        output.push(value)
      }
    }

    return output
  }

  /**
   * `_validateArguments` validates the arguments given to each function call.
   * Errors are logged to the console as warnings, but Countable fails
   * silently.
   *
   * @private
   *
   * @param   {Nodes}     elements  The (collection of) element(s) to
   *                                validate.
   *
   * @param   {Function}  callback  The callback function to validate.
   *
   * @return  {Boolean}   Returns whether all arguments are vaild.
   */

  function _validateArguments (elements, callback) {
    var elementsValid = elements && ((Object.prototype.toString.call(elements) === '[object NodeList]' && elements.length) || (elements.nodeType === 1)),
        callbackValid = callback && typeof callback === 'function'

    if ('console' in window && 'warn' in console) {
      if (!elementsValid) console.warn('Countable: No valid elements were found')
      if (!callbackValid) console.warn('Countable: "' + callback + '" is not a valid callback function')
    }

    return elementsValid && callbackValid
  }

  /**
   * `_extendDefaults` is a function to extend a set of default options with
   * the ones given in the function call. Available options are described
   * below.
   *
   * {Boolean}  hardReturns      Use two returns to seperate a paragraph
   *                             instead of one.
   * {Boolean}  stripTags        Strip HTML tags before counting the values.
   * {Boolean}  ignoreReturns    Ignore returns when calculating the `all`
   *                             property.
   * {Boolean}  ignoreZeroWidth  Ignore zero-width space characters.
   *
   * @private
   *
   * @param   {Object}  options  Countable allows the options described above.
   *                             They can be used in a function call to
   *                             override the default behaviour.
   *
   * @return  {Object}  The new options object.
   */

  function _extendDefaults (options) {
    var defaults = {
      hardReturns: false,
      stripTags: false,
      ignoreReturns: false,
      ignoreZeroWidth: true
    }

    for (var prop in options) {
      if (defaults.hasOwnProperty(prop)) defaults[prop] = options[prop]
    }

    return defaults
  }

  /**
   * `_count` trims an element's value, optionally strips HTML tags and counts
   * paragraphs, sentences, words, characters and characters plus spaces.
   *
   * @private
   *
   * @param   {Element}  element  The element whose value is to be counted.
   *
   * @param   {Object}   options  The options to use for the counting.
   *
   * @return  {Object}   The object containing the number of paragraphs,
   *                     sentences, words, characters and characters plus
   *                     spaces.
   */

  function _count (element, options) {
    var original = 'value' in element ? element.value : element.innerText || element.textContent,
        trimmed

    /**
     * The initial implementation to allow for HTML tags stripping was created
     * @craniumslows while the current one was created by @Rob--W.
     *
     * @see <http://goo.gl/Exmlr>
     * @see <http://goo.gl/gFQQh>
     */

    if (options.stripTags) original = original.replace(/<\/?[a-z][^>]*>/gi, '')
    if (options.ignoreZeroWidth) original = original.replace(/[\u200B]+/, '')

    trimmed = original.trim()

    /**
     * Most of the performance improvements are based on the works of @epmatsw.
     *
     * @see <http://goo.gl/SWOLB>
     */

    return {
      paragraphs: trimmed ? (trimmed.match(options.hardReturns ? /\n{2,}/g : /\n+/g) || []).length + 1 : 0,
      sentences: trimmed ? (trimmed.match(/[.?!…]+./g) || []).length + 1 : 0,
      words: trimmed ? (trimmed.replace(/['";:,.?¿\-!¡]+/g, '').match(/\S+/g) || []).length : 0,
      characters: trimmed ? _decode(trimmed.replace(/\s/g, '')).length : 0,
      all: _decode(options.ignoreReturns ? original.replace(/[\n\r]/g, '') : original).length
    }
  }

  /**
   * `_loop` is a helper function to iterate over a collection, e.g. a NodeList
   * or an Array. The callback receives the current element as the single
   * parameter.
   *
   * @private
   *
   * @param  {Array}     which     The collection to iterate over.
   *
   * @param  {Function}  callback  The callback function to call on each
   *                               iteration.
   */

  function _loop (which, callback) {
    var len = which.length

    if (typeof len !== 'undefined') {
      while (len--) {
        callback(which[len])
      }
    } else {
      callback(which)
    }
  }

  /**
   * This is the main object that will later be exposed to other scripts. It
   * holds all the public methods that can be used to enable the Countable
   * functionality.
   */

  var Countable = {

    /**
     * The `live` method binds the counting handler to all given elements. The
     * event is either `oninput` or `onkeydown`, based on the capabilities of
     * the browser.
     *
     * @param   {Nodes}     elements   All elements that should receive the
     *                                 Countable functionality.
     *
     * @param   {Function}  callback   The callback to fire whenever the
     *                                 element's value changes. The callback is
     *                                 called with the relevant element bound
     *                                 to `this` and the counted values as the
     *                                 single parameter.
     *
     * @param   {Object}    [options]  An object to modify Countable's
     *                                 behaviour. Refer to `_extendDefaults`
     *                                 for a list of available options.
     *
     * @return  {Object}    Returns the Countable object to allow for chaining.
     */

    live: function (elements, callback, options) {
      var ops = _extendDefaults(options),
          bind = function (element) {
            var handler = function () {
                  callback.call(element, _count(element, ops))
                }

            _liveElements.push({ element: element, handler: handler })

            handler()

            if (element.addEventListener) {
              element.addEventListener(_event, handler, false)
            } else if (element.attachEvent) {
              element.attachEvent('on' + _event, handler)
            }
          }

      if (!_validateArguments(elements, callback)) return

      if (elements.length) {
        _loop(elements, bind)
      } else {
        bind(elements)
      }

      return this
    },

    /**
     * The `die` method removes the Countable functionality from all given
     * elements.
     *
     * @param   {Nodes}  elements  All elements whose Countable functionality
     *                             should be unbound.
     *
     * @return  {Object}  Returns the Countable object to allow for chaining.
     */

    die: function (elements) {
      if (!_validateArguments(elements, function () {})) return

      _loop(elements, function (element) {
        var liveElement

        _loop(_liveElements, function (live) {
          if (live.element === element) liveElement = live
        })

        if (!liveElement) return

        if (element.removeEventListener) {
          element.removeEventListener(_event, liveElement.handler, false)
        } else if (element.detachEvent) {
          element.detachEvent('on' + _event, liveElement.handler)
        }

        _liveElements.splice(_liveElements.indexOf(liveElement), 1)
      })

      return this
    },

    /**
     * The `once` method works mostly like the `live` method, but no events are
     * bound, the functionality is only executed once.
     *
     * @alias   Countable.count
     *
     * @param   {Nodes}     elements   All elements that should receive the
     *                                 Countable functionality.
     *
     * @param   {Function}  callback   The callback to fire whenever the
     *                                 element's value changes. The callback is
     *                                 called with the relevant element bound
     *                                 to `this` and the counted values as the
     *                                 single parameter.
     *
     * @param   {Object}    [options]  An object to modify Countable's
     *                                 behaviour. Refer to `_extendDefaults`
     *                                 for a list of available options.
     *
     * @return  {Object}    Returns the Countable object to allow for chaining.
     */

    once: function (elements, callback, options) {
      if (!_validateArguments(elements, callback)) return

      _loop(elements, function (element) {
        callback.call(element, _count(element, _extendDefaults(options)))
      })

      return this
    },

    count: function (elements, callback, options) {
      return this.once(elements, callback, options)
    },

    /**
     * The `enabled` method checks if the live-counting functionality is bound
     * to an element.
     *
     * @param   {Element}  element  A single Element.
     *
     * @return  {Boolean}  A boolean value representing whether Countable
     *                     functionality is bound to the given element.
     */

    enabled: function (element) {
      var isEnabled = false

      if (element && element.nodeType === 1) {
        _loop(_liveElements, function (live) {
          if (live.element === element) isEnabled = true
        })
      }

      return isEnabled
    }

  }

  /**
   * Expose Countable depending on the module system used across the
   * application. (Node / CommonJS, AMD, global)
   */

  if (typeof exports === 'object') {
    module.exports = Countable
  } else if (typeof define === 'function' && define.amd) {
    define(function () { return Countable })
  } else {
    global.Countable = Countable
  }
}(this));

/*! Socket.IO.js build:0.9.11, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */

var io = ('undefined' === typeof module ? {} : module.exports);
(function() {

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, global) {

  /**
   * IO namespace.
   *
   * @namespace
   */

  var io = exports;

  /**
   * Socket.IO version
   *
   * @api public
   */

  io.version = '0.9.11';

  /**
   * Protocol implemented.
   *
   * @api public
   */

  io.protocol = 1;

  /**
   * Available transports, these will be populated with the available transports
   *
   * @api public
   */

  io.transports = [];

  /**
   * Keep track of jsonp callbacks.
   *
   * @api private
   */

  io.j = [];

  /**
   * Keep track of our io.Sockets
   *
   * @api private
   */
  io.sockets = {};


  /**
   * Manages connections to hosts.
   *
   * @param {String} uri
   * @Param {Boolean} force creation of new socket (defaults to false)
   * @api public
   */

  io.connect = function (host, details) {
    var uri = io.util.parseUri(host)
      , uuri
      , socket;

    if (global && global.location) {
      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);
      uri.host = uri.host || (global.document
        ? global.document.domain : global.location.hostname);
      uri.port = uri.port || global.location.port;
    }

    uuri = io.util.uniqueUri(uri);

    var options = {
        host: uri.host
      , secure: 'https' == uri.protocol
      , port: uri.port || ('https' == uri.protocol ? 443 : 80)
      , query: uri.query || ''
    };

    io.util.merge(options, details);

    if (options['force new connection'] || !io.sockets[uuri]) {
      socket = new io.Socket(options);
    }

    if (!options['force new connection'] && socket) {
      io.sockets[uuri] = socket;
    }

    socket = socket || io.sockets[uuri];

    // if path is different from '' or /
    return socket.of(uri.path.length > 1 ? uri.path : '');
  };

})('object' === typeof module ? module.exports : (this.io = {}), this);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, global) {

  /**
   * Utilities namespace.
   *
   * @namespace
   */

  var util = exports.util = {};

  /**
   * Parses an URI
   *
   * @author Steven Levithan <stevenlevithan.com> (MIT license)
   * @api public
   */

  var re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',
               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',
               'anchor'];

  util.parseUri = function (str) {
    var m = re.exec(str || '')
      , uri = {}
      , i = 14;

    while (i--) {
      uri[parts[i]] = m[i] || '';
    }

    return uri;
  };

  /**
   * Produces a unique url that identifies a Socket.IO connection.
   *
   * @param {Object} uri
   * @api public
   */

  util.uniqueUri = function (uri) {
    var protocol = uri.protocol
      , host = uri.host
      , port = uri.port;

    if ('document' in global) {
      host = host || document.domain;
      port = port || (protocol == 'https'
        && document.location.protocol !== 'https:' ? 443 : document.location.port);
    } else {
      host = host || 'localhost';

      if (!port && protocol == 'https') {
        port = 443;
      }
    }

    return (protocol || 'http') + '://' + host + ':' + (port || 80);
  };

  /**
   * Mergest 2 query strings in to once unique query string
   *
   * @param {String} base
   * @param {String} addition
   * @api public
   */

  util.query = function (base, addition) {
    var query = util.chunkQuery(base || '')
      , components = [];

    util.merge(query, util.chunkQuery(addition || ''));
    for (var part in query) {
      if (query.hasOwnProperty(part)) {
        components.push(part + '=' + query[part]);
      }
    }

    return components.length ? '?' + components.join('&') : '';
  };

  /**
   * Transforms a querystring in to an object
   *
   * @param {String} qs
   * @api public
   */

  util.chunkQuery = function (qs) {
    var query = {}
      , params = qs.split('&')
      , i = 0
      , l = params.length
      , kv;

    for (; i < l; ++i) {
      kv = params[i].split('=');
      if (kv[0]) {
        query[kv[0]] = kv[1];
      }
    }

    return query;
  };

  /**
   * Executes the given function when the page is loaded.
   *
   *     io.util.load(function () { console.log('page loaded'); });
   *
   * @param {Function} fn
   * @api public
   */

  var pageLoaded = false;

  util.load = function (fn) {
    if ('document' in global && document.readyState === 'complete' || pageLoaded) {
      return fn();
    }

    util.on(global, 'load', fn, false);
  };

  /**
   * Adds an event.
   *
   * @api private
   */

  util.on = function (element, event, fn, capture) {
    if (element.attachEvent) {
      element.attachEvent('on' + event, fn);
    } else if (element.addEventListener) {
      element.addEventListener(event, fn, capture);
    }
  };

  /**
   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.
   *
   * @param {Boolean} [xdomain] Create a request that can be used cross domain.
   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.
   * @api private
   */

  util.request = function (xdomain) {

    if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {
      return new XDomainRequest();
    }

    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {
      return new XMLHttpRequest();
    }

    if (!xdomain) {
      try {
        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');
      } catch(e) { }
    }

    return null;
  };

  /**
   * XHR based transport constructor.
   *
   * @constructor
   * @api public
   */

  /**
   * Change the internal pageLoaded value.
   */

  if ('undefined' != typeof window) {
    util.load(function () {
      pageLoaded = true;
    });
  }

  /**
   * Defers a function to ensure a spinner is not displayed by the browser
   *
   * @param {Function} fn
   * @api public
   */

  util.defer = function (fn) {
    if (!util.ua.webkit || 'undefined' != typeof importScripts) {
      return fn();
    }

    util.load(function () {
      setTimeout(fn, 100);
    });
  };

  /**
   * Merges two objects.
   *
   * @api public
   */

  util.merge = function merge (target, additional, deep, lastseen) {
    var seen = lastseen || []
      , depth = typeof deep == 'undefined' ? 2 : deep
      , prop;

    for (prop in additional) {
      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {
        if (typeof target[prop] !== 'object' || !depth) {
          target[prop] = additional[prop];
          seen.push(additional[prop]);
        } else {
          util.merge(target[prop], additional[prop], depth - 1, seen);
        }
      }
    }

    return target;
  };

  /**
   * Merges prototypes from objects
   *
   * @api public
   */

  util.mixin = function (ctor, ctor2) {
    util.merge(ctor.prototype, ctor2.prototype);
  };

  /**
   * Shortcut for prototypical and static inheritance.
   *
   * @api private
   */

  util.inherit = function (ctor, ctor2) {
    function f() {};
    f.prototype = ctor2.prototype;
    ctor.prototype = new f;
  };

  /**
   * Checks if the given object is an Array.
   *
   *     io.util.isArray([]); // true
   *     io.util.isArray({}); // false
   *
   * @param Object obj
   * @api public
   */

  util.isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  /**
   * Intersects values of two arrays into a third
   *
   * @api public
   */

  util.intersect = function (arr, arr2) {
    var ret = []
      , longest = arr.length > arr2.length ? arr : arr2
      , shortest = arr.length > arr2.length ? arr2 : arr;

    for (var i = 0, l = shortest.length; i < l; i++) {
      if (~util.indexOf(longest, shortest[i]))
        ret.push(shortest[i]);
    }

    return ret;
  };

  /**
   * Array indexOf compatibility.
   *
   * @see bit.ly/a5Dxa2
   * @api public
   */

  util.indexOf = function (arr, o, i) {

    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;
         i < j && arr[i] !== o; i++) {}

    return j <= i ? -1 : i;
  };

  /**
   * Converts enumerables to array.
   *
   * @api public
   */

  util.toArray = function (enu) {
    var arr = [];

    for (var i = 0, l = enu.length; i < l; i++)
      arr.push(enu[i]);

    return arr;
  };

  /**
   * UA / engines detection namespace.
   *
   * @namespace
   */

  util.ua = {};

  /**
   * Whether the UA supports CORS for XHR.
   *
   * @api public
   */

  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {
    try {
      var a = new XMLHttpRequest();
    } catch (e) {
      return false;
    }

    return a.withCredentials != undefined;
  })();

  /**
   * Detect webkit.
   *
   * @api public
   */

  util.ua.webkit = 'undefined' != typeof navigator
    && /webkit/i.test(navigator.userAgent);

   /**
   * Detect iPad/iPhone/iPod.
   *
   * @api public
   */

  util.ua.iDevice = 'undefined' != typeof navigator
      && /iPad|iPhone|iPod/i.test(navigator.userAgent);

})('undefined' != typeof io ? io : module.exports, this);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.EventEmitter = EventEmitter;

  /**
   * Event emitter constructor.
   *
   * @api public.
   */

  function EventEmitter () {};

  /**
   * Adds a listener
   *
   * @api public
   */

  EventEmitter.prototype.on = function (name, fn) {
    if (!this.$events) {
      this.$events = {};
    }

    if (!this.$events[name]) {
      this.$events[name] = fn;
    } else if (io.util.isArray(this.$events[name])) {
      this.$events[name].push(fn);
    } else {
      this.$events[name] = [this.$events[name], fn];
    }

    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  /**
   * Adds a volatile listener.
   *
   * @api public
   */

  EventEmitter.prototype.once = function (name, fn) {
    var self = this;

    function on () {
      self.removeListener(name, on);
      fn.apply(this, arguments);
    };

    on.listener = fn;
    this.on(name, on);

    return this;
  };

  /**
   * Removes a listener.
   *
   * @api public
   */

  EventEmitter.prototype.removeListener = function (name, fn) {
    if (this.$events && this.$events[name]) {
      var list = this.$events[name];

      if (io.util.isArray(list)) {
        var pos = -1;

        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {
            pos = i;
            break;
          }
        }

        if (pos < 0) {
          return this;
        }

        list.splice(pos, 1);

        if (!list.length) {
          delete this.$events[name];
        }
      } else if (list === fn || (list.listener && list.listener === fn)) {
        delete this.$events[name];
      }
    }

    return this;
  };

  /**
   * Removes all listeners for an event.
   *
   * @api public
   */

  EventEmitter.prototype.removeAllListeners = function (name) {
    if (name === undefined) {
      this.$events = {};
      return this;
    }

    if (this.$events && this.$events[name]) {
      this.$events[name] = null;
    }

    return this;
  };

  /**
   * Gets all listeners for a certain event.
   *
   * @api publci
   */

  EventEmitter.prototype.listeners = function (name) {
    if (!this.$events) {
      this.$events = {};
    }

    if (!this.$events[name]) {
      this.$events[name] = [];
    }

    if (!io.util.isArray(this.$events[name])) {
      this.$events[name] = [this.$events[name]];
    }

    return this.$events[name];
  };

  /**
   * Emits an event.
   *
   * @api public
   */

  EventEmitter.prototype.emit = function (name) {
    if (!this.$events) {
      return false;
    }

    var handler = this.$events[name];

    if (!handler) {
      return false;
    }

    var args = Array.prototype.slice.call(arguments, 1);

    if ('function' == typeof handler) {
      handler.apply(this, args);
    } else if (io.util.isArray(handler)) {
      var listeners = handler.slice();

      for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i].apply(this, args);
      }
    } else {
      return false;
    }

    return true;
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Based on JSON2 (http://www.JSON.org/js.html).
 */

(function (exports, nativeJSON) {
  "use strict";

  // use native JSON if it's available
  if (nativeJSON && nativeJSON.parse){
    return exports.JSON = {
      parse: nativeJSON.parse
    , stringify: nativeJSON.stringify
    };
  }

  var JSON = exports.JSON = {};

  function f(n) {
      // Format integers to have at least two digits.
      return n < 10 ? '0' + n : n;
  }

  function date(d, key) {
    return isFinite(d.valueOf()) ?
        d.getUTCFullYear()     + '-' +
        f(d.getUTCMonth() + 1) + '-' +
        f(d.getUTCDate())      + 'T' +
        f(d.getUTCHours())     + ':' +
        f(d.getUTCMinutes())   + ':' +
        f(d.getUTCSeconds())   + 'Z' : null;
  };

  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      gap,
      indent,
      meta = {    // table of character substitutions
          '\b': '\\b',
          '\t': '\\t',
          '\n': '\\n',
          '\f': '\\f',
          '\r': '\\r',
          '"' : '\\"',
          '\\': '\\\\'
      },
      rep;


  function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
          var c = meta[a];
          return typeof c === 'string' ? c :
              '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
  }


  function str(key, holder) {

// Produce a string from holder[key].

      var i,          // The loop counter.
          k,          // The member key.
          v,          // The member value.
          length,
          mind = gap,
          partial,
          value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

      if (value instanceof Date) {
          value = date(key);
      }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

      if (typeof rep === 'function') {
          value = rep.call(holder, key, value);
      }

// What happens next depends on the value's type.

      switch (typeof value) {
      case 'string':
          return quote(value);

      case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

          return isFinite(value) ? String(value) : 'null';

      case 'boolean':
      case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

          return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

      case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

          if (!value) {
              return 'null';
          }

// Make an array to hold the partial results of stringifying this object value.

          gap += indent;
          partial = [];

// Is the value an array?

          if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

              length = value.length;
              for (i = 0; i < length; i += 1) {
                  partial[i] = str(i, value) || 'null';
              }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

              v = partial.length === 0 ? '[]' : gap ?
                  '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                  '[' + partial.join(',') + ']';
              gap = mind;
              return v;
          }

// If the replacer is an array, use it to select the members to be stringified.

          if (rep && typeof rep === 'object') {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                  if (typeof rep[i] === 'string') {
                      k = rep[i];
                      v = str(k, value);
                      if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                      }
                  }
              }
          } else {

// Otherwise, iterate through all of the keys in the object.

              for (k in value) {
                  if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = str(k, value);
                      if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                      }
                  }
              }
          }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

          v = partial.length === 0 ? '{}' : gap ?
              '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
              '{' + partial.join(',') + '}';
          gap = mind;
          return v;
      }
  }

// If the JSON object does not yet have a stringify method, give it one.

  JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

      var i;
      gap = '';
      indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

      if (typeof space === 'number') {
          for (i = 0; i < space; i += 1) {
              indent += ' ';
          }

// If the space parameter is a string, it will be used as the indent string.

      } else if (typeof space === 'string') {
          indent = space;
      }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

      rep = replacer;
      if (replacer && typeof replacer !== 'function' &&
              (typeof replacer !== 'object' ||
              typeof replacer.length !== 'number')) {
          throw new Error('JSON.stringify');
      }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

      return str('', {'': value});
  };

// If the JSON object does not yet have a parse method, give it one.

  JSON.parse = function (text, reviver) {
  // The parse method takes a text and an optional reviver function, and returns
  // a JavaScript value if the text is a valid JSON text.

      var j;

      function walk(holder, key) {

  // The walk method is used to recursively walk the resulting structure so
  // that modifications can be made.

          var k, v, value = holder[key];
          if (value && typeof value === 'object') {
              for (k in value) {
                  if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = walk(value, k);
                      if (v !== undefined) {
                          value[k] = v;
                      } else {
                          delete value[k];
                      }
                  }
              }
          }
          return reviver.call(holder, key, value);
      }


  // Parsing happens in four stages. In the first stage, we replace certain
  // Unicode characters with escape sequences. JavaScript handles many characters
  // incorrectly, either silently deleting them, or treating them as line endings.

      text = String(text);
      cx.lastIndex = 0;
      if (cx.test(text)) {
          text = text.replace(cx, function (a) {
              return '\\u' +
                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
          });
      }

  // In the second stage, we run the text against regular expressions that look
  // for non-JSON patterns. We are especially concerned with '()' and 'new'
  // because they can cause invocation, and '=' because it can cause mutation.
  // But just to be safe, we want to reject all unexpected forms.

  // We split the second stage into 4 regexp operations in order to work around
  // crippling inefficiencies in IE's and Safari's regexp engines. First we
  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
  // replace all simple value tokens with ']' characters. Third, we delete all
  // open brackets that follow a colon or comma or that begin the text. Finally,
  // we look to see that the remaining characters are only whitespace or ']' or
  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

      if (/^[\],:{}\s]*$/
              .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                  .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                  .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

  // In the third stage we use the eval function to compile the text into a
  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
  // in JavaScript: it can begin a block or an object literal. We wrap the text
  // in parens to eliminate the ambiguity.

          j = eval('(' + text + ')');

  // In the optional fourth stage, we recursively walk the new structure, passing
  // each name/value pair to a reviver function for possible transformation.

          return typeof reviver === 'function' ?
              walk({'': j}, '') : j;
      }

  // If the text is not JSON parseable, then a SyntaxError is thrown.

      throw new SyntaxError('JSON.parse');
  };

})(
    'undefined' != typeof io ? io : module.exports
  , typeof JSON !== 'undefined' ? JSON : undefined
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Parser namespace.
   *
   * @namespace
   */

  var parser = exports.parser = {};

  /**
   * Packet types.
   */

  var packets = parser.packets = [
      'disconnect'
    , 'connect'
    , 'heartbeat'
    , 'message'
    , 'json'
    , 'event'
    , 'ack'
    , 'error'
    , 'noop'
  ];

  /**
   * Errors reasons.
   */

  var reasons = parser.reasons = [
      'transport not supported'
    , 'client not handshaken'
    , 'unauthorized'
  ];

  /**
   * Errors advice.
   */

  var advice = parser.advice = [
      'reconnect'
  ];

  /**
   * Shortcuts.
   */

  var JSON = io.JSON
    , indexOf = io.util.indexOf;

  /**
   * Encodes a packet.
   *
   * @api private
   */

  parser.encodePacket = function (packet) {
    var type = indexOf(packets, packet.type)
      , id = packet.id || ''
      , endpoint = packet.endpoint || ''
      , ack = packet.ack
      , data = null;

    switch (packet.type) {
      case 'error':
        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''
          , adv = packet.advice ? indexOf(advice, packet.advice) : '';

        if (reason !== '' || adv !== '')
          data = reason + (adv !== '' ? ('+' + adv) : '');

        break;

      case 'message':
        if (packet.data !== '')
          data = packet.data;
        break;

      case 'event':
        var ev = { name: packet.name };

        if (packet.args && packet.args.length) {
          ev.args = packet.args;
        }

        data = JSON.stringify(ev);
        break;

      case 'json':
        data = JSON.stringify(packet.data);
        break;

      case 'connect':
        if (packet.qs)
          data = packet.qs;
        break;

      case 'ack':
        data = packet.ackId
          + (packet.args && packet.args.length
              ? '+' + JSON.stringify(packet.args) : '');
        break;
    }

    // construct packet with required fragments
    var encoded = [
        type
      , id + (ack == 'data' ? '+' : '')
      , endpoint
    ];

    // data fragment is optional
    if (data !== null && data !== undefined)
      encoded.push(data);

    return encoded.join(':');
  };

  /**
   * Encodes multiple messages (payload).
   *
   * @param {Array} messages
   * @api private
   */

  parser.encodePayload = function (packets) {
    var decoded = '';

    if (packets.length == 1)
      return packets[0];

    for (var i = 0, l = packets.length; i < l; i++) {
      var packet = packets[i];
      decoded += '\ufffd' + packet.length + '\ufffd' + packets[i];
    }

    return decoded;
  };

  /**
   * Decodes a packet
   *
   * @api private
   */

  var regexp = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;

  parser.decodePacket = function (data) {
    var pieces = data.match(regexp);

    if (!pieces) return {};

    var id = pieces[2] || ''
      , data = pieces[5] || ''
      , packet = {
            type: packets[pieces[1]]
          , endpoint: pieces[4] || ''
        };

    // whether we need to acknowledge the packet
    if (id) {
      packet.id = id;
      if (pieces[3])
        packet.ack = 'data';
      else
        packet.ack = true;
    }

    // handle different packet types
    switch (packet.type) {
      case 'error':
        var pieces = data.split('+');
        packet.reason = reasons[pieces[0]] || '';
        packet.advice = advice[pieces[1]] || '';
        break;

      case 'message':
        packet.data = data || '';
        break;

      case 'event':
        try {
          var opts = JSON.parse(data);
          packet.name = opts.name;
          packet.args = opts.args;
        } catch (e) { }

        packet.args = packet.args || [];
        break;

      case 'json':
        try {
          packet.data = JSON.parse(data);
        } catch (e) { }
        break;

      case 'connect':
        packet.qs = data || '';
        break;

      case 'ack':
        var pieces = data.match(/^([0-9]+)(\+)?(.*)/);
        if (pieces) {
          packet.ackId = pieces[1];
          packet.args = [];

          if (pieces[3]) {
            try {
              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];
            } catch (e) { }
          }
        }
        break;

      case 'disconnect':
      case 'heartbeat':
        break;
    };

    return packet;
  };

  /**
   * Decodes data payload. Detects multiple messages
   *
   * @return {Array} messages
   * @api public
   */

  parser.decodePayload = function (data) {
    // IE doesn't like data[i] for unicode chars, charAt works fine
    if (data.charAt(0) == '\ufffd') {
      var ret = [];

      for (var i = 1, length = ''; i < data.length; i++) {
        if (data.charAt(i) == '\ufffd') {
          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));
          i += Number(length) + 1;
          length = '';
        } else {
          length += data.charAt(i);
        }
      }

      return ret;
    } else {
      return [parser.decodePacket(data)];
    }
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.Transport = Transport;

  /**
   * This is the transport template for all supported transport methods.
   *
   * @constructor
   * @api public
   */

  function Transport (socket, sessid) {
    this.socket = socket;
    this.sessid = sessid;
  };

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(Transport, io.EventEmitter);


  /**
   * Indicates whether heartbeats is enabled for this transport
   *
   * @api private
   */

  Transport.prototype.heartbeats = function () {
    return true;
  };

  /**
   * Handles the response from the server. When a new response is received
   * it will automatically update the timeout, decode the message and
   * forwards the response to the onMessage function for further processing.
   *
   * @param {String} data Response from the server.
   * @api private
   */

  Transport.prototype.onData = function (data) {
    this.clearCloseTimeout();

    // If the connection in currently open (or in a reopening state) reset the close
    // timeout since we have just received data. This check is necessary so
    // that we don't reset the timeout on an explicitly disconnected connection.
    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {
      this.setCloseTimeout();
    }

    if (data !== '') {
      // todo: we should only do decodePayload for xhr transports
      var msgs = io.parser.decodePayload(data);

      if (msgs && msgs.length) {
        for (var i = 0, l = msgs.length; i < l; i++) {
          this.onPacket(msgs[i]);
        }
      }
    }

    return this;
  };

  /**
   * Handles packets.
   *
   * @api private
   */

  Transport.prototype.onPacket = function (packet) {
    this.socket.setHeartbeatTimeout();

    if (packet.type == 'heartbeat') {
      return this.onHeartbeat();
    }

    if (packet.type == 'connect' && packet.endpoint == '') {
      this.onConnect();
    }

    if (packet.type == 'error' && packet.advice == 'reconnect') {
      this.isOpen = false;
    }

    this.socket.onPacket(packet);

    return this;
  };

  /**
   * Sets close timeout
   *
   * @api private
   */

  Transport.prototype.setCloseTimeout = function () {
    if (!this.closeTimeout) {
      var self = this;

      this.closeTimeout = setTimeout(function () {
        self.onDisconnect();
      }, this.socket.closeTimeout);
    }
  };

  /**
   * Called when transport disconnects.
   *
   * @api private
   */

  Transport.prototype.onDisconnect = function () {
    if (this.isOpen) this.close();
    this.clearTimeouts();
    this.socket.onDisconnect();
    return this;
  };

  /**
   * Called when transport connects
   *
   * @api private
   */

  Transport.prototype.onConnect = function () {
    this.socket.onConnect();
    return this;
  };

  /**
   * Clears close timeout
   *
   * @api private
   */

  Transport.prototype.clearCloseTimeout = function () {
    if (this.closeTimeout) {
      clearTimeout(this.closeTimeout);
      this.closeTimeout = null;
    }
  };

  /**
   * Clear timeouts
   *
   * @api private
   */

  Transport.prototype.clearTimeouts = function () {
    this.clearCloseTimeout();

    if (this.reopenTimeout) {
      clearTimeout(this.reopenTimeout);
    }
  };

  /**
   * Sends a packet
   *
   * @param {Object} packet object.
   * @api private
   */

  Transport.prototype.packet = function (packet) {
    this.send(io.parser.encodePacket(packet));
  };

  /**
   * Send the received heartbeat message back to server. So the server
   * knows we are still connected.
   *
   * @param {String} heartbeat Heartbeat response from the server.
   * @api private
   */

  Transport.prototype.onHeartbeat = function (heartbeat) {
    this.packet({ type: 'heartbeat' });
  };

  /**
   * Called when the transport opens.
   *
   * @api private
   */

  Transport.prototype.onOpen = function () {
    this.isOpen = true;
    this.clearCloseTimeout();
    this.socket.onOpen();
  };

  /**
   * Notifies the base when the connection with the Socket.IO server
   * has been disconnected.
   *
   * @api private
   */

  Transport.prototype.onClose = function () {
    var self = this;

    /* FIXME: reopen delay causing a infinit loop
    this.reopenTimeout = setTimeout(function () {
      self.open();
    }, this.socket.options['reopen delay']);*/

    this.isOpen = false;
    this.socket.onClose();
    this.onDisconnect();
  };

  /**
   * Generates a connection url based on the Socket.IO URL Protocol.
   * See <https://github.com/learnboost/socket.io-node/> for more details.
   *
   * @returns {String} Connection url
   * @api private
   */

  Transport.prototype.prepareUrl = function () {
    var options = this.socket.options;

    return this.scheme() + '://'
      + options.host + ':' + options.port + '/'
      + options.resource + '/' + io.protocol
      + '/' + this.name + '/' + this.sessid;
  };

  /**
   * Checks if the transport is ready to start a connection.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  Transport.prototype.ready = function (socket, fn) {
    fn.call(this);
  };
})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports.Socket = Socket;

  /**
   * Create a new `Socket.IO client` which can establish a persistent
   * connection with a Socket.IO enabled server.
   *
   * @api public
   */

  function Socket (options) {
    this.options = {
        port: 80
      , secure: false
      , document: 'document' in global ? document : false
      , resource: 'socket.io'
      , transports: io.transports
      , 'connect timeout': 10000
      , 'try multiple transports': true
      , 'reconnect': true
      , 'reconnection delay': 500
      , 'reconnection limit': Infinity
      , 'reopen delay': 3000
      , 'max reconnection attempts': 10
      , 'sync disconnect on unload': false
      , 'auto connect': true
      , 'flash policy port': 10843
      , 'manualFlush': false
    };

    io.util.merge(this.options, options);

    this.connected = false;
    this.open = false;
    this.connecting = false;
    this.reconnecting = false;
    this.namespaces = {};
    this.buffer = [];
    this.doBuffer = false;

    if (this.options['sync disconnect on unload'] &&
        (!this.isXDomain() || io.util.ua.hasCORS)) {
      var self = this;
      io.util.on(global, 'beforeunload', function () {
        self.disconnectSync();
      }, false);
    }

    if (this.options['auto connect']) {
      this.connect();
    }
};

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(Socket, io.EventEmitter);

  /**
   * Returns a namespace listener/emitter for this socket
   *
   * @api public
   */

  Socket.prototype.of = function (name) {
    if (!this.namespaces[name]) {
      this.namespaces[name] = new io.SocketNamespace(this, name);

      if (name !== '') {
        this.namespaces[name].packet({ type: 'connect' });
      }
    }

    return this.namespaces[name];
  };

  /**
   * Emits the given event to the Socket and all namespaces
   *
   * @api private
   */

  Socket.prototype.publish = function () {
    this.emit.apply(this, arguments);

    var nsp;

    for (var i in this.namespaces) {
      if (this.namespaces.hasOwnProperty(i)) {
        nsp = this.of(i);
        nsp.$emit.apply(nsp, arguments);
      }
    }
  };

  /**
   * Performs the handshake
   *
   * @api private
   */

  function empty () { };

  Socket.prototype.handshake = function (fn) {
    var self = this
      , options = this.options;

    function complete (data) {
      if (data instanceof Error) {
        self.connecting = false;
        self.onError(data.message);
      } else {
        fn.apply(null, data.split(':'));
      }
    };

    var url = [
          'http' + (options.secure ? 's' : '') + ':/'
        , options.host + ':' + options.port
        , options.resource
        , io.protocol
        , io.util.query(this.options.query, 't=' + +new Date)
      ].join('/');

    if (this.isXDomain() && !io.util.ua.hasCORS) {
      var insertAt = document.getElementsByTagName('script')[0]
        , script = document.createElement('script');

      script.src = url + '&jsonp=' + io.j.length;
      insertAt.parentNode.insertBefore(script, insertAt);

      io.j.push(function (data) {
        complete(data);
        script.parentNode.removeChild(script);
      });
    } else {
      var xhr = io.util.request();

      xhr.open('GET', url, true);
      if (this.isXDomain()) {
        xhr.withCredentials = true;
      }
      xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
          xhr.onreadystatechange = empty;

          if (xhr.status == 200) {
            complete(xhr.responseText);
          } else if (xhr.status == 403) {
            self.onError(xhr.responseText);
          } else {
            self.connecting = false;            
            !self.reconnecting && self.onError(xhr.responseText);
          }
        }
      };
      xhr.send(null);
    }
  };

  /**
   * Find an available transport based on the options supplied in the constructor.
   *
   * @api private
   */

  Socket.prototype.getTransport = function (override) {
    var transports = override || this.transports, match;

    for (var i = 0, transport; transport = transports[i]; i++) {
      if (io.Transport[transport]
        && io.Transport[transport].check(this)
        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {
        return new io.Transport[transport](this, this.sessionid);
      }
    }

    return null;
  };

  /**
   * Connects to the server.
   *
   * @param {Function} [fn] Callback.
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.connect = function (fn) {
    if (this.connecting) {
      return this;
    }

    var self = this;
    self.connecting = true;
    
    this.handshake(function (sid, heartbeat, close, transports) {
      self.sessionid = sid;
      self.closeTimeout = close * 1000;
      self.heartbeatTimeout = heartbeat * 1000;
      if(!self.transports)
          self.transports = self.origTransports = (transports ? io.util.intersect(
              transports.split(',')
            , self.options.transports
          ) : self.options.transports);

      self.setHeartbeatTimeout();

      function connect (transports){
        if (self.transport) self.transport.clearTimeouts();

        self.transport = self.getTransport(transports);
        if (!self.transport) return self.publish('connect_failed');

        // once the transport is ready
        self.transport.ready(self, function () {
          self.connecting = true;
          self.publish('connecting', self.transport.name);
          self.transport.open();

          if (self.options['connect timeout']) {
            self.connectTimeoutTimer = setTimeout(function () {
              if (!self.connected) {
                self.connecting = false;

                if (self.options['try multiple transports']) {
                  var remaining = self.transports;

                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=
                         self.transport.name) {}

                    if (remaining.length){
                      connect(remaining);
                    } else {
                      self.publish('connect_failed');
                    }
                }
              }
            }, self.options['connect timeout']);
          }
        });
      }

      connect(self.transports);

      self.once('connect', function (){
        clearTimeout(self.connectTimeoutTimer);

        fn && typeof fn == 'function' && fn();
      });
    });

    return this;
  };

  /**
   * Clears and sets a new heartbeat timeout using the value given by the
   * server during the handshake.
   *
   * @api private
   */

  Socket.prototype.setHeartbeatTimeout = function () {
    clearTimeout(this.heartbeatTimeoutTimer);
    if(this.transport && !this.transport.heartbeats()) return;

    var self = this;
    this.heartbeatTimeoutTimer = setTimeout(function () {
      self.transport.onClose();
    }, this.heartbeatTimeout);
  };

  /**
   * Sends a message.
   *
   * @param {Object} data packet.
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.packet = function (data) {
    if (this.connected && !this.doBuffer) {
      this.transport.packet(data);
    } else {
      this.buffer.push(data);
    }

    return this;
  };

  /**
   * Sets buffer state
   *
   * @api private
   */

  Socket.prototype.setBuffer = function (v) {
    this.doBuffer = v;

    if (!v && this.connected && this.buffer.length) {
      if (!this.options['manualFlush']) {
        this.flushBuffer();
      }
    }
  };

  /**
   * Flushes the buffer data over the wire.
   * To be invoked manually when 'manualFlush' is set to true.
   *
   * @api public
   */

  Socket.prototype.flushBuffer = function() {
    this.transport.payload(this.buffer);
    this.buffer = [];
  };
  

  /**
   * Disconnect the established connect.
   *
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.disconnect = function () {
    if (this.connected || this.connecting) {
      if (this.open) {
        this.of('').packet({ type: 'disconnect' });
      }

      // handle disconnection immediately
      this.onDisconnect('booted');
    }

    return this;
  };

  /**
   * Disconnects the socket with a sync XHR.
   *
   * @api private
   */

  Socket.prototype.disconnectSync = function () {
    // ensure disconnection
    var xhr = io.util.request();
    var uri = [
        'http' + (this.options.secure ? 's' : '') + ':/'
      , this.options.host + ':' + this.options.port
      , this.options.resource
      , io.protocol
      , ''
      , this.sessionid
    ].join('/') + '/?disconnect=1';

    xhr.open('GET', uri, false);
    xhr.send(null);

    // handle disconnection immediately
    this.onDisconnect('booted');
  };

  /**
   * Check if we need to use cross domain enabled transports. Cross domain would
   * be a different port or different domain name.
   *
   * @returns {Boolean}
   * @api private
   */

  Socket.prototype.isXDomain = function () {

    var port = global.location.port ||
      ('https:' == global.location.protocol ? 443 : 80);

    return this.options.host !== global.location.hostname 
      || this.options.port != port;
  };

  /**
   * Called upon handshake.
   *
   * @api private
   */

  Socket.prototype.onConnect = function () {
    if (!this.connected) {
      this.connected = true;
      this.connecting = false;
      if (!this.doBuffer) {
        // make sure to flush the buffer
        this.setBuffer(false);
      }
      this.emit('connect');
    }
  };

  /**
   * Called when the transport opens
   *
   * @api private
   */

  Socket.prototype.onOpen = function () {
    this.open = true;
  };

  /**
   * Called when the transport closes.
   *
   * @api private
   */

  Socket.prototype.onClose = function () {
    this.open = false;
    clearTimeout(this.heartbeatTimeoutTimer);
  };

  /**
   * Called when the transport first opens a connection
   *
   * @param text
   */

  Socket.prototype.onPacket = function (packet) {
    this.of(packet.endpoint).onPacket(packet);
  };

  /**
   * Handles an error.
   *
   * @api private
   */

  Socket.prototype.onError = function (err) {
    if (err && err.advice) {
      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {
        this.disconnect();
        if (this.options.reconnect) {
          this.reconnect();
        }
      }
    }

    this.publish('error', err && err.reason ? err.reason : err);
  };

  /**
   * Called when the transport disconnects.
   *
   * @api private
   */

  Socket.prototype.onDisconnect = function (reason) {
    var wasConnected = this.connected
      , wasConnecting = this.connecting;

    this.connected = false;
    this.connecting = false;
    this.open = false;

    if (wasConnected || wasConnecting) {
      this.transport.close();
      this.transport.clearTimeouts();
      if (wasConnected) {
        this.publish('disconnect', reason);

        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {
          this.reconnect();
        }
      }
    }
  };

  /**
   * Called upon reconnection.
   *
   * @api private
   */

  Socket.prototype.reconnect = function () {
    this.reconnecting = true;
    this.reconnectionAttempts = 0;
    this.reconnectionDelay = this.options['reconnection delay'];

    var self = this
      , maxAttempts = this.options['max reconnection attempts']
      , tryMultiple = this.options['try multiple transports']
      , limit = this.options['reconnection limit'];

    function reset () {
      if (self.connected) {
        for (var i in self.namespaces) {
          if (self.namespaces.hasOwnProperty(i) && '' !== i) {
              self.namespaces[i].packet({ type: 'connect' });
          }
        }
        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);
      }

      clearTimeout(self.reconnectionTimer);

      self.removeListener('connect_failed', maybeReconnect);
      self.removeListener('connect', maybeReconnect);

      self.reconnecting = false;

      delete self.reconnectionAttempts;
      delete self.reconnectionDelay;
      delete self.reconnectionTimer;
      delete self.redoTransports;

      self.options['try multiple transports'] = tryMultiple;
    };

    function maybeReconnect () {
      if (!self.reconnecting) {
        return;
      }

      if (self.connected) {
        return reset();
      };

      if (self.connecting && self.reconnecting) {
        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);
      }

      if (self.reconnectionAttempts++ >= maxAttempts) {
        if (!self.redoTransports) {
          self.on('connect_failed', maybeReconnect);
          self.options['try multiple transports'] = true;
          self.transports = self.origTransports;
          self.transport = self.getTransport();
          self.redoTransports = true;
          self.connect();
        } else {
          self.publish('reconnect_failed');
          reset();
        }
      } else {
        if (self.reconnectionDelay < limit) {
          self.reconnectionDelay *= 2; // exponential back off
        }

        self.connect();
        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);
        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);
      }
    };

    this.options['try multiple transports'] = false;
    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);

    this.on('connect', maybeReconnect);
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.SocketNamespace = SocketNamespace;

  /**
   * Socket namespace constructor.
   *
   * @constructor
   * @api public
   */

  function SocketNamespace (socket, name) {
    this.socket = socket;
    this.name = name || '';
    this.flags = {};
    this.json = new Flag(this, 'json');
    this.ackPackets = 0;
    this.acks = {};
  };

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(SocketNamespace, io.EventEmitter);

  /**
   * Copies emit since we override it
   *
   * @api private
   */

  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;

  /**
   * Creates a new namespace, by proxying the request to the socket. This
   * allows us to use the synax as we do on the server.
   *
   * @api public
   */

  SocketNamespace.prototype.of = function () {
    return this.socket.of.apply(this.socket, arguments);
  };

  /**
   * Sends a packet.
   *
   * @api private
   */

  SocketNamespace.prototype.packet = function (packet) {
    packet.endpoint = this.name;
    this.socket.packet(packet);
    this.flags = {};
    return this;
  };

  /**
   * Sends a message
   *
   * @api public
   */

  SocketNamespace.prototype.send = function (data, fn) {
    var packet = {
        type: this.flags.json ? 'json' : 'message'
      , data: data
    };

    if ('function' == typeof fn) {
      packet.id = ++this.ackPackets;
      packet.ack = true;
      this.acks[packet.id] = fn;
    }

    return this.packet(packet);
  };

  /**
   * Emits an event
   *
   * @api public
   */
  
  SocketNamespace.prototype.emit = function (name) {
    var args = Array.prototype.slice.call(arguments, 1)
      , lastArg = args[args.length - 1]
      , packet = {
            type: 'event'
          , name: name
        };

    if ('function' == typeof lastArg) {
      packet.id = ++this.ackPackets;
      packet.ack = 'data';
      this.acks[packet.id] = lastArg;
      args = args.slice(0, args.length - 1);
    }

    packet.args = args;

    return this.packet(packet);
  };

  /**
   * Disconnects the namespace
   *
   * @api private
   */

  SocketNamespace.prototype.disconnect = function () {
    if (this.name === '') {
      this.socket.disconnect();
    } else {
      this.packet({ type: 'disconnect' });
      this.$emit('disconnect');
    }

    return this;
  };

  /**
   * Handles a packet
   *
   * @api private
   */

  SocketNamespace.prototype.onPacket = function (packet) {
    var self = this;

    function ack () {
      self.packet({
          type: 'ack'
        , args: io.util.toArray(arguments)
        , ackId: packet.id
      });
    };

    switch (packet.type) {
      case 'connect':
        this.$emit('connect');
        break;

      case 'disconnect':
        if (this.name === '') {
          this.socket.onDisconnect(packet.reason || 'booted');
        } else {
          this.$emit('disconnect', packet.reason);
        }
        break;

      case 'message':
      case 'json':
        var params = ['message', packet.data];

        if (packet.ack == 'data') {
          params.push(ack);
        } else if (packet.ack) {
          this.packet({ type: 'ack', ackId: packet.id });
        }

        this.$emit.apply(this, params);
        break;

      case 'event':
        var params = [packet.name].concat(packet.args);

        if (packet.ack == 'data')
          params.push(ack);

        this.$emit.apply(this, params);
        break;

      case 'ack':
        if (this.acks[packet.ackId]) {
          this.acks[packet.ackId].apply(this, packet.args);
          delete this.acks[packet.ackId];
        }
        break;

      case 'error':
        if (packet.advice){
          this.socket.onError(packet);
        } else {
          if (packet.reason == 'unauthorized') {
            this.$emit('connect_failed', packet.reason);
          } else {
            this.$emit('error', packet.reason);
          }
        }
        break;
    }
  };

  /**
   * Flag interface.
   *
   * @api private
   */

  function Flag (nsp, name) {
    this.namespace = nsp;
    this.name = name;
  };

  /**
   * Send a message
   *
   * @api public
   */

  Flag.prototype.send = function () {
    this.namespace.flags[this.name] = true;
    this.namespace.send.apply(this.namespace, arguments);
  };

  /**
   * Emit an event
   *
   * @api public
   */

  Flag.prototype.emit = function () {
    this.namespace.flags[this.name] = true;
    this.namespace.emit.apply(this.namespace, arguments);
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports.websocket = WS;

  /**
   * The WebSocket transport uses the HTML5 WebSocket API to establish an
   * persistent connection with the Socket.IO server. This transport will also
   * be inherited by the FlashSocket fallback as it provides a API compatible
   * polyfill for the WebSockets.
   *
   * @constructor
   * @extends {io.Transport}
   * @api public
   */

  function WS (socket) {
    io.Transport.apply(this, arguments);
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(WS, io.Transport);

  /**
   * Transport name
   *
   * @api public
   */

  WS.prototype.name = 'websocket';

  /**
   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach
   * all the appropriate listeners to handle the responses from the server.
   *
   * @returns {Transport}
   * @api public
   */

  WS.prototype.open = function () {
    var query = io.util.query(this.socket.options.query)
      , self = this
      , Socket


    if (!Socket) {
      Socket = global.MozWebSocket || global.WebSocket;
    }

    this.websocket = new Socket(this.prepareUrl() + query);

    this.websocket.onopen = function () {
      self.onOpen();
      self.socket.setBuffer(false);
    };
    this.websocket.onmessage = function (ev) {
      self.onData(ev.data);
    };
    this.websocket.onclose = function () {
      self.onClose();
      self.socket.setBuffer(true);
    };
    this.websocket.onerror = function (e) {
      self.onError(e);
    };

    return this;
  };

  /**
   * Send a message to the Socket.IO server. The message will automatically be
   * encoded in the correct message format.
   *
   * @returns {Transport}
   * @api public
   */

  // Do to a bug in the current IDevices browser, we need to wrap the send in a 
  // setTimeout, when they resume from sleeping the browser will crash if 
  // we don't allow the browser time to detect the socket has been closed
  if (io.util.ua.iDevice) {
    WS.prototype.send = function (data) {
      var self = this;
      setTimeout(function() {
         self.websocket.send(data);
      },0);
      return this;
    };
  } else {
    WS.prototype.send = function (data) {
      this.websocket.send(data);
      return this;
    };
  }

  /**
   * Payload
   *
   * @api private
   */

  WS.prototype.payload = function (arr) {
    for (var i = 0, l = arr.length; i < l; i++) {
      this.packet(arr[i]);
    }
    return this;
  };

  /**
   * Disconnect the established `WebSocket` connection.
   *
   * @returns {Transport}
   * @api public
   */

  WS.prototype.close = function () {
    this.websocket.close();
    return this;
  };

  /**
   * Handle the errors that `WebSocket` might be giving when we
   * are attempting to connect or send messages.
   *
   * @param {Error} e The error.
   * @api private
   */

  WS.prototype.onError = function (e) {
    this.socket.onError(e);
  };

  /**
   * Returns the appropriate scheme for the URI generation.
   *
   * @api private
   */
  WS.prototype.scheme = function () {
    return this.socket.options.secure ? 'wss' : 'ws';
  };

  /**
   * Checks if the browser has support for native `WebSockets` and that
   * it's not the polyfill created for the FlashSocket transport.
   *
   * @return {Boolean}
   * @api public
   */

  WS.check = function () {
    return ('WebSocket' in global && !('__addTask' in WebSocket))
          || 'MozWebSocket' in global;
  };

  /**
   * Check if the `WebSocket` transport support cross domain communications.
   *
   * @returns {Boolean}
   * @api public
   */

  WS.xdomainCheck = function () {
    return true;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('websocket');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.flashsocket = Flashsocket;

  /**
   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket
   * specification. It uses a .swf file to communicate with the server. If you want
   * to serve the .swf file from a other server than where the Socket.IO script is
   * coming from you need to use the insecure version of the .swf. More information
   * about this can be found on the github page.
   *
   * @constructor
   * @extends {io.Transport.websocket}
   * @api public
   */

  function Flashsocket () {
    io.Transport.websocket.apply(this, arguments);
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(Flashsocket, io.Transport.websocket);

  /**
   * Transport name
   *
   * @api public
   */

  Flashsocket.prototype.name = 'flashsocket';

  /**
   * Disconnect the established `FlashSocket` connection. This is done by adding a 
   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` 
   * transport.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.open = function () {
    var self = this
      , args = arguments;

    WebSocket.__addTask(function () {
      io.Transport.websocket.prototype.open.apply(self, args);
    });
    return this;
  };
  
  /**
   * Sends a message to the Socket.IO server. This is done by adding a new
   * task to the FlashSocket. The rest will be handled off by the `WebSocket` 
   * transport.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.send = function () {
    var self = this, args = arguments;
    WebSocket.__addTask(function () {
      io.Transport.websocket.prototype.send.apply(self, args);
    });
    return this;
  };

  /**
   * Disconnects the established `FlashSocket` connection.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.close = function () {
    WebSocket.__tasks.length = 0;
    io.Transport.websocket.prototype.close.call(this);
    return this;
  };

  /**
   * The WebSocket fall back needs to append the flash container to the body
   * element, so we need to make sure we have access to it. Or defer the call
   * until we are sure there is a body element.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  Flashsocket.prototype.ready = function (socket, fn) {
    function init () {
      var options = socket.options
        , port = options['flash policy port']
        , path = [
              'http' + (options.secure ? 's' : '') + ':/'
            , options.host + ':' + options.port
            , options.resource
            , 'static/flashsocket'
            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'
          ];

      // Only start downloading the swf file when the checked that this browser
      // actually supports it
      if (!Flashsocket.loaded) {
        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {
          // Set the correct file based on the XDomain settings
          WEB_SOCKET_SWF_LOCATION = path.join('/');
        }

        if (port !== 843) {
          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);
        }

        WebSocket.__initialize();
        Flashsocket.loaded = true;
      }

      fn.call(self);
    }

    var self = this;
    if (document.body) return init();

    io.util.load(init);
  };

  /**
   * Check if the FlashSocket transport is supported as it requires that the Adobe
   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if
   * the polyfill is correctly loaded.
   *
   * @returns {Boolean}
   * @api public
   */

  Flashsocket.check = function () {
    if (
        typeof WebSocket == 'undefined'
      || !('__initialize' in WebSocket) || !swfobject
    ) return false;

    return swfobject.getFlashPlayerVersion().major >= 10;
  };

  /**
   * Check if the FlashSocket transport can be used as cross domain / cross origin 
   * transport. Because we can't see which type (secure or insecure) of .swf is used
   * we will just return true.
   *
   * @returns {Boolean}
   * @api public
   */

  Flashsocket.xdomainCheck = function () {
    return true;
  };

  /**
   * Disable AUTO_INITIALIZATION
   */

  if (typeof window != 'undefined') {
    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;
  }

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('flashsocket');
})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/
if ('undefined' != typeof window) {
var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O[(['Active'].concat('Object').join('X'))]!=D){try{var ad=new window[(['Active'].concat('Object').join('X'))](W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?(['Active'].concat('').join('X')):"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();
}
// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>
// License: New BSD License
// Reference: http://dev.w3.org/html5/websockets/
// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol

(function() {
  
  if ('undefined' == typeof window || window.WebSocket) return;

  var console = window.console;
  if (!console || !console.log || !console.error) {
    console = {log: function(){ }, error: function(){ }};
  }
  
  if (!swfobject.hasFlashPlayerVersion("10.0.0")) {
    console.error("Flash Player >= 10.0.0 is required.");
    return;
  }
  if (location.protocol == "file:") {
    console.error(
      "WARNING: web-socket-js doesn't work in file:///... URL " +
      "unless you set Flash Security Settings properly. " +
      "Open the page via Web server i.e. http://...");
  }

  /**
   * This class represents a faux web socket.
   * @param {string} url
   * @param {array or string} protocols
   * @param {string} proxyHost
   * @param {int} proxyPort
   * @param {string} headers
   */
  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {
    var self = this;
    self.__id = WebSocket.__nextId++;
    WebSocket.__instances[self.__id] = self;
    self.readyState = WebSocket.CONNECTING;
    self.bufferedAmount = 0;
    self.__events = {};
    if (!protocols) {
      protocols = [];
    } else if (typeof protocols == "string") {
      protocols = [protocols];
    }
    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.
    // Otherwise, when onopen fires immediately, onopen is called before it is set.
    setTimeout(function() {
      WebSocket.__addTask(function() {
        WebSocket.__flash.create(
            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);
      });
    }, 0);
  };

  /**
   * Send data to the web socket.
   * @param {string} data  The data to send to the socket.
   * @return {boolean}  True for success, false for failure.
   */
  WebSocket.prototype.send = function(data) {
    if (this.readyState == WebSocket.CONNECTING) {
      throw "INVALID_STATE_ERR: Web Socket connection has not been established";
    }
    // We use encodeURIComponent() here, because FABridge doesn't work if
    // the argument includes some characters. We don't use escape() here
    // because of this:
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions
    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't
    // preserve all Unicode characters either e.g. "\uffff" in Firefox.
    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require
    // additional testing.
    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));
    if (result < 0) { // success
      return true;
    } else {
      this.bufferedAmount += result;
      return false;
    }
  };

  /**
   * Close this web socket gracefully.
   */
  WebSocket.prototype.close = function() {
    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {
      return;
    }
    this.readyState = WebSocket.CLOSING;
    WebSocket.__flash.close(this.__id);
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {string} type
   * @param {function} listener
   * @param {boolean} useCapture
   * @return void
   */
  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {
    if (!(type in this.__events)) {
      this.__events[type] = [];
    }
    this.__events[type].push(listener);
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {string} type
   * @param {function} listener
   * @param {boolean} useCapture
   * @return void
   */
  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {
    if (!(type in this.__events)) return;
    var events = this.__events[type];
    for (var i = events.length - 1; i >= 0; --i) {
      if (events[i] === listener) {
        events.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {Event} event
   * @return void
   */
  WebSocket.prototype.dispatchEvent = function(event) {
    var events = this.__events[event.type] || [];
    for (var i = 0; i < events.length; ++i) {
      events[i](event);
    }
    var handler = this["on" + event.type];
    if (handler) handler(event);
  };

  /**
   * Handles an event from Flash.
   * @param {Object} flashEvent
   */
  WebSocket.prototype.__handleEvent = function(flashEvent) {
    if ("readyState" in flashEvent) {
      this.readyState = flashEvent.readyState;
    }
    if ("protocol" in flashEvent) {
      this.protocol = flashEvent.protocol;
    }
    
    var jsEvent;
    if (flashEvent.type == "open" || flashEvent.type == "error") {
      jsEvent = this.__createSimpleEvent(flashEvent.type);
    } else if (flashEvent.type == "close") {
      // TODO implement jsEvent.wasClean
      jsEvent = this.__createSimpleEvent("close");
    } else if (flashEvent.type == "message") {
      var data = decodeURIComponent(flashEvent.message);
      jsEvent = this.__createMessageEvent("message", data);
    } else {
      throw "unknown event type: " + flashEvent.type;
    }
    
    this.dispatchEvent(jsEvent);
  };
  
  WebSocket.prototype.__createSimpleEvent = function(type) {
    if (document.createEvent && window.Event) {
      var event = document.createEvent("Event");
      event.initEvent(type, false, false);
      return event;
    } else {
      return {type: type, bubbles: false, cancelable: false};
    }
  };
  
  WebSocket.prototype.__createMessageEvent = function(type, data) {
    if (document.createEvent && window.MessageEvent && !window.opera) {
      var event = document.createEvent("MessageEvent");
      event.initMessageEvent("message", false, false, data, null, null, window, null);
      return event;
    } else {
      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.
      return {type: type, data: data, bubbles: false, cancelable: false};
    }
  };
  
  /**
   * Define the WebSocket readyState enumeration.
   */
  WebSocket.CONNECTING = 0;
  WebSocket.OPEN = 1;
  WebSocket.CLOSING = 2;
  WebSocket.CLOSED = 3;

  WebSocket.__flash = null;
  WebSocket.__instances = {};
  WebSocket.__tasks = [];
  WebSocket.__nextId = 0;
  
  /**
   * Load a new flash security policy file.
   * @param {string} url
   */
  WebSocket.loadFlashPolicyFile = function(url){
    WebSocket.__addTask(function() {
      WebSocket.__flash.loadManualPolicyFile(url);
    });
  };

  /**
   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.
   */
  WebSocket.__initialize = function() {
    if (WebSocket.__flash) return;
    
    if (WebSocket.__swfLocation) {
      // For backword compatibility.
      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;
    }
    if (!window.WEB_SOCKET_SWF_LOCATION) {
      console.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
      return;
    }
    var container = document.createElement("div");
    container.id = "webSocketContainer";
    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents
    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).
    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash
    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is
    // the best we can do as far as we know now.
    container.style.position = "absolute";
    if (WebSocket.__isFlashLite()) {
      container.style.left = "0px";
      container.style.top = "0px";
    } else {
      container.style.left = "-100px";
      container.style.top = "-100px";
    }
    var holder = document.createElement("div");
    holder.id = "webSocketFlash";
    container.appendChild(holder);
    document.body.appendChild(container);
    // See this article for hasPriority:
    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html
    swfobject.embedSWF(
      WEB_SOCKET_SWF_LOCATION,
      "webSocketFlash",
      "1" /* width */,
      "1" /* height */,
      "10.0.0" /* SWF version */,
      null,
      null,
      {hasPriority: true, swliveconnect : true, allowScriptAccess: "always"},
      null,
      function(e) {
        if (!e.success) {
          console.error("[WebSocket] swfobject.embedSWF failed");
        }
      });
  };
  
  /**
   * Called by Flash to notify JS that it's fully loaded and ready
   * for communication.
   */
  WebSocket.__onFlashInitialized = function() {
    // We need to set a timeout here to avoid round-trip calls
    // to flash during the initialization process.
    setTimeout(function() {
      WebSocket.__flash = document.getElementById("webSocketFlash");
      WebSocket.__flash.setCallerUrl(location.href);
      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
      for (var i = 0; i < WebSocket.__tasks.length; ++i) {
        WebSocket.__tasks[i]();
      }
      WebSocket.__tasks = [];
    }, 0);
  };
  
  /**
   * Called by Flash to notify WebSockets events are fired.
   */
  WebSocket.__onFlashEvent = function() {
    setTimeout(function() {
      try {
        // Gets events using receiveEvents() instead of getting it from event object
        // of Flash event. This is to make sure to keep message order.
        // It seems sometimes Flash events don't arrive in the same order as they are sent.
        var events = WebSocket.__flash.receiveEvents();
        for (var i = 0; i < events.length; ++i) {
          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);
        }
      } catch (e) {
        console.error(e);
      }
    }, 0);
    return true;
  };
  
  // Called by Flash.
  WebSocket.__log = function(message) {
    console.log(decodeURIComponent(message));
  };
  
  // Called by Flash.
  WebSocket.__error = function(message) {
    console.error(decodeURIComponent(message));
  };
  
  WebSocket.__addTask = function(task) {
    if (WebSocket.__flash) {
      task();
    } else {
      WebSocket.__tasks.push(task);
    }
  };
  
  /**
   * Test if the browser is running flash lite.
   * @return {boolean} True if flash lite is running, false otherwise.
   */
  WebSocket.__isFlashLite = function() {
    if (!window.navigator || !window.navigator.mimeTypes) {
      return false;
    }
    var mimeType = window.navigator.mimeTypes["application/x-shockwave-flash"];
    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {
      return false;
    }
    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;
  };
  
  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {
    if (window.addEventListener) {
      window.addEventListener("load", function(){
        WebSocket.__initialize();
      }, false);
    } else {
      window.attachEvent("onload", function(){
        WebSocket.__initialize();
      });
    }
  }
  
})();

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   *
   * @api public
   */

  exports.XHR = XHR;

  /**
   * XHR constructor
   *
   * @costructor
   * @api public
   */

  function XHR (socket) {
    if (!socket) return;

    io.Transport.apply(this, arguments);
    this.sendBuffer = [];
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(XHR, io.Transport);

  /**
   * Establish a connection
   *
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.open = function () {
    this.socket.setBuffer(false);
    this.onOpen();
    this.get();

    // we need to make sure the request succeeds since we have no indication
    // whether the request opened or not until it succeeded.
    this.setCloseTimeout();

    return this;
  };

  /**
   * Check if we need to send data to the Socket.IO server, if we have data in our
   * buffer we encode it and forward it to the `post` method.
   *
   * @api private
   */

  XHR.prototype.payload = function (payload) {
    var msgs = [];

    for (var i = 0, l = payload.length; i < l; i++) {
      msgs.push(io.parser.encodePacket(payload[i]));
    }

    this.send(io.parser.encodePayload(msgs));
  };

  /**
   * Send data to the Socket.IO server.
   *
   * @param data The message
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.send = function (data) {
    this.post(data);
    return this;
  };

  /**
   * Posts a encoded message to the Socket.IO server.
   *
   * @param {String} data A encoded message.
   * @api private
   */

  function empty () { };

  XHR.prototype.post = function (data) {
    var self = this;
    this.socket.setBuffer(true);

    function stateChange () {
      if (this.readyState == 4) {
        this.onreadystatechange = empty;
        self.posting = false;

        if (this.status == 200){
          self.socket.setBuffer(false);
        } else {
          self.onClose();
        }
      }
    }

    function onload () {
      this.onload = empty;
      self.socket.setBuffer(false);
    };

    this.sendXHR = this.request('POST');

    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {
      this.sendXHR.onload = this.sendXHR.onerror = onload;
    } else {
      this.sendXHR.onreadystatechange = stateChange;
    }

    this.sendXHR.send(data);
  };

  /**
   * Disconnects the established `XHR` connection.
   *
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.close = function () {
    this.onClose();
    return this;
  };

  /**
   * Generates a configured XHR request
   *
   * @param {String} url The url that needs to be requested.
   * @param {String} method The method the request should use.
   * @returns {XMLHttpRequest}
   * @api private
   */

  XHR.prototype.request = function (method) {
    var req = io.util.request(this.socket.isXDomain())
      , query = io.util.query(this.socket.options.query, 't=' + +new Date);

    req.open(method || 'GET', this.prepareUrl() + query, true);

    if (method == 'POST') {
      try {
        if (req.setRequestHeader) {
          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        } else {
          // XDomainRequest
          req.contentType = 'text/plain';
        }
      } catch (e) {}
    }

    return req;
  };

  /**
   * Returns the scheme to use for the transport URLs.
   *
   * @api private
   */

  XHR.prototype.scheme = function () {
    return this.socket.options.secure ? 'https' : 'http';
  };

  /**
   * Check if the XHR transports are supported
   *
   * @param {Boolean} xdomain Check if we support cross domain requests.
   * @returns {Boolean}
   * @api public
   */

  XHR.check = function (socket, xdomain) {
    try {
      var request = io.util.request(xdomain),
          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),
          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),
          isXProtocol = (global.location && socketProtocol != global.location.protocol);
      if (request && !(usesXDomReq && isXProtocol)) {
        return true;
      }
    } catch(e) {}

    return false;
  };

  /**
   * Check if the XHR transport supports cross domain requests.
   *
   * @returns {Boolean}
   * @api public
   */

  XHR.xdomainCheck = function (socket) {
    return XHR.check(socket, true);
  };

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.htmlfile = HTMLFile;

  /**
   * The HTMLFile transport creates a `forever iframe` based transport
   * for Internet Explorer. Regular forever iframe implementations will 
   * continuously trigger the browsers buzy indicators. If the forever iframe
   * is created inside a `htmlfile` these indicators will not be trigged.
   *
   * @constructor
   * @extends {io.Transport.XHR}
   * @api public
   */

  function HTMLFile (socket) {
    io.Transport.XHR.apply(this, arguments);
  };

  /**
   * Inherits from XHR transport.
   */

  io.util.inherit(HTMLFile, io.Transport.XHR);

  /**
   * Transport name
   *
   * @api public
   */

  HTMLFile.prototype.name = 'htmlfile';

  /**
   * Creates a new Ac...eX `htmlfile` with a forever loading iframe
   * that can be used to listen to messages. Inside the generated
   * `htmlfile` a reference will be made to the HTMLFile transport.
   *
   * @api private
   */

  HTMLFile.prototype.get = function () {
    this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
    this.doc.open();
    this.doc.write('<html></html>');
    this.doc.close();
    this.doc.parentWindow.s = this;

    var iframeC = this.doc.createElement('div');
    iframeC.className = 'socketio';

    this.doc.body.appendChild(iframeC);
    this.iframe = this.doc.createElement('iframe');

    iframeC.appendChild(this.iframe);

    var self = this
      , query = io.util.query(this.socket.options.query, 't='+ +new Date);

    this.iframe.src = this.prepareUrl() + query;

    io.util.on(window, 'unload', function () {
      self.destroy();
    });
  };

  /**
   * The Socket.IO server will write script tags inside the forever
   * iframe, this function will be used as callback for the incoming
   * information.
   *
   * @param {String} data The message
   * @param {document} doc Reference to the context
   * @api private
   */

  HTMLFile.prototype._ = function (data, doc) {
    this.onData(data);
    try {
      var script = doc.getElementsByTagName('script')[0];
      script.parentNode.removeChild(script);
    } catch (e) { }
  };

  /**
   * Destroy the established connection, iframe and `htmlfile`.
   * And calls the `CollectGarbage` function of Internet Explorer
   * to release the memory.
   *
   * @api private
   */

  HTMLFile.prototype.destroy = function () {
    if (this.iframe){
      try {
        this.iframe.src = 'about:blank';
      } catch(e){}

      this.doc = null;
      this.iframe.parentNode.removeChild(this.iframe);
      this.iframe = null;

      CollectGarbage();
    }
  };

  /**
   * Disconnects the established connection.
   *
   * @returns {Transport} Chaining.
   * @api public
   */

  HTMLFile.prototype.close = function () {
    this.destroy();
    return io.Transport.XHR.prototype.close.call(this);
  };

  /**
   * Checks if the browser supports this transport. The browser
   * must have an `Ac...eXObject` implementation.
   *
   * @return {Boolean}
   * @api public
   */

  HTMLFile.check = function (socket) {
    if (typeof window != "undefined" && (['Active'].concat('Object').join('X')) in window){
      try {
        var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
        return a && io.Transport.XHR.check(socket);
      } catch(e){}
    }
    return false;
  };

  /**
   * Check if cross domain requests are supported.
   *
   * @returns {Boolean}
   * @api public
   */

  HTMLFile.xdomainCheck = function () {
    // we can probably do handling for sub-domains, we should
    // test that it's cross domain but a subdomain here
    return false;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('htmlfile');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports['xhr-polling'] = XHRPolling;

  /**
   * The XHR-polling transport uses long polling XHR requests to create a
   * "persistent" connection with the server.
   *
   * @constructor
   * @api public
   */

  function XHRPolling () {
    io.Transport.XHR.apply(this, arguments);
  };

  /**
   * Inherits from XHR transport.
   */

  io.util.inherit(XHRPolling, io.Transport.XHR);

  /**
   * Merge the properties from XHR transport
   */

  io.util.merge(XHRPolling, io.Transport.XHR);

  /**
   * Transport name
   *
   * @api public
   */

  XHRPolling.prototype.name = 'xhr-polling';

  /**
   * Indicates whether heartbeats is enabled for this transport
   *
   * @api private
   */

  XHRPolling.prototype.heartbeats = function () {
    return false;
  };

  /** 
   * Establish a connection, for iPhone and Android this will be done once the page
   * is loaded.
   *
   * @returns {Transport} Chaining.
   * @api public
   */

  XHRPolling.prototype.open = function () {
    var self = this;

    io.Transport.XHR.prototype.open.call(self);
    return false;
  };

  /**
   * Starts a XHR request to wait for incoming messages.
   *
   * @api private
   */

  function empty () {};

  XHRPolling.prototype.get = function () {
    if (!this.isOpen) return;

    var self = this;

    function stateChange () {
      if (this.readyState == 4) {
        this.onreadystatechange = empty;

        if (this.status == 200) {
          self.onData(this.responseText);
          self.get();
        } else {
          self.onClose();
        }
      }
    };

    function onload () {
      this.onload = empty;
      this.onerror = empty;
      self.retryCounter = 1;
      self.onData(this.responseText);
      self.get();
    };

    function onerror () {
      self.retryCounter ++;
      if(!self.retryCounter || self.retryCounter > 3) {
        self.onClose();  
      } else {
        self.get();
      }
    };

    this.xhr = this.request();

    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {
      this.xhr.onload = onload;
      this.xhr.onerror = onerror;
    } else {
      this.xhr.onreadystatechange = stateChange;
    }

    this.xhr.send(null);
  };

  /**
   * Handle the unclean close behavior.
   *
   * @api private
   */

  XHRPolling.prototype.onClose = function () {
    io.Transport.XHR.prototype.onClose.call(this);

    if (this.xhr) {
      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;
      try {
        this.xhr.abort();
      } catch(e){}
      this.xhr = null;
    }
  };

  /**
   * Webkit based browsers show a infinit spinner when you start a XHR request
   * before the browsers onload event is called so we need to defer opening of
   * the transport until the onload event is called. Wrapping the cb in our
   * defer method solve this.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  XHRPolling.prototype.ready = function (socket, fn) {
    var self = this;

    io.util.defer(function () {
      fn.call(self);
    });
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('xhr-polling');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {
  /**
   * There is a way to hide the loading indicator in Firefox. If you create and
   * remove a iframe it will stop showing the current loading indicator.
   * Unfortunately we can't feature detect that and UA sniffing is evil.
   *
   * @api private
   */

  var indicator = global.document && "MozAppearance" in
    global.document.documentElement.style;

  /**
   * Expose constructor.
   */

  exports['jsonp-polling'] = JSONPPolling;

  /**
   * The JSONP transport creates an persistent connection by dynamically
   * inserting a script tag in the page. This script tag will receive the
   * information of the Socket.IO server. When new information is received
   * it creates a new script tag for the new data stream.
   *
   * @constructor
   * @extends {io.Transport.xhr-polling}
   * @api public
   */

  function JSONPPolling (socket) {
    io.Transport['xhr-polling'].apply(this, arguments);

    this.index = io.j.length;

    var self = this;

    io.j.push(function (msg) {
      self._(msg);
    });
  };

  /**
   * Inherits from XHR polling transport.
   */

  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);

  /**
   * Transport name
   *
   * @api public
   */

  JSONPPolling.prototype.name = 'jsonp-polling';

  /**
   * Posts a encoded message to the Socket.IO server using an iframe.
   * The iframe is used because script tags can create POST based requests.
   * The iframe is positioned outside of the view so the user does not
   * notice it's existence.
   *
   * @param {String} data A encoded message.
   * @api private
   */

  JSONPPolling.prototype.post = function (data) {
    var self = this
      , query = io.util.query(
             this.socket.options.query
          , 't='+ (+new Date) + '&i=' + this.index
        );

    if (!this.form) {
      var form = document.createElement('form')
        , area = document.createElement('textarea')
        , id = this.iframeId = 'socketio_iframe_' + this.index
        , iframe;

      form.className = 'socketio';
      form.style.position = 'absolute';
      form.style.top = '0px';
      form.style.left = '0px';
      form.style.display = 'none';
      form.target = id;
      form.method = 'POST';
      form.setAttribute('accept-charset', 'utf-8');
      area.name = 'd';
      form.appendChild(area);
      document.body.appendChild(form);

      this.form = form;
      this.area = area;
    }

    this.form.action = this.prepareUrl() + query;

    function complete () {
      initIframe();
      self.socket.setBuffer(false);
    };

    function initIframe () {
      if (self.iframe) {
        self.form.removeChild(self.iframe);
      }

      try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        iframe = document.createElement('<iframe name="'+ self.iframeId +'">');
      } catch (e) {
        iframe = document.createElement('iframe');
        iframe.name = self.iframeId;
      }

      iframe.id = self.iframeId;

      self.form.appendChild(iframe);
      self.iframe = iframe;
    };

    initIframe();

    // we temporarily stringify until we figure out how to prevent
    // browsers from turning `\n` into `\r\n` in form inputs
    this.area.value = io.JSON.stringify(data);

    try {
      this.form.submit();
    } catch(e) {}

    if (this.iframe.attachEvent) {
      iframe.onreadystatechange = function () {
        if (self.iframe.readyState == 'complete') {
          complete();
        }
      };
    } else {
      this.iframe.onload = complete;
    }

    this.socket.setBuffer(true);
  };

  /**
   * Creates a new JSONP poll that can be used to listen
   * for messages from the Socket.IO server.
   *
   * @api private
   */

  JSONPPolling.prototype.get = function () {
    var self = this
      , script = document.createElement('script')
      , query = io.util.query(
             this.socket.options.query
          , 't='+ (+new Date) + '&i=' + this.index
        );

    if (this.script) {
      this.script.parentNode.removeChild(this.script);
      this.script = null;
    }

    script.async = true;
    script.src = this.prepareUrl() + query;
    script.onerror = function () {
      self.onClose();
    };

    var insertAt = document.getElementsByTagName('script')[0];
    insertAt.parentNode.insertBefore(script, insertAt);
    this.script = script;

    if (indicator) {
      setTimeout(function () {
        var iframe = document.createElement('iframe');
        document.body.appendChild(iframe);
        document.body.removeChild(iframe);
      }, 100);
    }
  };

  /**
   * Callback function for the incoming message stream from the Socket.IO server.
   *
   * @param {String} data The message
   * @api private
   */

  JSONPPolling.prototype._ = function (msg) {
    this.onData(msg);
    if (this.isOpen) {
      this.get();
    }
    return this;
  };

  /**
   * The indicator hack only works after onload
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  JSONPPolling.prototype.ready = function (socket, fn) {
    var self = this;
    if (!indicator) return fn.call(this);

    io.util.load(function () {
      fn.call(self);
    });
  };

  /**
   * Checks if browser supports this transport.
   *
   * @return {Boolean}
   * @api public
   */

  JSONPPolling.check = function () {
    return 'document' in global;
  };

  /**
   * Check if cross domain requests are supported
   *
   * @returns {Boolean}
   * @api public
   */

  JSONPPolling.xdomainCheck = function () {
    return true;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('jsonp-polling');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

if (typeof define === "function" && define.amd) {
  define([], function () { return io; });
}
})();
//////////////////////////////////////////////////////////////////////////////////
// CloudCarousel V1.0.5
// (c) 2011 by R Cecco. <http://www.professorcloud.com>
// MIT License
//
// Reflection code based on plugin by Christophe Beyls <http://www.digitalia.be>
//
// Please retain this copyright header in all versions of the software
//////////////////////////////////////////////////////////////////////////////////
var matched, browser;

jQuery.uaMatch = function( ua ) {
    ua = ua.toLowerCase();

    var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
        /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
        /(msie) ([\w.]+)/.exec( ua ) ||
        ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
        [];

    return {
        browser: match[ 1 ] || "",
        version: match[ 2 ] || "0"
    };
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
    browser[ matched.browser ] = true;
    browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
    browser.webkit = true;
} else if ( browser.webkit ) {
    browser.safari = true;
}

jQuery.browser = browser;

(function($) {

	// START Reflection object.
	// Creates a reflection for underneath an image.
	// IE uses an image with IE specific filter properties, other browsers use the Canvas tag.	
	// The position and size of the reflection gets updated by updateAll() in Controller.
	function Reflection(img, reflHeight, opacity) {				
		
		var	reflection, cntx, imageWidth = img.width, imageHeight = img.width, gradient, parent;
	
		parent = $(img.parentNode);
		this.element = reflection = parent.append("<canvas class='reflection' style='position:absolute'/>").find(':last')[0];
        if ( !reflection.getContext &&  $.browser.msie) {
			this.element = reflection = parent.append("<img class='reflection' style='position:absolute'/>").find(':last')[0];					
			reflection.src = img.src;			
			reflection.style.filter = "flipv progid:DXImageTransform.Microsoft.Alpha(opacity=" + (opacity * 100) + ", style=1, finishOpacity=0, startx=0, starty=0, finishx=0, finishy=" + (reflHeight / imageHeight * 100) + ")";	
			
        } else {							
			cntx = reflection.getContext("2d");
			try {
				
				
				$(reflection).attr({width: imageWidth, height: reflHeight});
				cntx.save();
				cntx.translate(0, imageHeight-1);
				cntx.scale(1, -1);				
				cntx.drawImage(img, 0, 0, imageWidth, imageHeight);				
				cntx.restore();
				cntx.globalCompositeOperation = "destination-out";
				gradient = cntx.createLinearGradient(0, 0, 0, reflHeight);
				gradient.addColorStop(0, "rgba(255, 255, 255, " + (1 - opacity) + ")");
				gradient.addColorStop(1, "rgba(255, 255, 255, 1.0)");
				cntx.fillStyle = gradient;
				cntx.fillRect(0, 0, imageWidth, reflHeight);				
			} catch(e) {			
				return;
			}		
		}
		// Store a copy of the alt and title attrs into the reflection
		$(reflection).attr({ 'alt': $(img).attr('alt'), title: $(img).attr('title')} );	
				
	}	//END Reflection object

	// START Item object.
	// A wrapper object for items within the carousel.
	var	Item = function(imgIn, options)
	{								
		this.orgWidth = imgIn.width;			
		this.orgHeight = imgIn.height;		
		this.image = imgIn;
		this.reflection = null;					
		this.alt = imgIn.alt;
		this.title = imgIn.title;
		this.imageOK = false;		
		this.options = options;				
						
		this.imageOK = true;	
		
		if (this.options.reflHeight > 0)
		{													
			this.reflection = new Reflection(this.image, this.options.reflHeight, this.options.reflOpacity);					
		}
		$(this.image).css('position','absolute');	// Bizarre. This seems to reset image width to 0 on webkit!					
	};// END Item object
	
	
	// Controller object.
	// This handles moving all the items, dealing with mouse clicks etc.	
	var Controller = function(container, images, options)
	{						
		var	items = [], funcSin = Math.sin, funcCos = Math.cos, ctx=this;
		this.controlTimer = 0;
		this.stopped = false;
		//this.imagesLoaded = 0;
		this.container = container;
		this.xRadius = options.xRadius;
		this.yRadius = options.yRadius;
		this.showFrontTextTimer = 0;
		this.autoRotateTimer = 0;
		if (options.xRadius === 0)
		{
			this.xRadius = ($(container).width()/2.3);
		}
		if (options.yRadius === 0)
		{
			this.yRadius = ($(container).height()/6);
		}

		this.xCentre = options.xPos;
		this.yCentre = options.yPos;
		this.frontIndex = 0;	// Index of the item at the front
		
		// Start with the first item at the front.
		this.rotation = this.destRotation = Math.PI/2;
		this.timeDelay = 1000/options.FPS;
								
		// Turn on the infoBox
		if(options.altBox !== null)
		{
			$(options.altBox).css('display','block');	
			$(options.titleBox).css('display','block');	
		}
		// Turn on relative position for container to allow absolutely positioned elements
		// within it to work.
		$(container).css({ position:'relative', overflow:'hidden'} );
	
		$(options.buttonLeft).css('display','inline');
		$(options.buttonRight).css('display','inline');
		
		// Setup the buttons.
		$(options.buttonLeft).bind('mouseup',this,function(event){
			event.data.rotate(-1);	
			return false;
		});
		$(options.buttonRight).bind('mouseup',this,function(event){															
			event.data.rotate(1);	
			return false;
		});
		
		// Add code that makes tab and shift+tab scroll through items
		if (options.tabbingEl) {
			options.tabbingEl.bind('keydown',this,function(event){
	            if (event.keyCode == 9 && event.shiftKey) {
					event.data.rotate(-1);
	                event.preventDefault();
	                event.stopPropagation();
				} else if (event.keyCode == 9) {
					event.data.rotate(1);
	                event.preventDefault();
	                event.stopPropagation();
	            }
			});
		}
		
		// You will need this plugin for the mousewheel to work: http://plugins.jquery.com/project/mousewheel
		if (options.mouseWheel)
		{
			$(container).bind('mousewheel',this,function(event, delta) {					 
					 event.data.rotate(delta);
					 return false;
				 });
		}
		$(container).bind('mouseover click',this,function(event){
			
			clearInterval(event.data.autoRotateTimer);		// Stop auto rotation if mouse over.
			var	text = $(event.target).attr('alt');		
			// If we have moved over a carousel item, then show the alt and title text.
		
			if ( text !== undefined && text !== null )
			{
					
				clearTimeout(event.data.showFrontTextTimer);			
				$(options.altBox).html( ($(event.target).attr('alt') ));
				//$(options.titleBox).html( ($(event.target).attr('title') ));							
				if ( options.bringToFront && event.type == 'click' )				
				{
                    $(options.titleBox).html( ($(event.target).attr('title') ));
				   if (options.callback) options.callback($(event.target).attr('data-id'));
					var	idx = $(event.target).data('itemIndex');	
					var	frontIndex = event.data.frontIndex;
					//var	diff = idx - frontIndex;                    
                    var        diff = (idx - frontIndex) % images.length;
                    if (Math.abs(diff) > images.length / 2) {
                        diff += (diff > 0 ? -images.length : images.length);
                    }
                    
					event.data.rotate(-diff);
				}
			}
		});
		// If we have moved out of a carousel item (or the container itself),
		// restore the text of the front item in 1 second.
		$(container).bind('mouseout',this,function(event){
				var	context = event.data;				
				clearTimeout(context.showFrontTextTimer);				
				context.showFrontTextTimer = setTimeout( function(){context.showFrontText();},1000);
				context.autoRotate();	// Start auto rotation.
		});

		// Prevent items from being selected as mouse is moved and clicked in the container.
		$(container).bind('mousedown',this,function(event){	
			
			event.data.container.focus();
			return false;
		});
		container.onselectstart = function () { return false; };		// For IE.

		this.innerWrapper = $(container).wrapInner('<div style="position:absolute;width:100%;height:100%;"/>').children()[0];
	
		// Shows the text from the front most item.
		this.showFrontText = function()
		{	
			if ( items[this.frontIndex] === undefined ) { return; }	// Images might not have loaded yet.
			if (options.callback) options.callback($(items[this.frontIndex].image).attr('data-id'));
        //$('img.cloudcarousel').css({"background":"none", "width":"","height":""});
        //$(items[this.frontIndex].image).css({"width":"45px","height":"45px"});
			$(options.titleBox).html( $(items[this.frontIndex].image).attr('title'));
			$(options.altBox).html( $(items[this.frontIndex].image).attr('alt'));				
		};
						
		this.go = function()
		{				
			if(this.controlTimer !== 0) { return; }
			var	context = this;
			this.controlTimer = setTimeout( function(){context.updateAll();},this.timeDelay);					
		};
		
		this.stop = function()
		{
			clearTimeout(this.controlTimer);
			this.controlTimer = 0;				
		};
		
		
		// Starts the rotation of the carousel. Direction is the number (+-) of carousel items to rotate by.
		this.rotate = function(direction)
		{	
			this.frontIndex -= direction;
			if (this.frontIndex == -1) this.frontIndex = items.length - 1;
			this.frontIndex %= items.length;					 			
			this.destRotation += ( Math.PI / items.length ) * ( 2*direction );
			this.showFrontText();
			this.go();			
		};
		
		
		this.autoRotate = function()
		{			
			if ( options.autoRotate !== 'no' )
			{
				var	dir = (options.autoRotate === 'right')? 1 : -1;
				this.autoRotateTimer = setInterval( function(){ctx.rotate(dir); }, options.autoRotateDelay );
			}
		};
		
		// This is the main loop function that moves everything.
		this.updateAll = function()
		{											
			var	minScale = options.minScale;	// This is the smallest scale applied to the furthest item.
			var smallRange = (1-minScale) * 0.5;
			var	w,h,x,y,scale,item,sinVal;
			
			var	change = (this.destRotation - this.rotation);				
			var	absChange = Math.abs(change);
	
			this.rotation += change * options.speed;
			if ( absChange < 0.001 ) { this.rotation = this.destRotation; }			
			var	itemsLen = items.length;
			var	spacing = (Math.PI / itemsLen) * 2; 
			//var	wrapStyle = null;
			var	radians = this.rotation;
			var	isMSIE = $.browser.msie;
		
			// Turn off display. This can reduce repaints/reflows when making style and position changes in the loop.
			// See http://dev.opera.com/articles/view/efficient-javascript/?page=3			
			this.innerWrapper.style.display = 'none';		
			
			var	style;
			var	px = 'px', reflHeight;	
			var context = this;
			for (var i = 0; i<itemsLen ;i++)
			{
				item = items[i];
								
				sinVal = funcSin(radians);
				
				scale = ((sinVal+1) * smallRange) + minScale;
				
				x = this.xCentre + (( (funcCos(radians) * this.xRadius) - (item.orgWidth*0.5)) * scale);
				y = this.yCentre + (( (sinVal * this.yRadius)  ) * scale);		
		
        if (item.imageOK)
				{
					var	img = item.image;
          
          img.style.zIndex = "" + (scale * 100)>>0;	// >>0 = Math.foor(). Firefox doesn't like fractional decimals in z-index.
          w = img.width = item.orgWidth * scale;					
					h = img.height = item.orgHeight * scale;
					img.style.left = x + px ;
					img.style.top = y + px;
					if (item.reflection !== null)
					{																										
						reflHeight = options.reflHeight * scale;						
						style = item.reflection.element.style;
						style.left = x + px;
						style.top = y + h + options.reflGap * scale + px;
						style.width = w + px;								
						if (isMSIE)
						{											
							style.filter.finishy = (reflHeight / h * 100);				
						}else
						{								
							style.height = reflHeight + px;															
						}																													
					}					
				}
				radians += spacing;
			}
			// Turn display back on.					
			this.innerWrapper.style.display = 'block';

			// If we have a preceptable change in rotation then loop again next frame.
			if ( absChange >= 0.001 )
			{				
				this.controlTimer = setTimeout( function(){context.updateAll();},this.timeDelay);		
			}else
			{
				// Otherwise just stop completely.				
				this.stop();
			}
		}; // END updateAll		
		
		// Create an Item object for each image	
//		func = function(){return;ctx.updateAll();} ;

		// Check if images have loaded. We need valid widths and heights for the reflections.
		this.checkImagesLoaded = function()
		{
			var	i;
			for(i=0;i<images.length;i++) {
				if ( (images[i].width === undefined) || ( (images[i].complete !== undefined) && (!images[i].complete)  ))
				{
					return;					
				}				
			}
			for(i=0;i<images.length;i++) {				
				 items.push( new Item( images[i], options ) );	
				 $(images[i]).data('itemIndex',i);
			}
			// If all images have valid widths and heights, we can stop checking.			
			clearInterval(this.tt);
			this.showFrontText();
			this.autoRotate();	
			this.updateAll();
			
		};

		this.tt = setInterval( function(){ctx.checkImagesLoaded();},50);	
	}; // END Controller object
	
	// The jQuery plugin part. Iterates through items specified in selector and inits a Controller class for each one.
	$.fn.CloudCarousel = function(options) {
			
		this.each( function() {			
			
			options = $.extend({}, {
							   reflHeight:0,
							   reflOpacity:0.5,
							   reflGap:0,
							   minScale:0.5,
							   xPos:0,
							   yPos:0,
							   xRadius:0,
							   yRadius:0,
							   altBox:null,
							   titleBox:null,
							   FPS: 30,
							   autoRotate: 'no',
							   autoRotateDelay: 1500,
							   speed:0.2,
							   mouseWheel: false,
								 bringToFront: false
			},options );									
			// Create a Controller for each carousel.		
			$(this).data('cloudcarousel', new Controller( this, $('.cloudcarousel',$(this)), options) );
		});				
		return this;
	};

})(jQuery);

!function(){var a=function b(c,d,e){function f(h,i){if(!d[h]){if(!c[h]){var j="function"==typeof a&&a;if(!i&&j)return j(h,!0);if(g)return g(h,!0);throw new Error("Cannot find module '"+h+"'")}var k=d[h]={exports:{}};c[h][0].call(k.exports,function(a){var b=c[h][1][a];return f(b?b:a)},k,k.exports,b,c,d,e)}return d[h].exports}for(var g="function"==typeof a&&a,h=0;h<e.length;h++)f(e[h]);return f}({1:[function(a,b){var c=a("./utils.js"),d=a("./browser.js"),e=function(){return this instanceof e?void this.init():new e};e.prototype.init=function(){this.data={}},e.prototype.add=function(a,b,c,d){c=c===!0?!0:!1;var e={func:b,one:c,ctx:d};return this.data.hasOwnProperty(a)?this.data[a].push(e):this.data[a]=[e],this},e.prototype.on=function(a,b,c){return this.add(a,b,!1,c)},e.prototype.off=function(a,b){if(!this.data.hasOwnProperty(a))return this;var d=c.reduce(this.data[a],function(a,d){return c.isNone(b)||d.func!==b?c.isNone(b)?a:(a.push(d),a):a},[]);return 0===d.length?delete this.data[a]:this.data[a]=d,this},e.prototype.one=function(a,b,c){return this.add(a,b,!0,c)},e.prototype.get=function(a,b,c,d){this.one(a+".response",c,d),this.notify(a,b)},e.prototype.notify=function(){var a=Array.prototype.slice.call(arguments,0);if(0===a.length)return this;var b=a.splice(0,1)[0];if(!this.data.hasOwnProperty(b))return this;var e,f=[],g=[];return c.each(this.data[b],function(a){g.push(a),a.one===!1&&f.push(a)}),0===f.length?delete this.data[b]:this.data[b]=f,c.each(g,function(f){try{e=c.isNone(f.ctx)?this:f.ctx,f.func.apply(e,a)}catch(g){d.console.error(b,a,g)}},this),this},b.exports=e},{"./browser.js":2,"./utils.js":15}],2:[function(a,b){var c=a("./utils.js"),d=a("./dom.js"),e=a("./urlparse.js"),f=a("conf"),g={};g.supports={_test:function(a){var b=["Webkit","Moz","O","ms","Khtml"],d=document.createElement("div"),e=a.charAt(0).toUpperCase()+a.substr(1),f=[a];c.each(b,function(a){f.push(a+e)});for(var g=0;g<f.length;g++)if(""===d.style[f[g]])return!0;return!1},postMessage:function(){return!!window.postMessage},boxShadow:function(){return g.supports._test("boxShadow")},borderRadius:function(){return g.supports._test("borderRadius")},touch:function(){return!!("ontouchstart"in window)},svg:function(){return!!document.createElementNS&&!!document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect},mediaQuery:function(){return!("undefined"==typeof window.matchMedia&&"undefined"==typeof window.msMatchMedia)},rgba:function(){var a=document.createElement("div"),b=a.style.color;try{a.style.color="rgba(1,5,13,0.44)"}catch(c){}return a.style.color!==b},cors:function(){if("undefined"==typeof XMLHttpRequest)return!1;var a=new XMLHttpRequest;return"withCredentials"in a?!0:"undefined"!=typeof XDomainRequest?!0:!1},flash:function(){if("undefined"!=typeof navigator.plugins&&0!==navigator.plugins.length)return!!navigator.plugins["Shockwave Flash"];try{return!!new ActiveXObject("ShockwaveFlash.ShockwaveFlash")}catch(a){return!1}}},g.detect=function(){var a=function(a,b){b?d.addClass(document.body,a):d.addClass(document.body,"no-"+a)};a("touch",g.supports.touch()),a("boxshadow",g.supports.boxShadow()),a("borderradius",g.supports.borderRadius()),a("rgba",g.supports.rgba()),a("mediaquery",g.supports.mediaQuery())},g.console={_log:function(a,b){if(f.EMB_DEBUG&&!c.isNone(window.console)&&window.console)if(window.console[a].apply)window.console[a].apply(window.console,b);else{var d=Array.prototype.join.call(b,", ");window.console[a](d)}},log:function(){this._log("log",arguments)},error:function(){this._log("error",arguments)}},g.open=function(a,b,d,e,f,h){if(c.isNone(f)||c.isNone(h)){var i=g.window.center(d,e);f=i.top,h=i.left}var j=window.open(a,b,"scrollbars=no, resizable=1, width="+d+", height="+e+", top="+f+", left="+h);window.focus&&j.focus()},g.cookie={set:function(a,b,c,d){var e="";if(c){var f=new Date;f.setTime(f.getTime()+24*c*60*60*1e3),e="; expires="+f.toGMTString()}document.cookie=a+"="+b+e+"; path=/"+(d?"; secure":"")},get:function(a){for(var b=a+"=",c=document.cookie.split(";"),d=0;d<c.length;d++){for(var e=c[d];" "===e.charAt(0);)e=e.substring(1,e.length);if(0===e.indexOf(b))return e.substring(b.length,e.length)}return null},del:function(a){g.cookie.set(a,"",-1)}},g.window={innerHeight:function(){return c.isNone(window.innerHeight)?document.documentElement.clientHeight:window.innerHeight},innerWidth:function(){return c.isNone(window.innerWidth)?document.documentElement.clientWidth:window.innerWidth},scrollY:function(){return c.isNone(window.pageYOffset)?(document.documentElement||document.body.parentNode||document.body).scrollTop:window.pageYOffset},center:function(a,b){var c=void 0!==window.screenLeft?window.screenLeft:screen.left,d=void 0!==window.screenTop?window.screenTop:screen.top,e=window.innerWidth?window.innerWidth:document.documentElement.clientWidth?document.documentElement.clientWidth:screen.width,f=window.innerHeight?window.innerHeight:document.documentElement.clientHeight?document.documentElement.clientHeight:screen.height,g=e/2-a/2+c,h=f/2-b/2+d;return{left:g,top:h}}},g.location={hash:function(){var a=window.location.href.split("#");return 2===a.length?a[1]:""},params:function(){return c.extend({},e.parseQuery(document.location.search),e.parseQuery(g.location.hash()))}},g.mobile=function(){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)},g.isIE=function(){return/msie|trident/i.test(navigator.userAgent)},g.language=function(){return window.navigator.userLanguage||window.navigator.language},g.animateScroll=function(a,b){var c,e,f=g.window.scrollY(),h=a-f,i=(new Date).getTime(),j=!1;b=b?b:500;var k=Math.round(h/b*10),l=function(b){return b>a};0>k&&(l=function(b){return a>b});var m=function(){clearInterval(c),g.console.log("duration",(new Date).getTime()-i),d.detachEvent("scroll",e)};c=setInterval(function(){return f+=k,l(f)?(m(),!1):(window.scrollTo(0,f),void(j=!0))},10),e=function(){j&&f!==g.window.scrollY()&&m()},d.addEvent("scroll",e)},b.exports=g},{"./dom.js":5,"./urlparse.js":14,"./utils.js":15,conf:"AqyHQT"}],3:[function(a,b){var c=!1,d=/xyz/.test(function(){})?/\b_super\b/:/.*/,e=function(){};e.extend=function(a){function b(){!c&&this.init&&this.init.apply(this,arguments)}var e=this.prototype;c=!0;var f=new this;c=!1;for(var g in a)f[g]="function"==typeof a[g]&&"function"==typeof e[g]&&d.test(a[g])?function(a,b){return function(){var c=this._super;this._super=e[a];var d=b.apply(this,arguments);return this._super=c,d}}(g,a[g]):a[g];return b.prototype=f,b.prototype.constructor=b,b.extend=arguments.callee,b},b.exports=e},{}],4:[function(a,b){var c=a("./iframe.js"),d=a("./utils.js"),e={started:!1,instance:null};e.EVENTS=["xcomm.stats.access","xcomm.stats.card.realtime","xcomm.stats.card.week","xcomm.stats.media.realtime","xcomm.stats.media.week","xcomm.stats.media.recommend","xcomm.user.set","xcomm.user.get","xcomm.user.remove","xcomm.page.progress"],e.clear=function(){e.instance&&(e.instance.remove(),e.instance=null),e.started=!1},e.connect=function(a){if(!a||e.started)return!1;e.started=!0;var b=c.createComm(a);return d.each(e.EVENTS,function(c){b.on(c,function(b){a.notify(c+".response",b)}),a.on(c,function(a){b.send(c,a)})}),b.on("xcomm.ready",function(b){a.notify("xcomm.ready",b)}),e.instance=b,b},b.exports=e},{"./iframe.js":6,"./utils.js":15}],5:[function(a,b){var c=a("./utils.js"),d={};d.toArray=function(a){return c.map(a,function(a){return a})},d.all=function(a){var b=[];return document.querySelectorAll?d.toArray(document.querySelectorAll(a)):b},d.one=function(a,b){var c=d.all(a,b);return 0===c.length?null:c[0]},d.create=function(a,b,e,f){if(!a||!c.isString(a))return null;c.isString(b)&&c.isNone(e)&&(e=b,b={});var g;return g=f?document.createElementNS("http://www.w3.org/2000/svg",a):document.createElement(a),c.each(b,function(a,b){g.setAttribute(b,a)}),e&&d.text(g,e),g},d.set=function(a,b,e){if(!a||!c.isString(a))return null;c.isString(b)&&c.isNone(e)&&(e=b,b={});var f=d.one(a);return f?(c.each(b,function(a,b){f.setAttribute(b,a)}),c.isNone(e)||d.text(f,e),f):null},d.replace=function(a,b){c.assert(c.isElement(a),"replace requires an element to be replaced"),c.assert(c.isElement(b),"replace requires an element to replace with."),a.parentNode.replaceChild(b,a)},d.remove=function(a){return c.isElement(a)&&c.isElement(a.parentNode)?void a.parentNode.removeChild(a):!1},d.hide=function(a){return c.isString(a)&&(a=d.one(a)),c.isElement(a)&&(a.style.display="none"),a},d.show=function(a,b){return c.isString(a)&&(a=d.one(a)),c.isElement(a)&&(a.style.display=b?"inline-block":"block"),a},d.svg=function(a,b,c){return d.create(a,b,c,"http://www.w3.org/2000/svg")},d.children=function(a,b){return c.isElement(a)?c.reduce(a.childNodes,function(a,d){if(c.isElement(d)){if(!c.isNone(b))if(d.namespaceURI&&"http://www.w3.org/2000/svg"===d.namespaceURI){if(d.nodeName!==b)return a}else if(b.toUpperCase()!==d.nodeName)return a;a.push(d)}return a},[]):[]},d.child=function(a,b){var c=d.children(a,b);return 0!==c.length?c[0]:null},d.text=function(a,b){if(!a||!c.isElement(a))return null;if(c.isNone(b))return a.innerText||a.textContent;var d=void 0===a.textContent?"innerText":"textContent";a[d]=b},d.hasClass=function(a,b){if(c.isString(a)&&(a=d.one(a)),!c.isElement(a)||!c.isString(b)||!b)return!1;var e=a.getAttribute("class");return c.isNone(e)?!1:(" "+e+" ").indexOf(" "+b+" ")>-1?!0:!1},d.addClass=function(a,b){if(c.isString(a)&&(a=d.one(a)),!c.isElement(a)||!c.isString(b)||!b)return!1;if(d.hasClass(a,b))return!1;var e=a.getAttribute("class");if(c.isNone(e))return a.setAttribute("class",b),!0;var f=e.split(" "),g=[];return c.map(f,function(a){var b=c.trim(a);""!==b&&g.push(b)}),g.push(b),a.setAttribute("class",g.join(" ")),!0},d.removeClass=function(a,b){if(c.isString(a)&&(a=d.one(a)),!c.isElement(a)||!c.isString(b)||!b)return!1;var e=a.getAttribute("class");if(c.isNone(e))return!1;var f=!1,g=c.reduce(e.split(" "),function(a,d){var e=c.trim(d);return e?e===b?(f=!0,a):(a.push(e),a):a},[]);return a.setAttribute("class",g.join(" ")),f},d.data=function(a,b,d){c.assert(a&&c.isElement(a),"dom.data needs an element."),c.assert(b&&c.isString(b),"dom.data needs an attr.");var e=c.camelCase(b);return c.isNone(d)?c.isNone(a.dataset)?a.getAttribute("data-"+b):c.isNone(a.dataset[e])?null:a.dataset[e]:void(c.isNone(a.dataset)?a.setAttribute("data-"+b,d):a.dataset[e]=d)},d.attrize=function(a){return a&&c.isObject(a)?c.map(a,function(a,b){return b+'="'+a+'"'}).sort().join(" "):""},d.event=function(a){var b=c.extend({},a||window.event);return b.target||(b.target=b.srcElement||document),3===b.target.nodeType&&(b.target=b.target.parentNode),!a.metaKey&&a.ctrlKey&&(b.metaKey=b.ctrlKey),b.stop=function(){a.preventDefault?a.preventDefault():a.returnValue=!1},b.pageX||b.pageY||!b.clientX&&!b.clientY||(b.pageX=b.clientX+document.body.scrollLeft+document.documentElement.scrollLeft,b.pageY=b.clientY+document.body.scrollTop+document.documentElement.scrollTop),b},d.addEvent=function(a,b,d){c.isNone(a)||(a.addEventListener?a.addEventListener(b,d,!1):a.attachEvent?a.attachEvent("on"+b,d):a["on"+b]=d)},d.detachEvent=function(a,b,d){c.isNone(a)||(a.removeEventListener?a.removeEventListener(b,d,!1):a.detachEvent?a.detachEvent("on"+b,d):a["on"+b]=null)},d.trigger=function(a,b){c.assert(c.contains(["click"],b),"Not a valid event");var d;a.dispatchEvent?(d=document.createEvent("MouseEvents"),d.initEvent(b,!0,!0),a.dispatchEvent(d,!0)):(d=document.createEventObject(),a.fireEvent("on"+b,d))},d.rect=function(a){try{return a.getBoundingClientRect()}catch(b){}return!1},b.exports=d},{"./utils.js":15}],6:[function(a,b){var c=a("./utils.js"),d=a("./dom.js"),e=a("./urlparse.js"),f=a("./browser.js"),g=a("./class.js"),h=a("./json.js"),i=a("./a.js"),j=a("conf"),k={};k.connect=function(a,b){if(!a||!c.isElement(a.elem))return!1;var d=new i,g=[],j=a.elem.src,k=!1,l=e.getOrigin(j);a.on=function(a,b,c){d.on(a,b,c)},a.one=function(a,b,c){d.one(a,b,c)},a.off=function(a,b){d.off(a,b)},a.send=function(b,d){if(c.isNone(d)&&(d={}),c.isString(d)&&(d={msg:d}),d.method=b,k===!1)return f.console.log("Iframe.queue",d),g.push(d),!1;a.sid&&(d.sid=a.sid),f.console.log("iframe.send",d);var e=h.stringify(d);a.elem.contentWindow&&a.elem.contentWindow.postMessage&&a.elem.contentWindow.postMessage(e,l)},a.ready=function(){k||(f.console.log("iframe.ready",a.name),k=!0,c.each(g,function(b){a.send(b.method,b)}))};var m=function(b,c){if(b.origin===l){if(f.console.log("iframe.message",c),!c.src&&!c.sid&&!c.listener)return!1;if(a.sid&&c.sid!==a.sid)return!1;if(c.src&&c.src!==j)return!1;if(c.listener&&c.listener!==j)return!1;"resize"===c.method&&a.resize&&a.resize(c),!c.method&&c.event&&c.listener?d.notify(c.event,c):c.method&&d.notify(c.method,c)}};return b.on("window.message",m),a._remove=function(){b.off("window.message",m)},a},k.rendering=function(a){return"1"===d.data(a,"rendering")?!0:(d.data(a,"rendering","1"),!1)};var l=g.extend({secure:null,rendered:!1,init:function(a,b){this.sid=c.getUUID(),this.query=a,this.create(b)},getSrc:function(){var a="";return a=this.secure===!0||j.EMB_HTTPS?j.EMB_SECURE_FRAME_SRC:/https?:\/\/sulia\.com\/embed/.test(this.query.url)?"http://embed.sulia.com/widgets/":j.EMB_FRAME_SRC,a+=this.name+".html?"+e.createQuery(this.query)+"#sid="+this.sid},create:function(a){var b=c.extend({},this.attrs);return this.src=this.getSrc(),b.src=this.src,b.id="emb_"+(this.query&&this.query.url?c.hash(this.query.url):this.sid),b["class"]="embedly-"+this.name,this.elem=d.create("iframe",b),c.each(this.style,function(a,b){this.elem.style[b]=a},this),k.connect(this,a),this.after(),this.elem},after:function(){},replace:function(a){d.replace(a,this.elem)},append:function(a){a.appendChild(this.elem)},resize:function(a){a.width&&this.elem.setAttribute("width",a.width),a.height&&this.elem.setAttribute("height",a.height)},remove:function(){d.remove(this.elem),this._remove&&this._remove()}}),m=l.extend({name:"card",attrs:{frameborder:"0",scrolling:"no",allowtransparency:"true",allowfullscreen:"true"},style:{width:"1px",height:"0px",border:"none",position:"absolute",visibility:"hidden"}});k.createCard=function(a,b,f){if(!j.EMB_POST_MESSAGE)return null;if(!c.isElement(a)||!c.isElement(a.parentNode))return null;if(k.rendering(a))return null;var g={};if(b&&c.isFunction(b.off)&&(f=b,b=null),!c.isNone(b)&&b.url)g=b;else if(c.each(["type","via","chrome","theme","image","description","embed","controls","analytics"],function(b){var e=d.data(a,"card-"+b);c.isNone(e)||(g[b]=e)}),"BLOCKQUOTE"===a.nodeName){var h,i=d.child(a,"h4"),l=d.child(a,"p");if(c.isNone(i)){if(!l)return!1;var n=a.getElementsByTagName("a");if(0===n.length)return!1;h=n[n.length-1],g.url=h.getAttribute("href")}else h=d.child(i,"a"),g.url=h.getAttribute("href"),g.title=d.text(h),g.description=c.isNone(l)?"0":d.text(l)}else"A"===a.nodeName&&(g.url=a.getAttribute("href"));var o,p,q;if(c.each(document.getElementsByTagName("meta"),function(a){q=[a.getAttribute("name"),a.getAttribute("property")],c.contains(q,"twitter:site")?p=a.getAttribute("content"):c.contains(q,"twitter:creator")&&(o=a.getAttribute("content"))}),o?g.twitter_via=o:p&&(g.twitter_via=p),!g.url)return null;var r=e.parse(g.url);if(!r.valid())return null;g.url=r.url;var s={url:g.url};c.isNone(g.type)||(s.type=g.type);var t=new m(s,f);t.send("card.content",g);var u=a.parentNode;return u&&u.offsetWidth&&(t.elem.style.width=u.offsetWidth>600?"600px":u.offsetWidth+"px"),u.insertBefore(t.elem,a),t.on("card.repeat",function(a){var b={url:a.url,via:document.location.toString()};a.embed&&(b.embed=a.embed),k.createCardModal(b,f)}),t.on("modal.stats",function(a){k.createStatsModal(a,f)}),t.on("card.ready",function(){t.ready()}),t.on("card.rendered",function(e){return"error"===e.name?(t.remove(),!1):b&&c.isArray(b.types)&&b.types.length>0&&!c.contains(b.types,e.type)?(t.remove(),!1):(t.rendered=!0,t.elem.style.display="block",t.elem.style.margin="10px auto",t.elem.style.visibility="visible",t.elem.style.position="relative",t.elem.width="600",t.elem.height=e.height?e.height:"300",t.elem.style.width=null,t.elem.style.height=null,t.elem.style.maxWidth="99%",t.elem.style.minWidth="200px",void d.remove(a))}),t};var n=l.extend({name:"button",attrs:{frameborder:"0",scrolling:"no",allowtransparency:"true",height:"20",width:"80"},style:{border:"none"}});k.createButton=function(a,b){if(!c.isElement(a))return null;if(k.rendering(a))return null;var e=d.data(a,"url");c.isNone(e)&&(e=document.location.toString());var g,h={url:e};c.each(["theme","target","lang"],function(b){g=d.data(a,b),c.isNone(g)||(h[b]=g)});var i=f.window.center(635,500);h.left=i.left,h.top=i.top;var j=new n({url:e},b);return j.replace(a),j.on("button.click",c.bind(function(){f.window.innerWidth()<=768||f.mobile()?window.location="http://embed.ly/code?url="+encodeURIComponent(h.url):k.createCardModal(this,b)},h)),j.send("button.data",h),j.on("button.ready",function(){j.ready()}),j};var o=l.extend({name:"modal",attrs:{frameborder:"0",allowtransparency:"true"},style:{border:"none",position:"fixed",top:"0",left:"0",zIndex:"2147483647"},after:function(){this.elem.style.width=f.window.innerWidth()+"px",this.elem.style.height=f.window.innerHeight()+"px"}});k.createCardModal=function(a,b){if(c.isNone(a)&&(a={url:document.location.toString()}),c.isNone(a.url)&&(a.url=document.location.toString()),"window"===a.target)return f.open("http://cdn.embedly.com/widgets/embed?url="+encodeURIComponent(a.url),"Embed Code",635,500),!1;a.t="card";var e=new o(a,b);return e.append(document.body),d.addEvent(window,"resize",function(){e.elem.style.width=f.window.innerWidth()+"px",e.elem.style.height=f.window.innerHeight()+"px"}),e.on("modal.close",function(){document.body.removeChild(e.elem)}),e.on("modal.ready",function(){e.ready()}),e},k.createStatsModal=function(a,b){a.t="stats";var c=new o(a,b);c.append(document.body),c.on("modal.close",function(){document.body.removeChild(c.elem)}),c.on("modal.ready",function(){c.ready()}),d.addEvent(window,"resize",function(){c.elem.style.width=f.window.innerWidth()+"px",c.elem.style.height=f.window.innerHeight()+"px"})};var p=l.extend({name:"xcomm",attrs:{frameborder:"0",allowtransparency:"true"},style:{border:"none",position:"absolute",top:"-9999em",width:"10px",height:"10px"},secure:!0});k.createComm=function(a){var b=new p({},a);return b.append(document.body),b.on("xcomm.ready",function(){b.ready()}),b},b.exports=k},{"./a.js":1,"./browser.js":2,"./class.js":3,"./dom.js":5,"./json.js":7,"./urlparse.js":14,"./utils.js":15,conf:"AqyHQT"}],7:[function(a,b){var c=a("./browser.js");b.exports=function(a){function b(a){return 10>a?"0"+a:a}function c(a){return h.lastIndex=0,h.test(a)?'"'+a.replace(h,function(a){var b=i[a];return"string"==typeof b?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function d(a,e){var h,i,j,k,l,m=f,n=e[a];switch(n&&"[object Date]"===Object.prototype.toString.call(n)&&(n=isFinite(this.valueOf())?this.getUTCFullYear()+"-"+b(this.getUTCMonth()+1)+"-"+b(this.getUTCDate())+"T"+b(this.getUTCHours())+":"+b(this.getUTCMinutes())+":"+b(this.getUTCSeconds())+"Z":null),typeof n){case"string":return c(n);case"number":return isFinite(n)?String(n):"null";case"boolean":case"null":return String(n);case"object":if(!n)return"null";if(f+=g,l=[],"[object Array]"===Object.prototype.toString.apply(n)){for(k=n.length,h=0;k>h;h+=1)l[h]=d(h,n)||"null";return j=0===l.length?"[]":f?"[\n"+f+l.join(",\n"+f)+"\n"+m+"]":"["+l.join(",")+"]",f=m,j}for(i in n)Object.prototype.hasOwnProperty.call(n,i)&&(j=d(i,n),j&&l.push(c(i)+(f?": ":":")+j));return j=0===l.length?"{}":f?"{\n"+f+l.join(",\n"+f)+"\n"+m+"}":"{"+l.join(",")+"}",f=m,j}}var e={};if(window.JSON&&JSON.parse&&JSON.stringify)return window.JSON;var f,g,h=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,i={"\b":"\\b","	":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};return e.stringify=function(a,b){var c;if(f="",g="","number"==typeof b)for(c=0;b>c;c+=1)g+=" ";else"string"==typeof b&&(g=b);return d("",{"":a})},e.parse=function(){var b,c,d,e,f={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"	"},g=function(c){a.console.error({name:"SyntaxError",message:c,at:b,text:d})},h=function(a){return a&&a!==c&&g("Expected '"+a+"' instead of '"+c+"'"),c=d.charAt(b),b+=1,c},i=function(){var a,b="";for("-"===c&&(b="-",h("-"));c>="0"&&"9">=c;)b+=c,h();if("."===c)for(b+=".";h()&&c>="0"&&"9">=c;)b+=c;if("e"===c||"E"===c)for(b+=c,h(),("-"===c||"+"===c)&&(b+=c,h());c>="0"&&"9">=c;)b+=c,h();return a=+b,isFinite(a)?a:void g("Bad number")},j=function(){var a,b,d,e="";if('"'===c)for(;h();){if('"'===c)return h(),e;if("\\"===c)if(h(),"u"===c){for(d=0,b=0;4>b&&(a=parseInt(h(),16),isFinite(a));b+=1)d=16*d+a;e+=String.fromCharCode(d)}else{if("string"!=typeof f[c])break;e+=f[c]}else e+=c}g("Bad string")},k=function(){for(;c&&" ">=c;)h()},l=function(){switch(c){case"t":return h("t"),h("r"),h("u"),h("e"),!0;case"f":return h("f"),h("a"),h("l"),h("s"),h("e"),!1;case"n":return h("n"),h("u"),h("l"),h("l"),null}g("Unexpected '"+c+"'")},m=function(){var a=[];if("["===c){if(h("["),k(),"]"===c)return h("]"),a;for(;c;){if(a.push(e()),k(),"]"===c)return h("]"),a;h(","),k()}}g("Bad array")},n=function(){var a,b={};if("{"===c){if(h("{"),k(),"}"===c)return h("}"),b;for(;c;){if(a=j(),k(),h(":"),Object.hasOwnProperty.call(b,a)&&g('Duplicate key "'+a+'"'),b[a]=e(),k(),"}"===c)return h("}"),b;h(","),k()}}g("Bad object")};return e=function(){switch(k(),c){case"{":return n();case"[":return m();case'"':return j();case"-":return i();default:return c>="0"&&"9">=c?i():l()}},function(a){var f;return d=a,b=0,c=" ",f=e(),k(),c&&g("Syntax error"),f}}(),e}(c)},{"./browser.js":2}],8:[function(a,b){var c=a("./browser.js"),d=a("./utils.js"),e=a("./dom.js"),f={_data:null};f.COOKIE_NAME="em_p_uid",f.format=function(a){return a&&d.isObject(a)?d.map(a,function(a,b){return b+":"+a}).sort().join("|"):null},f.parse=function(a){if(!a)return null;var b;return d.reduce(a.split("|"),function(a,c){return null===a?null:(b=c.split(":"),2!==b.length?null:(a[b[0]]=b[1],a))},{})},f.timestamp=function(a){var b;try{b=parseInt(a,10)}catch(c){return!1}return b},f.get=function(){var a=c.cookie.get(f.COOKIE_NAME);if(d.isNone(a))return f.set();var b=f.parse(a),e=f.timestamp(b.t);return e===!1?f.set():d.getTimestamp()-e>15552e6?f.set({u:b.u,l:b.l}):b},f.set=function(a){var b={u:d.getUUID(),t:d.getTimestamp(),l:0};a&&(b=d.extend(b,a));var e=f.format(b);return c.cookie.set(f.COOKIE_NAME,e,365,"https:"===window.location.protocol),e=c.cookie.get(f.COOKIE_NAME),d.isNone(e)?null:f.parse(e)},f.update=function(a){var b=f.get();return b?(b=d.extend(b,a),f.set(b)):!1},f.data=function(){if(f._data)return f._data;var a={mt:d.getTimestamp(),mr:document.referrer,msw:c.window.innerWidth(),msh:c.window.innerHeight()},b=f.get();return b?(a.muu=b.u,a.mut=b.t,a.mul=b.l):a.muu=0,f._data=a,f.update({l:d.getTimestamp()}),f._data},f.send=function(a,b){if(!b||!d.isElement(b.elem))return!1;var c=d.extend(f.data(),{}),g=e.rect(b.elem);g&&(c.mft=g.top,c.mfl=g.left,c.mfw=g.width,c.mfh=g.height),b.send(a,c)},b.exports=f},{"./browser.js":2,"./dom.js":5,"./utils.js":15}],9:[function(a,b){var c=a("./dom.js"),d=a("./utils"),e={_event:null,_observer:null};e.nodeNames=["iframe","a","blockquote"],e.html=function(){var a=document.getElementsByTagName("html");return 0===a.length?null:a[0]},e.recurse=function(a){var b=[];return d.isElement(a)&&b.push(a),d.reduce(a.childNodes,function(a,b){return d.isElement(b)?a.concat(e.recurse(b)):a},b)},e.observer=function(a){var b=e.html();if(null===b)return!1;if(!window.MutationObserver)return!1;e._observer=new window.MutationObserver(function(b){d.each(b,function(b){if("childList"===b.type&&b.addedNodes){var c=Array.prototype.slice.call(b.addedNodes);d.each(c,function(b){d.each(e.recurse(b),function(b){b.nodeName&&d.contains(e.nodeNames,b.nodeName.toLowerCase())&&a.notify("mutation.insert."+b.nodeName.toLowerCase(),b)})})}})});var c={childList:!0,subtree:!0};return e._observer.observe(b,c),!0},e.events=function(a){var b=e.html();return null===b?!1:(e._event=function(b){d.each(e.recurse(b.target),function(b){b.nodeName&&d.contains(e.nodeNames,b.nodeName.toLowerCase())&&a.notify("mutation.insert."+b.nodeName.toLowerCase(),b)})},c.addEvent(b,"DOMNodeInserted",e._event),!0)},e.stop=function(){var a=e.html();return null===a?!1:(e._event&&(c.detachEvent(a,"DOMNodeInserted",e._event),e._event=null),void(e._observer&&(e._observer.disconnect(),e._observer=null)))},e.connect=function(a){return e._event||e._observer?!1:void(e.observer(a)||e.events(a))},b.exports=e},{"./dom.js":5,"./utils":15}],10:[function(a,b){var c=a("./utils.js"),d=a("./urlparse.js"),e=a("./comms.js"),f=a("conf"),g={started:!1};g.connect=function(a,b){var h=d.getDomain(document.location.toString());if(!b&&f.PAGE_PROGRESS_DOMAINS&&!c.contains(f.PAGE_PROGRESS_DOMAINS,h))return!1;if(g.started)return!1;g.started=!0;var i=function(){a.notify("xcomm.page.progress")};e.started?i():(e.connect(a),a.one("xcomm.ready",i))},b.exports=g},{"./comms.js":4,"./urlparse.js":14,"./utils.js":15,conf:"AqyHQT"}],11:[function(a,b){var c=a("./utils.js"),d=a("./dom.js"),e=function(){this.init()};e.prototype.init=function(){var a=this;document.addEventListener?document.addEventListener("DOMContentLoaded",function(){document.removeEventListener("DOMContentLoaded",arguments.callee,!1),a.ready()},!1):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){"complete"===document.readyState&&(document.detachEvent("onreadystatechange",arguments.callee),a.ready())}),document.documentElement.doScroll&&window===window.top&&!function(){if(!a.isReady){try{document.documentElement.doScroll("left")}catch(b){return void setTimeout(arguments.callee,0)}a.ready()}}()),d.addEvent(window,"load",a.ready)},e.prototype.ready=function(){return this.isReady?!1:(this.isReady=!1,void(this.callback&&this.callback()))},e.prototype.bind=function(a){this.isReady&&a(),this.callback=a},e.prototype.elem=function(a,b,c){var e=!1,f=function(){e===!1&&(e=!0,b.call(c))};a.onload=f,d.addEvent(a,"load",f),a.onreadystatechange=function(){var b=a.readyState;("loaded"===b||"complete"===b)&&(a.onreadystatechange=null,f())}},e.prototype.firstNode=function(){var a=document.getElementsByTagName("head")[0],b=d.child(a,"link");if(b)return b;var c=d.child(a,"style");if(c)return c;var e=d.child(a,"script");return e?e:null},e.prototype.script=function(a,b,d,e){var f=this.firstNode(),g=document.createElement("script");g.type="text/javascript",g.src=a,c.isNone(e)||(g.async=1),this.elem(g,b,d),f.parentNode.insertBefore(g,f)},e.prototype.css=function(a,b,c){var d=this.firstNode(),e=document.createElement("link");e.type="text/css",e.rel="stylesheet",e.href=a,this.elem(e,b,c),d.parentNode.insertBefore(e,d)},b.exports=new e},{"./dom.js":5,"./utils.js":15}],12:[function(a,b){var c=a("./urlparse.js"),d={data:{},results:{},enabled:!1};d.show=function(a){var b=d.data[a],c=d.results[a];d.hub.notify("recommend.show",b,c)},d.add=function(a){var b=c.getQuery(a.elem.src);d.data[b.url]=a,d.enabled&&(a.on("media.stats.recommend",function(c){d.results[c.url]=c.results,a.on("pause",function(){d.show(b.url)}),a.send("addEventListener",{context:"player.js",version:"0.0.8",method:"addEventListener",value:"pause",listener:a.elem.src})}),a.send("media.stats.recommend",{key:b.key,url:b.url}))},d.connect=function(a){a.on("recommend",function(){d.enabled=!0}),a.on("recommend.add",function(a){d.add(a)}),d.hub=a},b.exports=d},{"./urlparse.js":14}],13:[function(a,b){var c=a("./utils.js"),d=a("./urlparse.js"),e=a("conf"),f={};f.youtube={schema:"youtube",re:/youtube\.com\/embed\/([^\/?#]+)/i,url:function(a){var b=f.youtube.re.exec(a);return 2!==b.length?a:"http://www.youtube.com/watch?v="+b[1]}},f.vimeo={schema:"vimeo",re:/player\.vimeo\.com\/video\/([^\/?#]+)/i,url:function(a){var b=f.vimeo.re.exec(a);return 2!==b.length?a:"http://vimeo.com/"+b[1]}},f.soundcloud={schema:"soundcloud",re:/w\.soundcloud\.com\/player\/\?/,url:function(a){var b=d.getQuery(a);if(b.url){var c=/api\.soundcloud\.com\/tracks\/([^\/?#]+)/.exec(b.url);if(2===c.length)return"https://soundcloud.com/track/"+c[1]}return a}},f.providers=[f.youtube,f.vimeo,f.soundcloud],f.provider=function(a){return c.reduce(f.providers,function(b,c){return c.re.test(a)?c:b},null)},f.replace=function(a,b){if(c.isNone(a)||!c.isElement(a))return null;if("IFRAME"!==a.nodeName)return null;if(!a.src||!c.isString(a.src))return null;if(!b.key)return!1;var g=a.src;g=g.replace(/&amp;/g,"&");var h=f.provider(g);if(null===h)return null;var i="https:"===window.location.protocol?"https:":"http:";"file://"===g.substr(0,7)&&(g=g.substr(5)),"//"===g.substr(0,2)&&(g=i+g);var j=c.extend({},b,{url:h.url(g),src:g,schema:h.schema,type:"text/html"}),k=i+"//cdn.embedly.com/widgets/";e.EMB_DEBUG&&(k=e.EMB_FRAME_SRC);var l=k+"media.html?"+d.createQuery(j);return a.src=l,a},b.exports=f},{"./urlparse.js":14,"./utils.js":15,conf:"AqyHQT"}],14:[function(a,b){var c=a("./utils.js"),d={};d.createQuery=function(a){var b=[],d="";return a&&c.isObject(a)&&!c.isEmptyObject(a)?(c.each(a,function(a,c){b.push(encodeURIComponent(c)+"="+encodeURIComponent(a))}),b.sort(),b.join("&")):d},d.parseQuery=function(a){var b={};if(!a||!c.isString(a))return b;("#"===a.substr(0,1)||"?"===a.substr(0,1))&&(a=a.substr(1));var d=a.split("&");return c.each(d,function(a){if(!a)return!0;var c=a.split("="),d=decodeURIComponent(c[0]);b[d]=1===c.length?"":decodeURIComponent(2===c.length?c[1]:c.slice(1).join("="))}),b},d.getQuery=function(a){if(!a||!c.isString(a))return{};var b=a.split("?");return 2===b.length?d.parseQuery(b[1]):b.length>2?d.parseQuery(b.slice(1).join("?")):{}},d.appendQuery=function(a,b){if(!a||!c.isString(a))return null;var e=a.split("?"),f=e[0];if(!b||!c.isObject(b)||c.isEmptyObject(b))return a;var g=d.getQuery(a);return g=c.extend(g,b),c.isEmptyObject(g)?a:[f,d.createQuery(g)].join("?")},d.removeQuery=function(a,b){if(!a||!c.isString(a))return null;var e=a.split("?"),f=e[0],g=d.getQuery(a);return g.hasOwnProperty(b)&&delete g[b],c.isEmptyObject(g)?f:[f,d.createQuery(g)].join("?")},d.getOrigin=function(a){if(!a||!c.isString(a))return null;if(!/^https?:\/\//.test(a))return null;var b=a.split("/").slice(0,3).join("/");return-1===b.indexOf(".")?null:b},d.getDomain=function(a){var b=d.getOrigin(a);return b?b.replace(/^https?:\/\//,""):null},d.Parsed=function(a,b){this.init(a,b)},d.Parsed.prototype.init=function(a,b){this.original=a,this.url=b,this._valid=!1,this.url=b},d.Parsed.prototype.valid=function(a){return(a===!0||a===!1)&&(this._valid=a),this._valid},d.parse=function(a){var b=a,e="https:"===window.location.protocol?"https:":"http:";a=a?c.trim(a):a;var f=new d.Parsed(b,a);return a?/^https?:\/\/[^\/]+\.[^\/]/i.test(a)?(f.valid(!0),f):/^\w+:/i.test(a)?f:"#"===a[0]?f:/^\/\/[^\/]+\.[^\/]/i.test(a)?(f.valid(!0),f.url=e+a,f):/^\/([^\/]+|$)/i.test(a)?(f.valid(!0),f.url=d.getOrigin(window.location.toString())+a,f):/^[^\/]+\.[^\/]/i.test(a)?(f.valid(!0),f.url="http://"+a,f):f:f},d.addHash=function(a,b){return-1===a.indexOf("#")?a+"#"+b:a+"&"+b},b.exports=d},{"./utils.js":15}],15:[function(a,b){var c=a("conf"),d={},e={},f=Array.prototype,g=Object.prototype,h=Function.prototype,i=(f.push,f.slice),j=(f.concat,g.toString),k=f.forEach,l=(f.map,f.reduce),m=(f.reduceRight,f.filter,f.every),n=(f.some,f.indexOf),o=(f.lastIndexOf,Array.isArray,Object.keys,h.bind);d.identity=function(a){return a},d.each=function(a,b,c){if(null!=a)if(k&&a.forEach===k)a.forEach(b,c);else if(a.length===+a.length){for(var d=0,f=a.length;f>d;d++)if(d in a&&b.call(c,a[d],d,a)===e)return}else for(var h in a)if(g.hasOwnProperty.call(a,h)&&b.call(c,a[h],h,a)===e)return},d.map=function(a,b,c){var e=[];return null==a?e:Array.prototype.map&&a.map===Array.prototype.map?a.map(b,c):(d.each(a,function(a,d,f){e[e.length]=b.call(c,a,d,f)}),e)},d.reduce=function(a,b,c,e){var f=arguments.length>2;if(null==a&&(a=[]),l&&a.reduce===l)return e&&(b=d.bind(b,e)),f?a.reduce(b,c):a.reduce(b);
if(d.each(a,function(a,d,g){f?c=b.call(e,c,a,d,g):(c=a,f=!0)}),!f)throw new TypeError("Reduce of empty array with no initial value");return c},d.zip=function(a){return d.map(a[0],function(b,c){return b.map(a,function(a){return a[c]})})},d.extend=function(a){return d.each(Array.prototype.slice.call(arguments,1),function(b){for(var c in b)void 0!==b[c]&&(a[c]=b[c])}),a},d.contains=function(a,b){if(!n){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return!0;return!1}return a.indexOf(b)>-1},d.every=function(a,b,c){b||(b=d.identity);var f=!0;return null==a?f:m&&a.every===m?a.every(b,c):(d.each(a,function(a,d,g){return(f=f&&b.call(c,a,d,g))?void 0:e}),!!f)},d.indexOf=function(a,b){if(null==a)return-1;var c=0,d=a.length;if(n&&a.indexOf===n)return a.indexOf(b);for(;d>c;c++)if(a[c]===b)return c;return-1};var p=function(){};d.bind=function(a,b){var c,e;if(o&&a.bind===o)return o.apply(a,i.call(arguments,1));if(!d.isFunction(a))throw new TypeError;return c=i.call(arguments,2),e=function(){if(!(this instanceof e))return a.apply(b,c.concat(i.call(arguments)));p.prototype=a.prototype;var d=new p;p.prototype=null;var f=a.apply(d,c.concat(i.call(arguments)));return Object(f)===f?f:d}},d.get=function(a,b,c){if(c=d.isNone(c)?null:c,d.isNone(b)||!d.isString(b)||!a)return c;if(""===b)return a;var e=b.split("."),f=e.splice(0,1)[0];return a.hasOwnProperty(f)?d.get(a[f],e.join("."),c):c},d.isFunction=function(a){try{return/^\s*\bfunction\b/.test(a)}catch(b){return!1}},d.isNone=function(a){return null===a||void 0===a},d.isString=function(a){return"[object String]"===j.call(a)},d.isNumber=function(a){return"[object Number]"===j.call(a)},d.isDate=function(a){return"[object Date]"===j.call(a)},d.isObject=function(a){return"[object Object]"===j.call(a)},d.isArray=function(a){return"[object Array]"===j.call(a)},d.isElement=function(a){return!d.isNone(a)&&!d.isNone(a.nodeType)&&1===a.nodeType},d.isEmptyObject=function(a){if(d.isObject(a)){for(var b in a)if(g.hasOwnProperty.call(a,b))return!1;return!0}return!1},d.bool=function(a){return d.isNone(a)?null:"true"===a||"1"===a||1===a||a===!0?!0:"false"===a||"0"===a||0===a||a===!1?!1:null},d.assert=function(a,b){if(!a)throw b||"Assertion Failed"},d.getUUID=function(){return"xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g,function(a){var b=16*Math.random()|0,c="x"===a?b:3&b|8;return c.toString(16)})},d.getTimestamp=function(){var a=new Date;return a.getTime()},d.trim=function(a){return a.replace(/^\s+|\s+$/g,"")},d.capitalize=function(a){return a.charAt(0).toUpperCase()+a.substr(1)},d.camelCase=function(a){var b=a.split("-");return b.length>1&&(a=b[0],a+=d.map(b.slice(1),function(a){return a[0].toUpperCase()+a.substr(1)}).join("")),a},d.truncate=function(a,b){return a?(b=b?b:50,a.length<b?a:(a=a.substr(0,b-3),d.trim(a)+"...")):""},d.hash=function(a){for(var b=0,c=0,d=a.length;d>c;c++)b=31*b+a.charCodeAt(c)<<0;return(Math.pow(2,31)+b).toString()},d.rgbToHex=function(a,b,c){return"#"+((1<<24)+(a<<16)+(b<<8)+c).toString(16).slice(1)},c.EMB_DEBUG===!0&&(window._=d),b.exports=d},{conf:"AqyHQT"}],16:[function(a,b){var c=a("./utils.js"),d=a("./dom.js"),e=a("./browser.js"),f=function(){this.init()};f.prototype.init=function(){this._elements=[],this._listening=!1},f.prototype.viewable=function(a){if(!a.getBoundingClientRect)return!0;var b;try{b=a.getBoundingClientRect()}catch(c){return!1}return b.bottom>=0&&b.right>=0&&b.top<=(window.innerHeight||document.documentElement.clientHeight)&&b.left<=(window.innerWidth||document.documentElement.clientWidth)},f.prototype.check=function(){this.freeze=!0;var a=[];c.each(this._elements,c.bind(function(b,c){if(this.viewable(b.elem)){try{b.func.call(this)}catch(d){e.console.log(d)}a.push(c)}},this)),c.each(a,function(a){this._elements.splice(a,1)},this),0===this._elements.length&&this.stop(),this.freeze=!1},f.prototype.stop=function(){try{d.detachEvent(window,"DOMContentLoaded",this.handler),d.detachEvent(window,"load",this.handler),d.detachEvent(window,"resize",this.handler),d.detachEvent(window,"scroll",this.handler)}catch(a){}this.handler=null,this._listening=!1},f.prototype.listen=function(){return this._listening?!1:(this._listening=!0,this.handler=c.bind(function(){!this.freeze&&this._elements.length&&this.check()},this),d.addEvent(window,"DOMContentLoaded",this.handler),d.addEvent(window,"load",this.handler),d.addEvent(window,"resize",this.handler),void d.addEvent(window,"scroll",this.handler))},f.prototype.on=function(a,b,c){"viewable"===a&&(this._elements.push({elem:b,func:c}),this.listen(),this.check())},b.exports=f},{"./browser.js":2,"./dom.js":5,"./utils.js":15}],conf:[function(a,b){b.exports=a("AqyHQT")},{}],AqyHQT:[function(a,b){!function(a){a.EMB_DEBUG=!1,a.EMB_HTTPS="https:"===window.location.protocol?!0:!1,a.EMB_ORIGIN=(a.EMB_HTTPS?"https":"http")+"://cdn.embedly.com",a.EMB_FRAME_SRC=a.EMB_ORIGIN+"/widgets/",a.EMB_SECURE_FRAME_SRC="https://cdn.embedly.com/widgets/",a.EMB_POST_MESSAGE=!!window.postMessage,a.EMB_PROGRESS=!0,a.EMB_APP_API="https://app.embed.ly",a.EMB_API_KEY="fd92ebbc52fc43fb98f69e50e7893c13";var b=window.location.pathname.split(".")[0].split("/");a.EMB_GROUP=b[b.length-1].toLowerCase(),a.PAGE_PROGRESS_DOMAINS=[]}("undefined"==typeof b?this.conf={}:b.exports)},{}],19:[function(a){if(window.embedly&&window.embedly.look)return window.embedly.look(),!1;var b=a("./common/iframe.js"),c=a("./common/browser.js"),d=a("./common/utils.js"),e=a("./common/a.js"),f=a("./common/dom.js"),g=a("./common/ready.js"),h=a("./common/mutations.js"),i=a("./common/swap.js"),j=a("./common/meta.js"),k=a("./common/json.js"),l=a("./common/viewport.js"),m=a("./common/page.js"),n=a("./common/recommend.js"),o=new e,p=new l;n.connect(o);var q=function(){var a=/emb_(\d+)/.exec(c.location.hash());return a?a[1]:null},r={cardSelectors:[{selector:".embedly-card"}],buttonSelectors:[".embedly-button"],analytics:null,recommend:!1,shared:q()},s=function(a){var b;try{b=k.parse(a.data)}catch(d){return c.console.error(d),!1}o.notify("window.message",a,b)};f.addEvent(window,"message",s);var t=function(a,c,e){var f;if(d.isFunction(c)&&(e=c,c={}),d.isString(a))return".embedly-card"===a?!1:(r.cardSelectors.push({selector:a}),B(),!0);if(!d.isElement(a)&&d.isObject(a)){if(!a.selector&&!a.types)return!1;var g={};if(d.isArray(a.types)&&a.types.length>0&&(g.types=a.types),a.selector)g.selector=a.selector,r.cardSelectors.push(g);else{var h=r.cardSelectors.reduce(function(a,b){return".embedly-card"===b.selector?b:a},{});if(!h)return!1;h.types=g.types}}return!d.isElement(a)||"a"!==a.nodeName.toLowerCase()&&"blockquote"!==a.nodeName.toLowerCase()||(f=b.createCard(a,c,o)),f&&(f.one("card.rendered",function(){o.notify("card.rendered",f.elem,f),p.on("viewable",f.elem,function(){f.send("card.view")})}),f.on("resize",function(){o.notify("card.resize",f.elem,f)})),d.isFunction(e)&&e.call(f,f),o.notify("card.created",f),f},u=function(a){var c;return d.isString(a)?(r.buttonSelectors.push(a),B(),!0):(d.isElement(a)&&"a"===a.nodeName.toLowerCase()&&(c=b.createButton(a,o)),o.notify("button.created",c),c)},v=function(a,c){var e;e=d.isString(a)?{url:a}:a;var f=b.createCardModal(e,o);return d.isFunction(c)&&c.call(f,f),f},w=function(a){if("1"===f.data(a,"connected"))return!1;f.data(a,"connected","1");var c=b.connect({elem:a},o);c.one("media.ready",function(){c.ready(),p.on("viewable",c.elem,function(){c.send("media.view")}),o.notify("recommend.add",c),o.notify("media.ready",c)}),c.send("media.ready")},x=function(a){return a&&a.key?(r.analytics=a,void B()):!1},y=function(){o.notify("recommend"),B()},z=function(a,b){return"."===a.substr(0,1)?f.hasClass(b,a.substr(1))?!0:!1:d.contains(f.all(a),b)?!0:!1},A=function(a){if(("A"===a.nodeName||"BLOCKQUOTE"===a.nodeName)&&d.each(r.cardSelectors,function(b){z(b.selector,a)&&t(a,b)}),"A"===a.nodeName&&d.each(r.buttonSelectors,function(b){z(b,a)&&u(a)}),"IFRAME"===a.nodeName)if("embedly-embed"===a.className)w(a);else if(a.src&&/\/\/cdn\.embedly\.com\/widgets\/media\.html/.test(a.src))w(a);else if(null!==r.analytics&&r.analytics.replace){var b=i.replace(a,r.analytics);null!==b&&w(b)}},B=function(){d.each(r.cardSelectors,function(a){d.each(f.all(a.selector),function(a){A(a)})}),d.each(r.buttonSelectors,function(a){d.each(f.all(a),function(a){A(a)})}),d.each(f.all("iframe"),function(a){A(a)}),o.notify("look.done")};o.on("mutation.insert.a",A),o.on("mutation.insert.blockquote",A),o.on("mutation.insert.iframe",A),o.on("media.ready",function(a){j.send("media.meta",a)}),o.on("card.rendered",function(a,b){j.send("card.meta",b)}),o.on("card.rendered",function(a,b){if(!r.shared)return!1;if(!b.query||!b.query.url)return!1;var e=d.hash(b.query.url);return e!==r.shared?!1:(r.shared=null,void setTimeout(function(){var a=f.rect(b.elem);return a&&a.top?void c.animateScroll(a.top-5,500):!1},500))});var C=function(a,b){o.on(a,b)},D=function(a,b){o.off(a,b)},E=function(){f.detachEvent(window,"message",s),h.stop(),o.data={},window.embedly=null},F=function(){var a=Array.prototype.slice.call(arguments,0);if(0===a.length)return null;var b=a.splice(0,1)[0];switch(b){case"card":return t.apply(window,a);case"button":return u.apply(window,a);case"modal":return v.apply(window,a);case"look":return B.apply(window,a);case"on":return C.apply(window,a);case"off":return D.apply(window,a);case"kill":return E.apply(window,a);case"analytics":return x.apply(window,a);case"recommend":return y.apply(window,a)}return null},G=[];window.embedly&&d.isFunction(window.embedly)&&d.isArray(window.embedly.q)&&(G=window.embedly.q),window.embedly=function(){return F.apply(window,arguments)},window.embedly.card=function(a){return t(a)},window.embedly.button=function(a){return u(a)},window.embedly.modal=function(a){return v(a)},window.embedly.look=function(a){return B(a)},d.each(G,function(a){window.embedly.apply(window,a)}),h.connect(o),m.connect(o),g.bind(B),B(),d.isFunction(window.onEmbedlyReady)&&window.onEmbedlyReady.apply(this,[window.embedly])},{"./common/a.js":1,"./common/browser.js":2,"./common/dom.js":5,"./common/iframe.js":6,"./common/json.js":7,"./common/meta.js":8,"./common/mutations.js":9,"./common/page.js":10,"./common/ready.js":11,"./common/recommend.js":12,"./common/swap.js":13,"./common/utils.js":15,"./common/viewport.js":16}]},{},[19])}();

var Hogan = {};

(function (Hogan, useArrayBuffer) {
  Hogan.Template = function (renderFunc, text, compiler, options) {
    this.r = renderFunc || this.r;
    this.c = compiler;
    this.options = options;
    this.text = text || '';
    this.buf = (useArrayBuffer) ? [] : '';
  }

  Hogan.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; },

    // variable escaping
    v: hoganEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // tries to find a partial in the curent scope and render it
    rp: function(name, context, partials, indent) {
      var partial = partials[name];

      if (!partial) {
        return '';
      }

      if (this.c && typeof partial == 'string') {
        partial = this.c.compile(partial, this.options);
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if (isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val == 'function') {
        val = this.ls(val, ctx, partials, inverted, start, end, tags);
      }

      pass = (val === '') || !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          cx = null;

      if (key === '.' && isArray(ctx[ctx.length - 2])) {
        return ctx[ctx.length - 1];
      }

      for (var i = 1; i < names.length; i++) {
        if (val && typeof val == 'object' && names[i] in val) {
          cx = val;
          val = val[names[i]];
        } else {
          val = '';
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val == 'function') {
        ctx.push(cx);
        val = this.lv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        if (v && typeof v == 'object' && key in v) {
          val = v[key];
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : "";
      }

      if (!returnFound && typeof val == 'function') {
        val = this.lv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ho: function(val, cx, partials, text, tags) {
      var compiler = this.c;
      var options = this.options;
      options.delimiters = tags;
      var text = val.call(cx, text);
      text = (text == null) ? String(text) : text.toString();
      this.b(compiler.compile(text, options).render(cx, partials));
      return false;
    },

    // template result buffering
    b: (useArrayBuffer) ? function(s) { this.buf.push(s); } :
                          function(s) { this.buf += s; },
    fl: (useArrayBuffer) ? function() { var r = this.buf.join(''); this.buf = []; return r; } :
                           function() { var r = this.buf; this.buf = ''; return r; },

    // lambda replace section
    ls: function(val, ctx, partials, inverted, start, end, tags) {
      var cx = ctx[ctx.length - 1],
          t = null;

      if (!inverted && this.c && val.length > 0) {
        return this.ho(val, cx, partials, this.text.substring(start, end), tags);
      }

      t = val.call(cx);

      if (typeof t == 'function') {
        if (inverted) {
          return true;
        } else if (this.c) {
          return this.ho(t, cx, partials, this.text.substring(start, end), tags);
        }
      }

      return t;
    },

    // lambda replace variable
    lv: function(val, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = val.call(cx);

      if (typeof result == 'function') {
        result = coerceToString(result.call(cx));
        if (this.c && ~result.indexOf("{\u007B")) {
          return this.c.compile(result, this.options).render(cx, partials);
        }
      }

      return coerceToString(result);
    }

  };

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos =/\'/g,
      rQuot = /\"/g,
      hChars =/[&<>\"\']/;


  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function hoganEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp,'&amp;')
        .replace(rLt,'&lt;')
        .replace(rGt,'&gt;')
        .replace(rApos,'&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  var isArray = Array.isArray || function(a) {
    return Object.prototype.toString.call(a) === '[object Array]';
  };

})(typeof exports !== 'undefined' ? exports : Hogan);




(function (Hogan) {
  // Setup regex  assignments
  // remove whitespace according to Mustache spec
  var rIsWhitespace = /\S/,
      rQuot = /\"/g,
      rNewline =  /\n/g,
      rCr = /\r/g,
      rSlash = /\\/g,
      tagTypes = {
        '#': 1, '^': 2, '/': 3,  '!': 4, '>': 5,
        '<': 6, '=': 7, '_v': 8, '{': 9, '&': 10
      };

  Hogan.scan = function scan(text, delimiters) {
    var len = text.length,
        IN_TEXT = 0,
        IN_TAG_TYPE = 1,
        IN_TAG = 2,
        state = IN_TEXT,
        tagType = null,
        tag = null,
        buf = '',
        tokens = [],
        seenTag = false,
        i = 0,
        lineStart = 0,
        otag = '{{',
        ctag = '}}';

    function addBuf() {
      if (buf.length > 0) {
        tokens.push(new String(buf));
        buf = '';
      }
    }

    function lineIsWhitespace() {
      var isAllWhitespace = true;
      for (var j = lineStart; j < tokens.length; j++) {
        isAllWhitespace =
          (tokens[j].tag && tagTypes[tokens[j].tag] < tagTypes['_v']) ||
          (!tokens[j].tag && tokens[j].match(rIsWhitespace) === null);
        if (!isAllWhitespace) {
          return false;
        }
      }

      return isAllWhitespace;
    }

    function filterLine(haveSeenTag, noNewLine) {
      addBuf();

      if (haveSeenTag && lineIsWhitespace()) {
        for (var j = lineStart, next; j < tokens.length; j++) {
          if (!tokens[j].tag) {
            if ((next = tokens[j+1]) && next.tag == '>') {
              // set indent to token value
              next.indent = tokens[j].toString()
            }
            tokens.splice(j, 1);
          }
        }
      } else if (!noNewLine) {
        tokens.push({tag:'\n'});
      }

      seenTag = false;
      lineStart = tokens.length;
    }

    function changeDelimiters(text, index) {
      var close = '=' + ctag,
          closeIndex = text.indexOf(close, index),
          delimiters = trim(
            text.substring(text.indexOf('=', index) + 1, closeIndex)
          ).split(' ');

      otag = delimiters[0];
      ctag = delimiters[1];

      return closeIndex + close.length - 1;
    }

    if (delimiters) {
      delimiters = delimiters.split(' ');
      otag = delimiters[0];
      ctag = delimiters[1];
    }

    for (i = 0; i < len; i++) {
      if (state == IN_TEXT) {
        if (tagChange(otag, text, i)) {
          --i;
          addBuf();
          state = IN_TAG_TYPE;
        } else {
          if (text.charAt(i) == '\n') {
            filterLine(seenTag);
          } else {
            buf += text.charAt(i);
          }
        }
      } else if (state == IN_TAG_TYPE) {
        i += otag.length - 1;
        tag = tagTypes[text.charAt(i + 1)];
        tagType = tag ? text.charAt(i + 1) : '_v';
        if (tagType == '=') {
          i = changeDelimiters(text, i);
          state = IN_TEXT;
        } else {
          if (tag) {
            i++;
          }
          state = IN_TAG;
        }
        seenTag = i;
      } else {
        if (tagChange(ctag, text, i)) {
          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                       i: (tagType == '/') ? seenTag - ctag.length : i + otag.length});
          buf = '';
          i += ctag.length - 1;
          state = IN_TEXT;
          if (tagType == '{') {
            if (ctag == '}}') {
              i++;
            } else {
              cleanTripleStache(tokens[tokens.length - 1]);
            }
          }
        } else {
          buf += text.charAt(i);
        }
      }
    }

    filterLine(seenTag, true);

    return tokens;
  }

  function cleanTripleStache(token) {
    if (token.n.substr(token.n.length - 1) === '}') {
      token.n = token.n.substring(0, token.n.length - 1);
    }
  }

  function trim(s) {
    if (s.trim) {
      return s.trim();
    }

    return s.replace(/^\s*|\s*$/g, '');
  }

  function tagChange(tag, text, index) {
    if (text.charAt(index) != tag.charAt(0)) {
      return false;
    }

    for (var i = 1, l = tag.length; i < l; i++) {
      if (text.charAt(index + i) != tag.charAt(i)) {
        return false;
      }
    }

    return true;
  }

  function buildTree(tokens, kind, stack, customTags) {
    var instructions = [],
        opener = null,
        token = null;

    while (tokens.length > 0) {
      token = tokens.shift();
      if (token.tag == '#' || token.tag == '^' || isOpener(token, customTags)) {
        stack.push(token);
        token.nodes = buildTree(tokens, token.tag, stack, customTags);
        instructions.push(token);
      } else if (token.tag == '/') {
        if (stack.length === 0) {
          throw new Error('Closing tag without opener: /' + token.n);
        }
        opener = stack.pop();
        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
        }
        opener.end = token.i;
        return instructions;
      } else {
        instructions.push(token);
      }
    }

    if (stack.length > 0) {
      throw new Error('missing closing tag: ' + stack.pop().n);
    }

    return instructions;
  }

  function isOpener(token, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].o == token.n) {
        token.tag = '#';
        return true;
      }
    }
  }

  function isCloser(close, open, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].c == close && tags[i].o == open) {
        return true;
      }
    }
  }

  Hogan.generate = function (tree, text, options) {
    var code = 'var _=this;_.b(i=i||"");' + walk(tree) + 'return _.fl();';
    if (options.asString) {
      return 'function(c,p,i){' + code + ';}';
    }

    return new Hogan.Template(new Function('c', 'p', 'i', code), text, Hogan, options);
  }

  function esc(s) {
    return s.replace(rSlash, '\\\\')
            .replace(rQuot, '\\\"')
            .replace(rNewline, '\\n')
            .replace(rCr, '\\r');
  }

  function chooseMethod(s) {
    return (~s.indexOf('.')) ? 'd' : 'f';
  }

  function walk(tree) {
    var code = '';
    for (var i = 0, l = tree.length; i < l; i++) {
      var tag = tree[i].tag;
      if (tag == '#') {
        code += section(tree[i].nodes, tree[i].n, chooseMethod(tree[i].n),
                        tree[i].i, tree[i].end, tree[i].otag + " " + tree[i].ctag);
      } else if (tag == '^') {
        code += invertedSection(tree[i].nodes, tree[i].n,
                                chooseMethod(tree[i].n));
      } else if (tag == '<' || tag == '>') {
        code += partial(tree[i]);
      } else if (tag == '{' || tag == '&') {
        code += tripleStache(tree[i].n, chooseMethod(tree[i].n));
      } else if (tag == '\n') {
        code += text('"\\n"' + (tree.length-1 == i ? '' : ' + i'));
      } else if (tag == '_v') {
        code += variable(tree[i].n, chooseMethod(tree[i].n));
      } else if (tag === undefined) {
        code += text('"' + esc(tree[i]) + '"');
      }
    }
    return code;
  }

  function section(nodes, id, method, start, end, tags) {
    return 'if(_.s(_.' + method + '("' + esc(id) + '",c,p,1),' +
           'c,p,0,' + start + ',' + end + ',"' + tags + '")){' +
           '_.rs(c,p,' +
           'function(c,p,_){' +
           walk(nodes) +
           '});c.pop();}';
  }

  function invertedSection(nodes, id, method) {
    return 'if(!_.s(_.' + method + '("' + esc(id) + '",c,p,1),c,p,1,0,0,"")){' +
           walk(nodes) +
           '};';
  }

  function partial(tok) {
    return '_.b(_.rp("' +  esc(tok.n) + '",c,p,"' + (tok.indent || '') + '"));';
  }

  function tripleStache(id, method) {
    return '_.b(_.t(_.' + method + '("' + esc(id) + '",c,p,0)));';
  }

  function variable(id, method) {
    return '_.b(_.v(_.' + method + '("' + esc(id) + '",c,p,0)));';
  }

  function text(id) {
    return '_.b(' + id + ');';
  }

  Hogan.parse = function(tokens, text, options) {
    options = options || {};
    return buildTree(tokens, '', [], options.sectionTags || []);
  },

  Hogan.cache = {};

  Hogan.compile = function(text, options) {
    // options
    //
    // asString: false (default)
    //
    // sectionTags: [{o: '_foo', c: 'foo'}]
    // An array of object with o and c fields that indicate names for custom
    // section tags. The example above allows parsing of {{_foo}}{{/foo}}.
    //
    // delimiters: A string that overrides the default delimiters.
    // Example: "<% %>"
    //
    options = options || {};

    var key = text + '||' + !!options.asString;

    var t = this.cache[key];

    if (t) {
      return t;
    }

    t = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
    return this.cache[key] = t;
  };
})(typeof exports !== 'undefined' ? exports : Hogan);


!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var i;"undefined"!=typeof window?i=window:"undefined"!=typeof global?i=global:"undefined"!=typeof self&&(i=self),i.famous=t()}}(function(){return function t(i,e,n){function o(r,a){if(!e[r]){if(!i[r]){var h="function"==typeof require&&require;if(!a&&h)return h(r,!0);if(s)return s(r,!0);var c=new Error("Cannot find module '"+r+"'");throw c.code="MODULE_NOT_FOUND",c}var p=e[r]={exports:{}};i[r][0].call(p.exports,function(t){var e=i[r][1][t];return o(e?e:t)},p,p.exports,t,i,e,n)}return e[r].exports}for(var s="function"==typeof require&&require,r=0;r<n.length;r++)o(n[r]);return o}({1:[function(t,i){function e(){var t=this.container;return[t.clientWidth,t.clientHeight]}function n(t){this.container=t,this._allocator=new r(t),this._node=new o,this._eventOutput=new s,this._size=e.call(this),this._perspectiveState=new h(0),this._perspective=void 0,this._nodeContext={allocator:this._allocator,transform:a.identity,opacity:1,origin:c,align:c,size:this._size},this._eventOutput.on("resize",function(){this.setSize(e.call(this))}.bind(this))}var o=t("./RenderNode"),s=t("./EventHandler"),r=t("./ElementAllocator"),a=t("./Transform"),h=t("../transitions/Transitionable"),c=[0,0],p=!("perspective"in document.documentElement.style),u=p?function(t,i){t.style.webkitPerspective=i?i.toFixed()+"px":""}:function(t,i){t.style.perspective=i?i.toFixed()+"px":""};n.prototype.getAllocator=function(){return this._allocator},n.prototype.add=function(t){return this._node.add(t)},n.prototype.migrate=function(t){t!==this.container&&(this.container=t,this._allocator.migrate(t))},n.prototype.getSize=function(){return this._size},n.prototype.setSize=function(t){t||(t=e.call(this)),this._size[0]=t[0],this._size[1]=t[1]},n.prototype.update=function(t){t&&(t.transform&&(this._nodeContext.transform=t.transform),t.opacity&&(this._nodeContext.opacity=t.opacity),t.origin&&(this._nodeContext.origin=t.origin),t.align&&(this._nodeContext.align=t.align),t.size&&(this._nodeContext.size=t.size));var i=this._perspectiveState.get();i!==this._perspective&&(u(this.container,i),this._perspective=i),this._node.commit(this._nodeContext)},n.prototype.getPerspective=function(){return this._perspectiveState.get()},n.prototype.setPerspective=function(t,i,e){return this._perspectiveState.set(t,i,e)},n.prototype.emit=function(t,i){return this._eventOutput.emit(t,i)},n.prototype.on=function(t,i){return this._eventOutput.on(t,i)},n.prototype.removeListener=function(t,i){return this._eventOutput.removeListener(t,i)},n.prototype.pipe=function(t){return this._eventOutput.pipe(t)},n.prototype.unpipe=function(t){return this._eventOutput.unpipe(t)},i.exports=n},{"../transitions/Transitionable":88,"./ElementAllocator":2,"./EventHandler":7,"./RenderNode":11,"./Transform":15}],2:[function(t,i){function e(t){t||(t=document.createDocumentFragment()),this.container=t,this.detachedNodes={},this.nodeCount=0}e.prototype.migrate=function(t){var i=this.container;if(t!==i){if(i instanceof DocumentFragment)t.appendChild(i);else for(;i.hasChildNodes();)t.appendChild(i.firstChild);this.container=t}},e.prototype.allocate=function(t){t=t.toLowerCase(),t in this.detachedNodes||(this.detachedNodes[t]=[]);var i,e=this.detachedNodes[t];return e.length>0?i=e.pop():(i=document.createElement(t),this.container.appendChild(i)),this.nodeCount++,i},e.prototype.deallocate=function(t){var i=t.nodeName.toLowerCase(),e=this.detachedNodes[i];e.push(t),this.nodeCount--},e.prototype.getNodeCount=function(){return this.nodeCount},i.exports=e},{}],3:[function(t,i){function e(t){this._matrix=null,this._opacity=1,this._origin=null,this._size=null,this._eventOutput=new c,this._eventOutput.bindThis(this),this.eventForwarder=function(t){this._eventOutput.emit(t.type,t)}.bind(this),this.id=h.register(this),this._element=null,this._sizeDirty=!1,this._originDirty=!1,this._transformDirty=!1,this._invisible=!1,t&&this.attach(t)}function n(t){for(var i in this._eventOutput.listeners)t.addEventListener(i,this.eventForwarder)}function o(t){for(var i in this._eventOutput.listeners)t.removeEventListener(i,this.eventForwarder)}function s(t){t[12]=Math.round(t[12]*l)/l,t[13]=Math.round(t[13]*l)/l;for(var i="matrix3d(",e=0;15>e;e++)i+=t[e]<1e-6&&t[e]>-1e-6?"0,":t[e]+",";return i+=t[15]+")"}function r(t){return 100*t[0]+"% "+100*t[1]+"%"}function a(t,i){return t&&i?t[0]!==i[0]||t[1]!==i[1]:t!==i}var h=t("./Entity"),c=t("./EventHandler"),p=t("./Transform"),u=!("transform"in document.documentElement.style),l=window.devicePixelRatio||1;e.prototype.on=function(t,i){this._element&&this._element.addEventListener(t,this.eventForwarder),this._eventOutput.on(t,i)},e.prototype.removeListener=function(t,i){this._eventOutput.removeListener(t,i)},e.prototype.emit=function(t,i){i&&!i.origin&&(i.origin=this);var e=this._eventOutput.emit(t,i);return e&&i&&i.stopPropagation&&i.stopPropagation(),e},e.prototype.pipe=function(t){return this._eventOutput.pipe(t)},e.prototype.unpipe=function(t){return this._eventOutput.unpipe(t)},e.prototype.render=function(){return this.id};var f;f=u?function(t,i){t.style.webkitTransform=s(i)}:function(t,i){t.style.transform=s(i)};var d=u?function(t,i){t.style.webkitTransformOrigin=r(i)}:function(t,i){t.style.transformOrigin=r(i)},_=u?function(t){t.style.webkitTransform="scale3d(0.0001,0.0001,0.0001)",t.style.opacity=0}:function(t){t.style.transform="scale3d(0.0001,0.0001,0.0001)",t.style.opacity=0};e.prototype.commit=function(t){var i=this._element;if(i){var e=t.transform,n=t.opacity,o=t.origin;if(t.size,!e&&this._matrix)return this._matrix=null,this._opacity=0,_(i),void 0;if(a(this._origin,o)&&(this._originDirty=!0),p.notEquals(this._matrix,e)&&(this._transformDirty=!0),this._invisible&&(this._invisible=!1,this._element.style.display=""),this._opacity!==n&&(this._opacity=n,i.style.opacity=n>=1?"0.999999":n),this._transformDirty||this._originDirty||this._sizeDirty){this._sizeDirty&&(this._sizeDirty=!1),this._originDirty&&(o?(this._origin||(this._origin=[0,0]),this._origin[0]=o[0],this._origin[1]=o[1]):this._origin=null,d(i,this._origin),this._originDirty=!1),e||(e=p.identity),this._matrix=e;var s=this._size?p.thenMove(e,[-this._size[0]*o[0],-this._size[1]*o[1],0]):e;f(i,s),this._transformDirty=!1}}},e.prototype.cleanup=function(){this._element&&(this._invisible=!0,this._element.style.display="none")},e.prototype.attach=function(t){this._element=t,n.call(this,t)},e.prototype.detach=function(){var t=this._element;return t&&(o.call(this,t),this._invisible&&(this._invisible=!1,this._element.style.display="")),this._element=null,t},i.exports=e},{"./Entity":5,"./EventHandler":7,"./Transform":15}],4:[function(t,i){function e(){w.runLoop?(f.step(),window.requestAnimationFrame(e)):O=!1}function n(){for(var t=0;t<d.length;t++)d[t].emit("resize");T.emit("resize")}function o(){window.addEventListener("touchmove",function(t){t.preventDefault()},!0),s()}function s(){return document.body?(document.body.classList.add("famous-root"),document.documentElement.classList.add("famous-root"),void 0):(f.nextTick(s),void 0)}function r(t,i){return document.body?(document.body.addEventListener(t,i),void 0):(f.nextTick(addEventListener.bind(this,t,i)),void 0)}function a(t,i){return document.body?(document.body.appendChild(i),t.emit("resize"),void 0):(f.nextTick(a.bind(this,t,i)),void 0)}var h,c,p=t("./Context"),u=t("./EventHandler"),l=t("./OptionsManager"),f={},d=[],_=[],g=0,y=0,v=[],m=Date.now(),O=!0,S={},T=new u,w={containerType:"div",containerClass:"famous-container",fpsCap:void 0,runLoop:!0,appMode:!0},b=new l(w),E=10;f.step=function(){g++,y=g;var t=Date.now();if(!(c&&c>t-m)){var i=0;h=t-m,m=t,T.emit("prerender");for(var e=_.length;e--;)_.shift()(g);for(;v.length&&Date.now()-t<E;)v.shift().call(this);for(i=0;i<d.length;i++)d[i].update();T.emit("postrender")}},window.requestAnimationFrame(e),window.addEventListener("resize",n,!1),n();var z=!1;f.pipe=function(t){return t.subscribe instanceof Function?t.subscribe(f):T.pipe(t)},f.unpipe=function(t){return t.unsubscribe instanceof Function?t.unsubscribe(f):T.unpipe(t)},f.on=function(t,i){return t in S||(S[t]=T.emit.bind(T,t),r(t,S[t])),T.on(t,i)},f.emit=function(t,i){return T.emit(t,i)},f.removeListener=function(t,i){return T.removeListener(t,i)},f.getFPS=function(){return 1e3/h},f.setFPSCap=function(t){c=Math.floor(1e3/t)},f.getOptions=function(t){return b.getOptions(t)},f.setOptions=function(){return b.setOptions.apply(b,arguments)},f.createContext=function(t){!z&&w.appMode&&f.nextTick(o);var i=!1;t||(t=document.createElement(w.containerType),t.classList.add(w.containerClass),i=!0);var e=new p(t);return f.registerContext(e),i&&a(e,t),e},f.registerContext=function(t){return d.push(t),t},f.getContexts=function(){return d},f.deregisterContext=function(t){var i=d.indexOf(t);i>=0&&d.splice(i,1)},f.nextTick=function(t){_.push(t)},f.defer=function(t){v.push(t)},b.on("change",function(t){"fpsCap"===t.id?f.setFPSCap(t.value):"runLoop"===t.id&&!O&&t.value&&(O=!0,window.requestAnimationFrame(e))}),i.exports=f},{"./Context":1,"./EventHandler":7,"./OptionsManager":10}],5:[function(t,i){function e(t){return r[t]}function n(t,i){r[t]=i}function o(t){var i=r.length;return n(i,t),i}function s(t){n(t,null)}var r=[];i.exports={register:o,unregister:s,get:e,set:n}},{}],6:[function(t,i){function e(){this.listeners={},this._owner=this}e.prototype.emit=function(t,i){var e=this.listeners[t];if(e)for(var n=0;n<e.length;n++)e[n].call(this._owner,i);return this},e.prototype.on=function(t,i){t in this.listeners||(this.listeners[t]=[]);var e=this.listeners[t].indexOf(i);return 0>e&&this.listeners[t].push(i),this},e.prototype.addListener=e.prototype.on,e.prototype.removeListener=function(t,i){var e=this.listeners[t];if(void 0!==e){var n=e.indexOf(i);n>=0&&e.splice(n,1)}return this},e.prototype.bindThis=function(t){this._owner=t},i.exports=e},{}],7:[function(t,i){function e(){n.apply(this,arguments),this.downstream=[],this.downstreamFn=[],this.upstream=[],this.upstreamListeners={}}var n=t("./EventEmitter");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.setInputHandler=function(t,i){t.trigger=i.trigger.bind(i),i.subscribe&&i.unsubscribe&&(t.subscribe=i.subscribe.bind(i),t.unsubscribe=i.unsubscribe.bind(i))},e.setOutputHandler=function(t,i){i instanceof e&&i.bindThis(t),t.pipe=i.pipe.bind(i),t.unpipe=i.unpipe.bind(i),t.on=i.on.bind(i),t.addListener=t.on,t.removeListener=i.removeListener.bind(i)},e.prototype.emit=function(t,i){n.prototype.emit.apply(this,arguments);var e=0;for(e=0;e<this.downstream.length;e++)this.downstream[e].trigger&&this.downstream[e].trigger(t,i);for(e=0;e<this.downstreamFn.length;e++)this.downstreamFn[e](t,i);return this},e.prototype.trigger=e.prototype.emit,e.prototype.pipe=function(t){if(t.subscribe instanceof Function)return t.subscribe(this);var i=t instanceof Function?this.downstreamFn:this.downstream,e=i.indexOf(t);return 0>e&&i.push(t),t instanceof Function?t("pipe",null):t.trigger&&t.trigger("pipe",null),t},e.prototype.unpipe=function(t){if(t.unsubscribe instanceof Function)return t.unsubscribe(this);var i=t instanceof Function?this.downstreamFn:this.downstream,e=i.indexOf(t);return e>=0?(i.splice(e,1),t instanceof Function?t("unpipe",null):t.trigger&&t.trigger("unpipe",null),t):!1},e.prototype.on=function(t){if(n.prototype.on.apply(this,arguments),!(t in this.upstreamListeners)){var i=this.trigger.bind(this,t);this.upstreamListeners[t]=i;for(var e=0;e<this.upstream.length;e++)this.upstream[e].on(t,i)}return this},e.prototype.addListener=e.prototype.on,e.prototype.subscribe=function(t){var i=this.upstream.indexOf(t);if(0>i){this.upstream.push(t);for(var e in this.upstreamListeners)t.on(e,this.upstreamListeners[e])}return this},e.prototype.unsubscribe=function(t){var i=this.upstream.indexOf(t);if(i>=0){this.upstream.splice(i,1);for(var e in this.upstreamListeners)t.removeListener(e,this.upstreamListeners[e])}return this},i.exports=e},{"./EventEmitter":6}],8:[function(t,i){function e(t){s.call(this,t),this._shouldRecalculateSize=!1,this._container=document.createDocumentFragment(),this.context=new n(this._container),this.setContent(this._container),this._groupSize=[void 0,void 0]}var n=t("./Context"),o=t("./Transform"),s=t("./Surface");e.SIZE_ZERO=[0,0],e.prototype=Object.create(s.prototype),e.prototype.elementType="div",e.prototype.elementClass="famous-group",e.prototype.add=function(){return this.context.add.apply(this.context,arguments)},e.prototype.render=function(){return s.prototype.render.call(this)},e.prototype.deploy=function(t){this.context.migrate(t)},e.prototype.recall=function(){this._container=document.createDocumentFragment(),this.context.migrate(this._container)},e.prototype.commit=function(t){var i=t.transform,n=t.origin,r=t.opacity,a=t.size,h=s.prototype.commit.call(this,{allocator:t.allocator,transform:o.thenMove(i,[-n[0]*a[0],-n[1]*a[1],0]),opacity:r,origin:n,size:e.SIZE_ZERO});return(a[0]!==this._groupSize[0]||a[1]!==this._groupSize[1])&&(this._groupSize[0]=a[0],this._groupSize[1]=a[1],this.context.setSize(a)),this.context.update({transform:o.translate(-n[0]*a[0],-n[1]*a[1],0),origin:n,size:a}),h},i.exports=e},{"./Context":1,"./Surface":14,"./Transform":15}],9:[function(t,i){function e(t){this._transformGetter=null,this._opacityGetter=null,this._originGetter=null,this._alignGetter=null,this._sizeGetter=null,this._proportionGetter=null,this._legacyStates={},this._output={transform:o.identity,opacity:1,origin:null,align:null,size:null,proportions:null,target:null},t&&(t.transform&&this.transformFrom(t.transform),void 0!==t.opacity&&this.opacityFrom(t.opacity),t.origin&&this.originFrom(t.origin),t.align&&this.alignFrom(t.align),t.size&&this.sizeFrom(t.size),t.proportions&&this.proportionsFrom(t.proportions))}function n(){this._transformGetter&&(this._output.transform=this._transformGetter()),this._opacityGetter&&(this._output.opacity=this._opacityGetter()),this._originGetter&&(this._output.origin=this._originGetter()),this._alignGetter&&(this._output.align=this._alignGetter()),this._sizeGetter&&(this._output.size=this._sizeGetter()),this._proportionGetter&&(this._output.proportions=this._proportionGetter())}var o=t("./Transform"),s=t("../transitions/Transitionable"),r=t("../transitions/TransitionableTransform");e.prototype.transformFrom=function(t){return t instanceof Function?this._transformGetter=t:t instanceof Object&&t.get?this._transformGetter=t.get.bind(t):(this._transformGetter=null,this._output.transform=t),this},e.prototype.opacityFrom=function(t){return t instanceof Function?this._opacityGetter=t:t instanceof Object&&t.get?this._opacityGetter=t.get.bind(t):(this._opacityGetter=null,this._output.opacity=t),this},e.prototype.originFrom=function(t){return t instanceof Function?this._originGetter=t:t instanceof Object&&t.get?this._originGetter=t.get.bind(t):(this._originGetter=null,this._output.origin=t),this},e.prototype.alignFrom=function(t){return t instanceof Function?this._alignGetter=t:t instanceof Object&&t.get?this._alignGetter=t.get.bind(t):(this._alignGetter=null,this._output.align=t),this},e.prototype.sizeFrom=function(t){return t instanceof Function?this._sizeGetter=t:t instanceof Object&&t.get?this._sizeGetter=t.get.bind(t):(this._sizeGetter=null,this._output.size=t),this},e.prototype.proportionsFrom=function(t){return t instanceof Function?this._proportionGetter=t:t instanceof Object&&t.get?this._proportionGetter=t.get.bind(t):(this._proportionGetter=null,this._output.proportions=t),this},e.prototype.setTransform=function(t,i,e){return i||this._legacyStates.transform?(this._legacyStates.transform||(this._legacyStates.transform=new r(this._output.transform)),this._transformGetter||this.transformFrom(this._legacyStates.transform),this._legacyStates.transform.set(t,i,e),this):this.transformFrom(t)},e.prototype.setOpacity=function(t,i,e){return i||this._legacyStates.opacity?(this._legacyStates.opacity||(this._legacyStates.opacity=new s(this._output.opacity)),this._opacityGetter||this.opacityFrom(this._legacyStates.opacity),this._legacyStates.opacity.set(t,i,e)):this.opacityFrom(t)},e.prototype.setOrigin=function(t,i,e){return i||this._legacyStates.origin?(this._legacyStates.origin||(this._legacyStates.origin=new s(this._output.origin||[0,0])),this._originGetter||this.originFrom(this._legacyStates.origin),this._legacyStates.origin.set(t,i,e),this):this.originFrom(t)},e.prototype.setAlign=function(t,i,e){return i||this._legacyStates.align?(this._legacyStates.align||(this._legacyStates.align=new s(this._output.align||[0,0])),this._alignGetter||this.alignFrom(this._legacyStates.align),this._legacyStates.align.set(t,i,e),this):this.alignFrom(t)},e.prototype.setSize=function(t,i,e){return t&&(i||this._legacyStates.size)?(this._legacyStates.size||(this._legacyStates.size=new s(this._output.size||[0,0])),this._sizeGetter||this.sizeFrom(this._legacyStates.size),this._legacyStates.size.set(t,i,e),this):this.sizeFrom(t)},e.prototype.setProportions=function(t,i,e){return t&&(i||this._legacyStates.proportions)?(this._legacyStates.proportions||(this._legacyStates.proportions=new s(this._output.proportions||[0,0])),this._proportionGetter||this.proportionsFrom(this._legacyStates.proportions),this._legacyStates.proportions.set(t,i,e),this):this.proportionsFrom(t)},e.prototype.halt=function(){this._legacyStates.transform&&this._legacyStates.transform.halt(),this._legacyStates.opacity&&this._legacyStates.opacity.halt(),this._legacyStates.origin&&this._legacyStates.origin.halt(),this._legacyStates.align&&this._legacyStates.align.halt(),this._legacyStates.size&&this._legacyStates.size.halt(),this._legacyStates.proportions&&this._legacyStates.proportions.halt(),this._transformGetter=null,this._opacityGetter=null,this._originGetter=null,this._alignGetter=null,this._sizeGetter=null,this._proportionGetter=null},e.prototype.getTransform=function(){return this._transformGetter()},e.prototype.getFinalTransform=function(){return this._legacyStates.transform?this._legacyStates.transform.getFinal():this._output.transform},e.prototype.getOpacity=function(){return this._opacityGetter()},e.prototype.getOrigin=function(){return this._originGetter()},e.prototype.getAlign=function(){return this._alignGetter()},e.prototype.getSize=function(){return this._sizeGetter?this._sizeGetter():this._output.size},e.prototype.getProportions=function(){return this._proportionGetter?this._proportionGetter():this._output.proportions},e.prototype.modify=function(t){return n.call(this),this._output.target=t,this._output},i.exports=e},{"../transitions/Transitionable":88,"../transitions/TransitionableTransform":89,"./Transform":15}],10:[function(t,i){function e(t){this._value=t,this.eventOutput=null}function n(){this.eventOutput=new o,this.eventOutput.bindThis(this),o.setOutputHandler(this,this.eventOutput)}var o=t("./EventHandler");e.patch=function(t){for(var i=new e(t),n=1;n<arguments.length;n++)i.patch(arguments[n]);return t},e.prototype.patch=function(){for(var t=this._value,i=0;i<arguments.length;i++){var e=arguments[i];for(var n in e)n in t&&e[n]&&e[n].constructor===Object&&t[n]&&t[n].constructor===Object?(t.hasOwnProperty(n)||(t[n]=Object.create(t[n])),this.key(n).patch(e[n]),this.eventOutput&&this.eventOutput.emit("change",{id:n,value:this.key(n).value()})):this.set(n,e[n])}return this},e.prototype.setOptions=e.prototype.patch,e.prototype.key=function(t){var i=new e(this._value[t]);return(!(i._value instanceof Object)||i._value instanceof Array)&&(i._value={}),i},e.prototype.get=function(t){return t?this._value[t]:this._value},e.prototype.getOptions=e.prototype.get,e.prototype.set=function(t,i){var e=this.get(t);return this._value[t]=i,this.eventOutput&&i!==e&&this.eventOutput.emit("change",{id:t,value:i}),this},e.prototype.on=function(){return n.call(this),this.on.apply(this,arguments)},e.prototype.removeListener=function(){return n.call(this),this.removeListener.apply(this,arguments)},e.prototype.pipe=function(){return n.call(this),this.pipe.apply(this,arguments)},e.prototype.unpipe=function(){return n.call(this),this.unpipe.apply(this,arguments)},i.exports=e},{"./EventHandler":7}],11:[function(t,i){function e(t){this._object=null,this._child=null,this._hasMultipleChildren=!1,this._isRenderable=!1,this._isModifier=!1,this._resultCache={},this._prevResults={},this._childResult=null,t&&this.set(t)}function n(t,i,e){for(var r=s.parse(t,i),a=Object.keys(r),h=0;h<a.length;h++){var c=a[h],p=o.get(c),u=r[c];u.allocator=i.allocator;var l=p.commit(u);l?n(l,i,e):e[c]=u}}var o=t("./Entity"),s=t("./SpecParser");e.prototype.add=function(t){var i=t instanceof e?t:new e(t);return this._child instanceof Array?this._child.push(i):this._child?(this._child=[this._child,i],this._hasMultipleChildren=!0,this._childResult=[]):this._child=i,i},e.prototype.get=function(){return this._object||(this._hasMultipleChildren?null:this._child?this._child.get():null)},e.prototype.set=function(t){return this._childResult=null,this._hasMultipleChildren=!1,this._isRenderable=t.render?!0:!1,this._isModifier=t.modify?!0:!1,this._object=t,this._child=null,t instanceof e?t:this},e.prototype.getSize=function(){var t=null,i=this.get();return i&&i.getSize&&(t=i.getSize()),!t&&this._child&&this._child.getSize&&(t=this._child.getSize()),t},e.prototype.commit=function(t){for(var i=Object.keys(this._prevResults),e=0;e<i.length;e++){var s=i[e];if(void 0===this._resultCache[s]){var r=o.get(s);r.cleanup&&r.cleanup(t.allocator)}}this._prevResults=this._resultCache,this._resultCache={},n(this.render(),t,this._resultCache)},e.prototype.render=function(){if(this._isRenderable)return this._object.render();var t=null;if(this._hasMultipleChildren){t=this._childResult;for(var i=this._child,e=0;e<i.length;e++)t[e]=i[e].render()}else this._child&&(t=this._child.render());return this._isModifier?this._object.modify(t):t},i.exports=e},{"./Entity":5,"./SpecParser":13}],12:[function(t,i){function e(t){this.id=null,this._objects=null,this.node=new c,this._definition=null,t&&this.load(t)}function n(t){for(var i in p)if(i in t){var e=t[i];return e instanceof Array||(e=[e]),p[i].apply(this,e)}}function o(t){var i=t.transform,e=t.opacity,o=t.origin,s=t.align,r=t.size,c=a.identity;if(i instanceof Array)if(16===i.length&&"number"==typeof i[0])c=i;else for(var p=0;p<i.length;p++)c=a.multiply(c,n(i[p]));else i instanceof Function?c=i:i instanceof Object&&(c=n(i));var u=new h({transform:c,opacity:e,origin:o,align:s,size:r});return u}function s(t){for(var i=new c,e=0;e<t.length;e++){var n=r.call(this,t[e]);n&&i.add(n)}return i}function r(t){var i,e;if(t instanceof Array)i=s.call(this,t);else if(e=this._objects.length,t.render&&t.render instanceof Function)i=t;else if(t.target){var n=r.call(this,t.target),a=o.call(this,t);i=new c(a),i.add(n),t.id&&(this.id[t.id]=a)}else t.id&&(i=new c,this.id[t.id]=i);return this._objects[e]=i,i}var a=t("./Transform"),h=t("./Modifier"),c=t("./RenderNode"),p={translate:a.translate,rotate:a.rotate,rotateX:a.rotateX,rotateY:a.rotateY,rotateZ:a.rotateZ,rotateAxis:a.rotateAxis,scale:a.scale,skew:a.skew,matrix3d:function(){return arguments}};e.prototype.create=function(){return new e(this._definition)},e.prototype.load=function(t){this._definition=t,this.id={},this._objects=[],this.node.set(r.call(this,t))},e.prototype.add=function(){return this.node.add.apply(this.node,arguments)},e.prototype.render=function(){return this.node.render.apply(this.node,arguments)},i.exports=e},{"./Modifier":9,"./RenderNode":11,"./Transform":15}],13:[function(t,i){function e(){this.result={}}function n(t,i){return[t[0]*i[0]+t[1]*i[4]+t[2]*i[8],t[0]*i[1]+t[1]*i[5]+t[2]*i[9],t[0]*i[2]+t[1]*i[6]+t[2]*i[10]]}var o=t("./Transform");e._instance=new e,e.parse=function(t,i){return e._instance.parse(t,i)},e.prototype.parse=function(t,i){return this.reset(),this._parseSpec(t,i,o.identity),this.result},e.prototype.reset=function(){this.result={}};var s=[0,0];e.prototype._parseSpec=function(t,i,e){var r,a,h,c,p,u,l;if("number"==typeof t){if(r=t,h=i.transform,u=i.align||s,i.size&&u&&(u[0]||u[1])){var f=[u[0]*i.size[0],u[1]*i.size[1],0];h=o.thenMove(h,n(f,e))}this.result[r]={transform:h,opacity:i.opacity,origin:i.origin||s,align:i.align||s,size:i.size}}else{if(!t)return;if(t instanceof Array)for(var d=0;d<t.length;d++)this._parseSpec(t[d],i,e);else{a=t.target,h=i.transform,c=i.opacity,p=i.origin,u=i.align,l=i.size;var _=e;if(void 0!==t.opacity&&(c=i.opacity*t.opacity),t.transform&&(h=o.multiply(i.transform,t.transform)),t.origin&&(p=t.origin,_=i.transform),t.align&&(u=t.align),t.size||t.proportions){var g=l;l=[l[0],l[1]],t.size&&(void 0!==t.size[0]&&(l[0]=t.size[0]),void 0!==t.size[1]&&(l[1]=t.size[1])),t.proportions&&(void 0!==t.proportions[0]&&(l[0]=l[0]*t.proportions[0]),void 0!==t.proportions[1]&&(l[1]=l[1]*t.proportions[1])),g&&(u&&(u[0]||u[1])&&(h=o.thenMove(h,n([u[0]*g[0],u[1]*g[1],0],e))),p&&(p[0]||p[1])&&(h=o.moveThen([-p[0]*l[0],-p[1]*l[1],0],h))),_=i.transform,p=null,u=null}this._parseSpec(a,{transform:h,opacity:c,origin:p,align:u,size:l},_)}}},i.exports=e},{"./Transform":15}],14:[function(t,i){function e(t){c.call(this),this.options={},this.properties={},this.attributes={},this.content="",this.classList=[],this.size=null,this._classesDirty=!0,this._stylesDirty=!0,this._attributesDirty=!0,this._sizeDirty=!0,this._contentDirty=!0,this._trueSizeCheck=!0,this._dirtyClasses=[],t&&this.setOptions(t),this._currentTarget=null}function n(t){for(var i=0;i<this._dirtyClasses.length;i++)t.classList.remove(this._dirtyClasses[i]);this._dirtyClasses=[]}function o(t){for(var i in this.properties)t.style[i]=this.properties[i]}function s(t){for(var i in this.properties)t.style[i]=""}function r(t){for(var i in this.attributes)t.setAttribute(i,this.attributes[i])}function a(t){for(var i in this.attributes)t.removeAttribute(i)}function h(t,i){return t&&i?t[0]!==i[0]||t[1]!==i[1]:t!==i}var c=t("./ElementOutput");e.prototype=Object.create(c.prototype),e.prototype.constructor=e,e.prototype.elementType="div",e.prototype.elementClass="famous-surface",e.prototype.setAttributes=function(t){for(var i in t){if("style"===i)throw new Error('Cannot set styles via "setAttributes" as it will break Famo.us.  Use "setProperties" instead.');this.attributes[i]=t[i]}this._attributesDirty=!0},e.prototype.getAttributes=function(){return this.attributes},e.prototype.setProperties=function(t){for(var i in t)this.properties[i]=t[i];return this._stylesDirty=!0,this},e.prototype.getProperties=function(){return this.properties},e.prototype.addClass=function(t){return this.classList.indexOf(t)<0&&(this.classList.push(t),this._classesDirty=!0),this},e.prototype.removeClass=function(t){var i=this.classList.indexOf(t);return i>=0&&(this._dirtyClasses.push(this.classList.splice(i,1)[0]),this._classesDirty=!0),this},e.prototype.toggleClass=function(t){var i=this.classList.indexOf(t);return i>=0?this.removeClass(t):this.addClass(t),this},e.prototype.setClasses=function(t){var i=0,e=[];for(i=0;i<this.classList.length;i++)t.indexOf(this.classList[i])<0&&e.push(this.classList[i]);for(i=0;i<e.length;i++)this.removeClass(e[i]);for(i=0;i<t.length;i++)this.addClass(t[i]);return this},e.prototype.getClassList=function(){return this.classList},e.prototype.setContent=function(t){return this.content!==t&&(this.content=t,this._contentDirty=!0),this},e.prototype.getContent=function(){return this.content},e.prototype.setOptions=function(t){return t.size&&this.setSize(t.size),t.classes&&this.setClasses(t.classes),t.properties&&this.setProperties(t.properties),t.attributes&&this.setAttributes(t.attributes),t.content&&this.setContent(t.content),this},e.prototype.setup=function(t){var i=t.allocate(this.elementType);if(this.elementClass)if(this.elementClass instanceof Array)for(var e=0;e<this.elementClass.length;e++)i.classList.add(this.elementClass[e]);else i.classList.add(this.elementClass);i.style.display="",this.attach(i),this._opacity=null,this._currentTarget=i,this._stylesDirty=!0,this._classesDirty=!0,this._attributesDirty=!0,this._sizeDirty=!0,this._contentDirty=!0,this._originDirty=!0,this._transformDirty=!0},e.prototype.commit=function(t){this._currentTarget||this.setup(t.allocator);var i=this._currentTarget,e=t.size;if(this._classesDirty){n.call(this,i);for(var s=this.getClassList(),a=0;a<s.length;a++)i.classList.add(s[a]);this._classesDirty=!1,this._trueSizeCheck=!0}if(this._stylesDirty&&(o.call(this,i),this._stylesDirty=!1,this._trueSizeCheck=!0),this._attributesDirty&&(r.call(this,i),this._attributesDirty=!1,this._trueSizeCheck=!0),this.size){var p=t.size;if(e=[this.size[0],this.size[1]],void 0===e[0]&&(e[0]=p[0]),void 0===e[1]&&(e[1]=p[1]),e[0]===!0||e[1]===!0){if(e[0]===!0)if(this._trueSizeCheck||0===this._size[0]){var u=i.offsetWidth;this._size&&this._size[0]!==u&&(this._size[0]=u,this._sizeDirty=!0),e[0]=u}else this._size&&(e[0]=this._size[0]);if(e[1]===!0)if(this._trueSizeCheck||0===this._size[1]){var l=i.offsetHeight;this._size&&this._size[1]!==l&&(this._size[1]=l,this._sizeDirty=!0),e[1]=l}else this._size&&(e[1]=this._size[1]);this._trueSizeCheck=!1}}h(this._size,e)&&(this._size||(this._size=[0,0]),this._size[0]=e[0],this._size[1]=e[1],this._sizeDirty=!0),this._sizeDirty&&(this._size&&(i.style.width=this.size&&this.size[0]===!0?"":this._size[0]+"px",i.style.height=this.size&&this.size[1]===!0?"":this._size[1]+"px"),this._eventOutput.emit("resize")),this._contentDirty&&(this.deploy(i),this._eventOutput.emit("deploy"),this._contentDirty=!1,this._trueSizeCheck=!0),c.prototype.commit.call(this,t)},e.prototype.cleanup=function(t){var i=0,e=this._currentTarget;this._eventOutput.emit("recall"),this.recall(e),e.style.display="none",e.style.opacity="",e.style.width="",e.style.height="",s.call(this,e),a.call(this,e);var o=this.getClassList();for(n.call(this,e),i=0;i<o.length;i++)e.classList.remove(o[i]);if(this.elementClass)if(this.elementClass instanceof Array)for(i=0;i<this.elementClass.length;i++)e.classList.remove(this.elementClass[i]);else e.classList.remove(this.elementClass);this.detach(e),this._currentTarget=null,t.deallocate(e)},e.prototype.deploy=function(t){var i=this.getContent();if(i instanceof Node){for(;t.hasChildNodes();)t.removeChild(t.firstChild);t.appendChild(i)}else t.innerHTML=i},e.prototype.recall=function(t){for(var i=document.createDocumentFragment();t.hasChildNodes();)i.appendChild(t.firstChild);this.setContent(i)},e.prototype.getSize=function(){return this._size?this._size:this.size},e.prototype.setSize=function(t){return this.size=t?[t[0],t[1]]:null,this._sizeDirty=!0,this},i.exports=e},{"./ElementOutput":3}],15:[function(t,i){function e(t){return 2===t.length?t[0]*t[0]+t[1]*t[1]:t[0]*t[0]+t[1]*t[1]+t[2]*t[2]}function n(t){return Math.sqrt(e(t))}function o(t){return 0>t?-1:1}var s={};s.precision=1e-6,s.identity=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],s.multiply4x4=function(t,i){return[t[0]*i[0]+t[4]*i[1]+t[8]*i[2]+t[12]*i[3],t[1]*i[0]+t[5]*i[1]+t[9]*i[2]+t[13]*i[3],t[2]*i[0]+t[6]*i[1]+t[10]*i[2]+t[14]*i[3],t[3]*i[0]+t[7]*i[1]+t[11]*i[2]+t[15]*i[3],t[0]*i[4]+t[4]*i[5]+t[8]*i[6]+t[12]*i[7],t[1]*i[4]+t[5]*i[5]+t[9]*i[6]+t[13]*i[7],t[2]*i[4]+t[6]*i[5]+t[10]*i[6]+t[14]*i[7],t[3]*i[4]+t[7]*i[5]+t[11]*i[6]+t[15]*i[7],t[0]*i[8]+t[4]*i[9]+t[8]*i[10]+t[12]*i[11],t[1]*i[8]+t[5]*i[9]+t[9]*i[10]+t[13]*i[11],t[2]*i[8]+t[6]*i[9]+t[10]*i[10]+t[14]*i[11],t[3]*i[8]+t[7]*i[9]+t[11]*i[10]+t[15]*i[11],t[0]*i[12]+t[4]*i[13]+t[8]*i[14]+t[12]*i[15],t[1]*i[12]+t[5]*i[13]+t[9]*i[14]+t[13]*i[15],t[2]*i[12]+t[6]*i[13]+t[10]*i[14]+t[14]*i[15],t[3]*i[12]+t[7]*i[13]+t[11]*i[14]+t[15]*i[15]]},s.multiply=function(t,i){return[t[0]*i[0]+t[4]*i[1]+t[8]*i[2],t[1]*i[0]+t[5]*i[1]+t[9]*i[2],t[2]*i[0]+t[6]*i[1]+t[10]*i[2],0,t[0]*i[4]+t[4]*i[5]+t[8]*i[6],t[1]*i[4]+t[5]*i[5]+t[9]*i[6],t[2]*i[4]+t[6]*i[5]+t[10]*i[6],0,t[0]*i[8]+t[4]*i[9]+t[8]*i[10],t[1]*i[8]+t[5]*i[9]+t[9]*i[10],t[2]*i[8]+t[6]*i[9]+t[10]*i[10],0,t[0]*i[12]+t[4]*i[13]+t[8]*i[14]+t[12],t[1]*i[12]+t[5]*i[13]+t[9]*i[14]+t[13],t[2]*i[12]+t[6]*i[13]+t[10]*i[14]+t[14],1]
},s.thenMove=function(t,i){return i[2]||(i[2]=0),[t[0],t[1],t[2],0,t[4],t[5],t[6],0,t[8],t[9],t[10],0,t[12]+i[0],t[13]+i[1],t[14]+i[2],1]},s.moveThen=function(t,i){t[2]||(t[2]=0);var e=t[0]*i[0]+t[1]*i[4]+t[2]*i[8],n=t[0]*i[1]+t[1]*i[5]+t[2]*i[9],o=t[0]*i[2]+t[1]*i[6]+t[2]*i[10];return s.thenMove(i,[e,n,o])},s.translate=function(t,i,e){return void 0===e&&(e=0),[1,0,0,0,0,1,0,0,0,0,1,0,t,i,e,1]},s.thenScale=function(t,i){return[i[0]*t[0],i[1]*t[1],i[2]*t[2],0,i[0]*t[4],i[1]*t[5],i[2]*t[6],0,i[0]*t[8],i[1]*t[9],i[2]*t[10],0,i[0]*t[12],i[1]*t[13],i[2]*t[14],1]},s.scale=function(t,i,e){return void 0===e&&(e=1),void 0===i&&(i=t),[t,0,0,0,0,i,0,0,0,0,e,0,0,0,0,1]},s.rotateX=function(t){var i=Math.cos(t),e=Math.sin(t);return[1,0,0,0,0,i,e,0,0,-e,i,0,0,0,0,1]},s.rotateY=function(t){var i=Math.cos(t),e=Math.sin(t);return[i,0,-e,0,0,1,0,0,e,0,i,0,0,0,0,1]},s.rotateZ=function(t){var i=Math.cos(t),e=Math.sin(t);return[i,e,0,0,-e,i,0,0,0,0,1,0,0,0,0,1]},s.rotate=function(t,i,e){var n=Math.cos(t),o=Math.sin(t),s=Math.cos(i),r=Math.sin(i),a=Math.cos(e),h=Math.sin(e),c=[s*a,n*h+o*r*a,o*h-n*r*a,0,-s*h,n*a-o*r*h,o*a+n*r*h,0,r,-o*s,n*s,0,0,0,0,1];return c},s.rotateAxis=function(t,i){var e=Math.sin(i),n=Math.cos(i),o=1-n,s=t[0]*t[0]*o,r=t[0]*t[1]*o,a=t[0]*t[2]*o,h=t[1]*t[1]*o,c=t[1]*t[2]*o,p=t[2]*t[2]*o,u=t[0]*e,l=t[1]*e,f=t[2]*e,d=[s+n,r+f,a-l,0,r-f,h+n,c+u,0,a+l,c-u,p+n,0,0,0,0,1];return d},s.aboutOrigin=function(t,i){var e=t[0]-(t[0]*i[0]+t[1]*i[4]+t[2]*i[8]),n=t[1]-(t[0]*i[1]+t[1]*i[5]+t[2]*i[9]),o=t[2]-(t[0]*i[2]+t[1]*i[6]+t[2]*i[10]);return s.thenMove(i,[e,n,o])},s.skew=function(t,i,e){return[1,Math.tan(i),0,0,Math.tan(e),1,0,0,0,Math.tan(t),1,0,0,0,0,1]},s.skewX=function(t){return[1,0,0,0,Math.tan(t),1,0,0,0,0,1,0,0,0,0,1]},s.skewY=function(t){return[1,Math.tan(t),0,0,0,1,0,0,0,0,1,0,0,0,0,1]},s.perspective=function(t){return[1,0,0,0,0,1,0,0,0,0,1,-1/t,0,0,0,1]},s.getTranslate=function(t){return[t[12],t[13],t[14]]},s.inverse=function(t){var i=t[5]*t[10]-t[6]*t[9],e=t[4]*t[10]-t[6]*t[8],n=t[4]*t[9]-t[5]*t[8],o=t[1]*t[10]-t[2]*t[9],s=t[0]*t[10]-t[2]*t[8],r=t[0]*t[9]-t[1]*t[8],a=t[1]*t[6]-t[2]*t[5],h=t[0]*t[6]-t[2]*t[4],c=t[0]*t[5]-t[1]*t[4],p=t[0]*i-t[1]*e+t[2]*n,u=1/p,l=[u*i,-u*o,u*a,0,-u*e,u*s,-u*h,0,u*n,-u*r,u*c,0,0,0,0,1];return l[12]=-t[12]*l[0]-t[13]*l[4]-t[14]*l[8],l[13]=-t[12]*l[1]-t[13]*l[5]-t[14]*l[9],l[14]=-t[12]*l[2]-t[13]*l[6]-t[14]*l[10],l},s.transpose=function(t){return[t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15]]},s.interpret=function(t){var i=[t[0],t[1],t[2]],r=o(i[0]),a=n(i),h=[i[0]+r*a,i[1],i[2]],c=2/e(h);if(c>=1/0)return{translate:s.getTranslate(t),rotate:[0,0,0],scale:[0,0,0],skew:[0,0,0]};var p=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1];p[0]=1-c*h[0]*h[0],p[5]=1-c*h[1]*h[1],p[10]=1-c*h[2]*h[2],p[1]=-c*h[0]*h[1],p[2]=-c*h[0]*h[2],p[6]=-c*h[1]*h[2],p[4]=p[1],p[8]=p[2],p[9]=p[6];var u=s.multiply(p,t),l=[u[5],u[6]],f=o(l[0]),d=n(l),_=[l[0]+f*d,l[1]],g=2/e(_),y=[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1];y[5]=1-g*_[0]*_[0],y[10]=1-g*_[1]*_[1],y[6]=-g*_[0]*_[1],y[9]=y[6];var v=s.multiply(y,p),m=s.multiply(v,t),O=s.scale(m[0]<0?-1:1,m[5]<0?-1:1,m[10]<0?-1:1);m=s.multiply(m,O),v=s.multiply(O,v);var S={};return S.translate=s.getTranslate(t),S.rotate=[Math.atan2(-v[6],v[10]),Math.asin(v[2]),Math.atan2(-v[1],v[0])],S.rotate[0]||(S.rotate[0]=0,S.rotate[2]=Math.atan2(v[4],v[5])),S.scale=[m[0],m[5],m[10]],S.skew=[Math.atan2(m[9],S.scale[2]),Math.atan2(m[8],S.scale[2]),Math.atan2(m[4],S.scale[0])],Math.abs(S.rotate[0])+Math.abs(S.rotate[2])>1.5*Math.PI&&(S.rotate[1]=Math.PI-S.rotate[1],S.rotate[1]>Math.PI&&(S.rotate[1]-=2*Math.PI),S.rotate[1]<-Math.PI&&(S.rotate[1]+=2*Math.PI),S.rotate[0]<0?S.rotate[0]+=Math.PI:S.rotate[0]-=Math.PI,S.rotate[2]<0?S.rotate[2]+=Math.PI:S.rotate[2]-=Math.PI),S},s.average=function(t,i,e){e=void 0===e?.5:e;for(var n=s.interpret(t),o=s.interpret(i),r={translate:[0,0,0],rotate:[0,0,0],scale:[0,0,0],skew:[0,0,0]},a=0;3>a;a++)r.translate[a]=(1-e)*n.translate[a]+e*o.translate[a],r.rotate[a]=(1-e)*n.rotate[a]+e*o.rotate[a],r.scale[a]=(1-e)*n.scale[a]+e*o.scale[a],r.skew[a]=(1-e)*n.skew[a]+e*o.skew[a];return s.build(r)},s.build=function(t){var i=s.scale(t.scale[0],t.scale[1],t.scale[2]),e=s.skew(t.skew[0],t.skew[1],t.skew[2]),n=s.rotate(t.rotate[0],t.rotate[1],t.rotate[2]);return s.thenMove(s.multiply(s.multiply(n,e),i),t.translate)},s.equals=function(t,i){return!s.notEquals(t,i)},s.notEquals=function(t,i){return t===i?!1:!(t&&i)||t[12]!==i[12]||t[13]!==i[13]||t[14]!==i[14]||t[0]!==i[0]||t[1]!==i[1]||t[2]!==i[2]||t[4]!==i[4]||t[5]!==i[5]||t[6]!==i[6]||t[8]!==i[8]||t[9]!==i[9]||t[10]!==i[10]},s.normalizeRotation=function(t){var i=t.slice(0);for((i[0]===.5*Math.PI||i[0]===.5*-Math.PI)&&(i[0]=-i[0],i[1]=Math.PI-i[1],i[2]-=Math.PI),i[0]>.5*Math.PI&&(i[0]=i[0]-Math.PI,i[1]=Math.PI-i[1],i[2]-=Math.PI),i[0]<.5*-Math.PI&&(i[0]=i[0]+Math.PI,i[1]=-Math.PI-i[1],i[2]-=Math.PI);i[1]<-Math.PI;)i[1]+=2*Math.PI;for(;i[1]>=Math.PI;)i[1]-=2*Math.PI;for(;i[2]<-Math.PI;)i[2]+=2*Math.PI;for(;i[2]>=Math.PI;)i[2]-=2*Math.PI;return i},s.inFront=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,.001,1],s.behind=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,-.001,1],i.exports=s},{}],16:[function(t,i){function e(t){this._node=new s,this._eventInput=new n,this._eventOutput=new n,n.setInputHandler(this,this._eventInput),n.setOutputHandler(this,this._eventOutput),this.options=r.clone(this.constructor.DEFAULT_OPTIONS||e.DEFAULT_OPTIONS),this._optionsManager=new o(this.options),t&&this.setOptions(t)}var n=t("./EventHandler"),o=t("./OptionsManager"),s=t("./RenderNode"),r=t("../utilities/Utility");e.DEFAULT_OPTIONS={},e.prototype.getOptions=function(t){return this._optionsManager.getOptions(t)},e.prototype.setOptions=function(t){this._optionsManager.patch(t)},e.prototype.add=function(){return this._node.add.apply(this._node,arguments)},e.prototype._add=e.prototype.add,e.prototype.render=function(){return this._node.render()},e.prototype.getSize=function(){return this._node&&this._node.getSize?this._node.getSize.apply(this._node,arguments)||this.options.size:this.options.size},i.exports=e},{"../utilities/Utility":95,"./EventHandler":7,"./OptionsManager":10,"./RenderNode":11}],17:[function(t,i){function e(t){t||(t=[]),t instanceof Array&&(t={array:t}),this._=null,this.index=t.index||0,t.array?this._=new this.constructor.Backing(t.array):t._&&(this._=t._),this.index===this._.firstIndex&&(this._.firstNode=this),this.index===this._.firstIndex+this._.array.length-1&&(this._.lastNode=this),void 0!==t.loop&&(this._.loop=t.loop),void 0!==t.trackSize&&(this._.trackSize=t.trackSize),this._previousNode=null,this._nextNode=null}e.Backing=function(t){this.array=t,this.firstIndex=0,this.loop=!1,this.firstNode=null,this.lastNode=null,this.cumulativeSizes=[[0,0]],this.sizeDirty=!0,this.trackSize=!1},e.Backing.prototype.getValue=function(t){var i=t-this.firstIndex;return 0>i||i>=this.array.length?null:this.array[i]},e.Backing.prototype.setValue=function(t,i){this.array[t-this.firstIndex]=i},e.Backing.prototype.getSize=function(t){return this.cumulativeSizes[t]},e.Backing.prototype.calculateSize=function(t){t=t||this.array.length;for(var i=[0,0],e=0;t>e;e++){var n=this.array[e].getSize();if(!n)return void 0;void 0!==i[0]&&(void 0===n[0]?i[0]=void 0:i[0]+=n[0]),void 0!==i[1]&&(void 0===n[1]?i[1]=void 0:i[1]+=n[1]),this.cumulativeSizes[e+1]=i.slice()}return this.sizeDirty=!1,i},e.Backing.prototype.reindex=function(t,i,e){if(this.array[0]){for(var n=0,o=this.firstIndex,s=e-i,r=this.firstNode;t-1>o;)r=r.getNext(),o++;var a=r;for(n=0;i>n;n++)r=r.getNext(),r&&(r._previousNode=a);var h=r?r.getNext():null;for(a._nextNode=null,r=a,n=0;e>n;n++)r=r.getNext();if(o+=e,r!==h&&(r._nextNode=h,h&&(h._previousNode=r)),h)for(r=h,o++;r&&o<this.array.length+this.firstIndex;)r._nextNode?r.index+=s:r.index=o,r=r.getNext(),o++;this.trackSize&&(this.sizeDirty=!0)}},e.prototype.getPrevious=function(){var t=this._.array.length;return t?this.index===this._.firstIndex?this._.loop?(this._previousNode=this._.lastNode||new this.constructor({_:this._,index:this._.firstIndex+t-1}),this._previousNode._nextNode=this):this._previousNode=null:this._previousNode||(this._previousNode=new this.constructor({_:this._,index:this.index-1}),this._previousNode._nextNode=this):this._previousNode=null,this._previousNode},e.prototype.getNext=function(){var t=this._.array.length;return t?this.index===this._.firstIndex+t-1?this._.loop?(this._nextNode=this._.firstNode||new this.constructor({_:this._,index:this._.firstIndex}),this._nextNode._previousNode=this):this._nextNode=null:this._nextNode||(this._nextNode=new this.constructor({_:this._,index:this.index+1}),this._nextNode._previousNode=this):this._nextNode=null,this._nextNode},e.prototype.indexOf=function(t){return this._.array.indexOf(t)},e.prototype.getIndex=function(){return this.index},e.prototype.toString=function(){return""+this.index},e.prototype.unshift=function(){this._.array.unshift.apply(this._.array,arguments),this._.firstIndex-=arguments.length,this._.trackSize&&(this._.sizeDirty=!0)},e.prototype.push=function(){this._.array.push.apply(this._.array,arguments),this._.trackSize&&(this._.sizeDirty=!0)},e.prototype.splice=function(t,i){var e=Array.prototype.slice.call(arguments,2);this._.array.splice.apply(this._.array,[t-this._.firstIndex,i].concat(e)),this._.reindex(t,i,e.length)},e.prototype.swap=function(t){var i=t.get(),e=this.get();this._.setValue(this.index,i),this._.setValue(t.index,e);var n=this._previousNode,o=this._nextNode,s=this.index,r=t._previousNode,a=t._nextNode,h=t.index;this.index=h,this._previousNode=r===this?t:r,this._previousNode&&(this._previousNode._nextNode=this),this._nextNode=a===this?t:a,this._nextNode&&(this._nextNode._previousNode=this),t.index=s,t._previousNode=n===t?this:n,t._previousNode&&(t._previousNode._nextNode=t),t._nextNode=o===t?this:o,t._nextNode&&(t._nextNode._previousNode=t),this.index===this._.firstIndex?this._.firstNode=this:this.index===this._.firstIndex+this._.array.length-1&&(this._.lastNode=this),t.index===this._.firstIndex?this._.firstNode=t:t.index===this._.firstIndex+this._.array.length-1&&(this._.lastNode=t),this._.trackSize&&(this._.sizeDirty=!0)},e.prototype.get=function(){return this._.getValue(this.index)},e.prototype.getSize=function(){var t=this.get();return t?t.getSize():null},e.prototype.render=function(){this._.trackSize&&this._.sizeDirty&&this._.calculateSize();var t=this.get();return t?t.render.apply(t,arguments):null},i.exports=e},{}],18:[function(t,i){i.exports={Context:t("./Context"),ElementAllocator:t("./ElementAllocator"),ElementOutput:t("./ElementOutput"),Engine:t("./Engine"),Entity:t("./Entity"),EventEmitter:t("./EventEmitter"),EventHandler:t("./EventHandler"),Group:t("./Group"),Modifier:t("./Modifier"),OptionsManager:t("./OptionsManager"),RenderNode:t("./RenderNode"),Scene:t("./Scene"),SpecParser:t("./SpecParser"),Surface:t("./Surface"),Transform:t("./Transform"),View:t("./View"),ViewSequence:t("./ViewSequence")}},{"./Context":1,"./ElementAllocator":2,"./ElementOutput":3,"./Engine":4,"./Entity":5,"./EventEmitter":6,"./EventHandler":7,"./Group":8,"./Modifier":9,"./OptionsManager":10,"./RenderNode":11,"./Scene":12,"./SpecParser":13,"./Surface":14,"./Transform":15,"./View":16,"./ViewSequence":17}],19:[function(t,i){function e(t){this.dispatchers={},this.currMode=void 0,this.setMode(t)}var n=t("../core/EventHandler");e.prototype.setMode=function(t){if(t!==this.currMode){var i=this.currMode;this.dispatchers[this.currMode]&&this.dispatchers[this.currMode].trigger("unpipe"),this.currMode=t,this.dispatchers[t]&&this.dispatchers[t].emit("pipe"),this.emit("change",{from:i,to:t})}},e.prototype.forMode=function(t){return this.dispatchers[t]||(this.dispatchers[t]=new n),this.dispatchers[t]},e.prototype.emit=function(t,i){if(void 0===this.currMode)return!1;i||(i={});var e=this.dispatchers[this.currMode];return e?e.trigger(t,i):void 0},i.exports=e},{"../core/EventHandler":7}],20:[function(t,i){function e(t){n.call(this),this._condition=t}var n=t("../core/EventHandler");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.emit=function(t,i){return this._condition(t,i)?n.prototype.emit.apply(this,arguments):void 0},e.prototype.trigger=e.prototype.emit,i.exports=e},{"../core/EventHandler":7}],21:[function(t,i){function e(t){n.call(this),this._mappingFunction=t}var n=t("../core/EventHandler");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.subscribe=null,e.prototype.unsubscribe=null,e.prototype.emit=function(t,i){var e=this._mappingFunction.apply(this,arguments);e&&e.emit instanceof Function&&e.emit(t,i)},e.prototype.trigger=e.prototype.emit,i.exports=e},{"../core/EventHandler":7}],22:[function(t,i){i.exports={EventArbiter:t("./EventArbiter"),EventFilter:t("./EventFilter"),EventMapper:t("./EventMapper")}},{"./EventArbiter":19,"./EventFilter":20,"./EventMapper":21}],23:[function(t,i){i.exports={core:t("./core"),events:t("./events"),inputs:t("./inputs"),math:t("./math"),modifiers:t("./modifiers"),physics:t("./physics"),surfaces:t("./surfaces"),transitions:t("./transitions"),utilities:t("./utilities"),views:t("./views"),widgets:t("./widgets")}},{"./core":18,"./events":22,"./inputs":36,"./math":42,"./modifiers":47,"./physics":71,"./surfaces":82,"./transitions":92,"./utilities":96,"./views":112,"./widgets":117}],24:[function(t,i){function e(t,i){void 0===i&&(i="update"),this._state=t&&t.get&&t.set?t:new s(t||0),this._eventInput=new o,o.setInputHandler(this,this._eventInput),this._eventInput.on(i,n.bind(this))}function n(t){var i=t.delta,e=this.get();if(i.constructor===e.constructor){var n=i instanceof Array?[e[0]+i[0],e[1]+i[1]]:e+i;this.set(n)}}var o=t("../core/EventHandler"),s=t("../transitions/Transitionable");e.prototype.get=function(){return this._state.get()},e.prototype.set=function(t){this._state.set(t)},i.exports=e},{"../core/EventHandler":7,"../transitions/Transitionable":88}],25:[function(){function t(t){window.addEventListener(t,function(t){return t.stopPropagation(),!1},!0)}var i="ontouchstart"in window;i&&(t("mousedown"),t("mousemove"),t("mouseup"),t("mouseleave"))},{}],26:[function(){!function(){if(window.CustomEvent){var t=300,i=500,e={},n={},o=Date.now;window.addEventListener("touchstart",function(t){for(var i=o(),n=0;n<t.changedTouches.length;n++){var s=t.changedTouches[n];e[s.identifier]=i}}),window.addEventListener("touchmove",function(t){for(var i=0;i<t.changedTouches.length;i++){var n=t.changedTouches[i];delete e[n.identifier]}}),window.addEventListener("touchend",function(i){for(var s=o(),r=0;r<i.changedTouches.length;r++){var a=i.changedTouches[r],h=e[a.identifier];if(h&&t>s-h){var c=new window.CustomEvent("click",{bubbles:!0,detail:a});n[s]=i,i.target.dispatchEvent(c)}delete e[a.identifier]}}),window.addEventListener("click",function(t){var e=o();for(var s in n){var r=n[s];i>e-s?t instanceof window.MouseEvent&&t.target===r.target&&t.stopPropagation():delete n[s]}},!0)}}()},{}],27:[function(t,i){function e(t,i){this._eventInput=new o,this._eventOutput=new o,o.setInputHandler(this,this._eventInput),o.setOutputHandler(this,this._eventOutput),this._syncs={},t&&this.addSync(t),i&&this.setOptions(i)}function n(t,i){s[t]&&(this._syncs[t]=new s[t](i),this.pipeSync(t))}var o=t("../core/EventHandler");e.DIRECTION_X=0,e.DIRECTION_Y=1,e.DIRECTION_Z=2;var s={};e.register=function(t){for(var i in t)if(s[i]){if(s[i]!==t[i])throw new Error("Conflicting sync classes for key: "+i)}else s[i]=t[i]},e.prototype.setOptions=function(t){for(var i in this._syncs)this._syncs[i].setOptions(t)},e.prototype.pipeSync=function(t){var i=this._syncs[t];this._eventInput.pipe(i),i.pipe(this._eventOutput)},e.prototype.unpipeSync=function(t){var i=this._syncs[t];this._eventInput.unpipe(i),i.unpipe(this._eventOutput)},e.prototype.addSync=function(t){if(t instanceof Array)for(var i=0;i<t.length;i++)n.call(this,t[i]);else if(t instanceof Object)for(var e in t)n.call(this,e,t[e])},i.exports=e},{"../core/EventHandler":7}],28:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new h(this.options),t&&this.setOptions(t),this._eventInput=new a,this._eventOutput=new a,a.setInputHandler(this,this._eventInput),a.setOutputHandler(this,this._eventOutput),this._eventInput.on("mousedown",n.bind(this)),this._eventInput.on("mousemove",o.bind(this)),this._eventInput.on("mouseup",s.bind(this)),this.options.propogate?this._eventInput.on("mouseleave",r.bind(this)):this._eventInput.on("mouseleave",s.bind(this)),this.options.clickThreshold&&window.addEventListener("click",function(t){Math.sqrt(Math.pow(this._displacement[0],2)+Math.pow(this._displacement[1],2))>this.options.clickThreshold&&t.stopPropagation()}.bind(this),!0),this._payload={delta:null,position:null,velocity:null,clientX:0,clientY:0,offsetX:0,offsetY:0},this._positionHistory=[],this._position=null,this._prevCoord=void 0,this._prevTime=void 0,this._down=!1,this._moved=!1,this._displacement=[0,0],this._documentActive=!1}function n(t){var i,e;this.options.preventDefault&&t.preventDefault();var n=t.clientX,o=t.clientY;this._prevCoord=[n,o],this._prevTime=Date.now(),this._down=!0,this._move=!1,void 0!==this.options.direction?(this._position=0,i=0,e=0):(this._position=[0,0],i=[0,0],e=[0,0]),this.options.clickThreshold&&(this._displacement=[0,0]);var s=this._payload;s.delta=i,s.position=this._position,s.velocity=e,s.clientX=n,s.clientY=o,s.offsetX=t.offsetX,s.offsetY=t.offsetY,this._positionHistory.push({position:s.position.slice?s.position.slice(0):s.position,time:this._prevTime}),this._eventOutput.emit("start",s),this._documentActive=!1}function o(t){if(this._prevCoord){var i=this._prevCoord;this._prevTime;var n=t.clientX,o=t.clientY,s=Date.now(),r=n-i[0],a=o-i[1];this.options.rails&&(Math.abs(r)>Math.abs(a)?a=0:r=0);var h,p,u=Math.max(s-this._positionHistory[0].time,c),l=this.options.scale;this.options.direction===e.DIRECTION_X?(p=l*r,this._position+=p,h=l*(this._position-this._positionHistory[0].position)/u):this.options.direction===e.DIRECTION_Y?(p=l*a,this._position+=p,h=l*(this._position-this._positionHistory[0].position)/u):(p=[l*r,l*a],h=[l*(this._position[0]-this._positionHistory[0].position[0])/u,l*(this._position[1]-this._positionHistory[0].position[1])/u],this._position[0]+=p[0],this._position[1]+=p[1]),this.options.clickThreshold!==!1&&(this._displacement[0]+=r,this._displacement[1]+=a);var f=this._payload;f.delta=p,f.position=this._position,f.velocity=h,f.clientX=n,f.clientY=o,f.offsetX=t.offsetX,f.offsetY=t.offsetY,this._positionHistory.length===this.options.velocitySampleLength&&this._positionHistory.shift(),this._positionHistory.push({position:f.position.slice?f.position.slice(0):f.position,time:s}),this._eventOutput.emit("update",f),this._prevCoord=[n,o],this._prevTime=s,this._move=!0}}function s(){this._down&&(this._eventOutput.emit("end",this._payload),this._prevCoord=void 0,this._prevTime=void 0,this._down=!1,this._move=!1,this._positionHistory=[])}function r(t){if(this._down&&this._move&&!this._documentActive){var i=o.bind(this),e=function(t){s.call(this,t),document.removeEventListener("mousemove",i),document.removeEventListener("mouseup",e)}.bind(this,t);document.addEventListener("mousemove",i),document.addEventListener("mouseup",e),this._documentActive=!0}}var a=t("../core/EventHandler"),h=t("../core/OptionsManager");e.DEFAULT_OPTIONS={clickThreshold:void 0,direction:void 0,rails:!1,scale:1,propogate:!0,velocitySampleLength:10,preventDefault:!0},e.DIRECTION_X=0,e.DIRECTION_Y=1;var c=8;e.prototype.getOptions=function(){return this.options},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},i.exports=e},{"../core/EventHandler":7,"../core/OptionsManager":10}],29:[function(t,i){function e(t){n.call(this),this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new o(this.options),t&&this.setOptions(t),this._displacement=0,this._previousDistance=0}var n=t("./TwoFingerSync"),o=t("../core/OptionsManager");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={scale:1},e.prototype._startUpdate=function(t){this._previousDistance=n.calculateDistance(this.posA,this.posB),this._displacement=0,this._eventOutput.emit("start",{count:t.touches.length,touches:[this.touchAId,this.touchBId],distance:this._dist,center:n.calculateCenter(this.posA,this.posB)})},e.prototype._moveUpdate=function(t){var i=n.calculateDistance(this.posA,this.posB),e=n.calculateCenter(this.posA,this.posB),o=this.options.scale,s=o*(i-this._previousDistance),r=s/t;this._previousDistance=i,this._displacement+=s,this._eventOutput.emit("update",{delta:s,velocity:r,distance:i,displacement:this._displacement,center:e,touches:[this.touchAId,this.touchBId]})},e.prototype.getOptions=function(){return this.options},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},i.exports=e},{"../core/OptionsManager":10,"./TwoFingerSync":35}],30:[function(t,i){function e(t){n.call(this),this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new o(this.options),t&&this.setOptions(t),this._angle=0,this._previousAngle=0}var n=t("./TwoFingerSync"),o=t("../core/OptionsManager");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={scale:1},e.prototype._startUpdate=function(t){this._angle=0,this._previousAngle=n.calculateAngle(this.posA,this.posB);var i=n.calculateCenter(this.posA,this.posB);this._eventOutput.emit("start",{count:t.touches.length,angle:this._angle,center:i,touches:[this.touchAId,this.touchBId]})},e.prototype._moveUpdate=function(t){var i=this.options.scale,e=n.calculateAngle(this.posA,this.posB),o=n.calculateCenter(this.posA,this.posB),s=i*(e-this._previousAngle),r=s/t;this._angle+=s,this._eventOutput.emit("update",{delta:s,velocity:r,angle:this._angle,center:o,touches:[this.touchAId,this.touchBId]}),this._previousAngle=e},e.prototype.getOptions=function(){return this.options},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},i.exports=e},{"../core/OptionsManager":10,"./TwoFingerSync":35}],31:[function(t,i){function e(t){o.call(this),this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new s(this.options),t&&this.setOptions(t),this._scaleFactor=1,this._startDist=0,this._eventInput.on("pipe",n.bind(this))}function n(){this.touchAId=void 0,this.touchBId=void 0}var o=t("./TwoFingerSync"),s=t("../core/OptionsManager");e.prototype=Object.create(o.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={scale:1},e.prototype._startUpdate=function(t){this._scaleFactor=1,this._startDist=o.calculateDistance(this.posA,this.posB),this._eventOutput.emit("start",{count:t.touches.length,touches:[this.touchAId,this.touchBId],distance:this._startDist,center:o.calculateCenter(this.posA,this.posB)})},e.prototype._moveUpdate=function(t){var i=this.options.scale,e=o.calculateDistance(this.posA,this.posB),n=o.calculateCenter(this.posA,this.posB),s=(e-this._startDist)/this._startDist,r=Math.max(1+i*s,0),a=(r-this._scaleFactor)/t;this._eventOutput.emit("update",{delta:s,scale:r,velocity:a,distance:e,center:n,touches:[this.touchAId,this.touchBId]}),this._scaleFactor=r},e.prototype.getOptions=function(){return this.options},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},i.exports=e},{"../core/OptionsManager":10,"./TwoFingerSync":35}],32:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new a(this.options),t&&this.setOptions(t),this._payload={delta:null,position:null,velocity:null,slip:!0},this._eventInput=new s,this._eventOutput=new s,s.setInputHandler(this,this._eventInput),s.setOutputHandler(this,this._eventOutput),this._position=void 0===this.options.direction?[0,0]:0,this._prevTime=void 0,this._prevVel=void 0,this._eventInput.on("mousewheel",o.bind(this)),this._eventInput.on("wheel",o.bind(this)),this._inProgress=!1,this._loopBound=!1}function n(){if(this._inProgress&&c()-this._prevTime>this.options.stallTime){this._inProgress=!1;var t=Math.abs(this._prevVel)>=this.options.minimumEndSpeed?this._prevVel:0,i=this._payload;i.position=this._position,i.velocity=t,i.slip=!0,this._eventOutput.emit("end",i)}}function o(t){this.options.preventDefault&&t.preventDefault(),this._inProgress||(this._inProgress=!0,this._position=void 0===this.options.direction?[0,0]:0,g=this._payload,g.slip=!0,g.position=this._position,g.clientX=t.clientX,g.clientY=t.clientY,g.offsetX=t.offsetX,g.offsetY=t.offsetY,this._eventOutput.emit("start",g),this._loopBound||(r.on("prerender",n.bind(this)),this._loopBound=!0));var i=c(),o=this._prevTime||i,s=void 0!==t.wheelDeltaX?t.wheelDeltaX:-t.deltaX,a=void 0!==t.wheelDeltaY?t.wheelDeltaY:-t.deltaY;1===t.deltaMode&&(s*=this.options.lineHeight,a*=this.options.lineHeight),this.options.rails&&(Math.abs(s)>Math.abs(a)?a=0:s=0);var p,u,l=Math.max(i-o,h),f=s/l,d=a/l,_=this.options.scale;this.options.direction===e.DIRECTION_X?(u=_*s,p=_*f,this._position+=u):this.options.direction===e.DIRECTION_Y?(u=_*a,p=_*d,this._position+=u):(u=[_*s,_*a],p=[_*f,_*d],this._position[0]+=u[0],this._position[1]+=u[1]);var g=this._payload;g.delta=u,g.velocity=p,g.position=this._position,g.slip=!0,this._eventOutput.emit("update",g),this._prevTime=i,this._prevVel=p}var s=t("../core/EventHandler"),r=t("../core/Engine"),a=t("../core/OptionsManager");e.DEFAULT_OPTIONS={direction:void 0,minimumEndSpeed:1/0,rails:!1,scale:1,stallTime:50,lineHeight:40,preventDefault:!0},e.DIRECTION_X=0,e.DIRECTION_Y=1;var h=8,c=Date.now;e.prototype.getOptions=function(){return this.options},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},i.exports=e},{"../core/Engine":4,"../core/EventHandler":7,"../core/OptionsManager":10}],33:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new h(this.options),t&&this.setOptions(t),this._eventOutput=new a,this._touchTracker=new r({touchLimit:this.options.touchLimit}),a.setOutputHandler(this,this._eventOutput),a.setInputHandler(this,this._touchTracker),this._touchTracker.on("trackstart",n.bind(this)),this._touchTracker.on("trackmove",o.bind(this)),this._touchTracker.on("trackend",s.bind(this)),this._payload={delta:null,position:null,velocity:null,clientX:void 0,clientY:void 0,count:0,touch:void 0},this._position=null}function n(t){var i,e;void 0!==this.options.direction?(this._position=0,i=0,e=0):(this._position=[0,0],i=[0,0],e=[0,0]);var n=this._payload;n.delta=e,n.position=this._position,n.velocity=i,n.clientX=t.x,n.clientY=t.y,n.count=t.count,n.touch=t.identifier,this._eventOutput.emit("start",n)}function o(t){var i=t.history,n=i[i.length-1],o=i[i.length-2],s=i[i.length-this.options.velocitySampleLength]?i[i.length-this.options.velocitySampleLength]:i[i.length-2],r=s.timestamp,a=n.timestamp,h=n.x-o.x,p=n.y-o.y,u=n.x-s.x,l=n.y-s.y;this.options.rails&&(Math.abs(h)>Math.abs(p)?p=0:h=0,Math.abs(u)>Math.abs(l)?l=0:u=0);var f,d,_=Math.max(a-r,c),g=u/_,y=l/_,v=this.options.scale;this.options.direction===e.DIRECTION_X?(d=v*h,f=v*g,this._position+=d):this.options.direction===e.DIRECTION_Y?(d=v*p,f=v*y,this._position+=d):(d=[v*h,v*p],f=[v*g,v*y],this._position[0]+=d[0],this._position[1]+=d[1]);var m=this._payload;m.delta=d,m.velocity=f,m.position=this._position,m.clientX=t.x,m.clientY=t.y,m.count=t.count,m.touch=t.identifier,this._eventOutput.emit("update",m)}function s(t){this._payload.count=t.count,this._eventOutput.emit("end",this._payload)}var r=t("./TouchTracker"),a=t("../core/EventHandler"),h=t("../core/OptionsManager");e.DEFAULT_OPTIONS={direction:void 0,rails:!1,touchLimit:1,velocitySampleLength:10,scale:1},e.DIRECTION_X=0,e.DIRECTION_Y=1;var c=8;e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},e.prototype.getOptions=function(){return this.options},i.exports=e},{"../core/EventHandler":7,"../core/OptionsManager":10,"./TouchTracker":34}],34:[function(t,i){function e(t,i,e){return{x:t.clientX,y:t.clientY,identifier:t.identifier,origin:i.origin,timestamp:c(),count:i.touches.length,history:e}}function n(t){if(!(t.touches.length>this.touchLimit)){this.isTouched=!0;for(var i=0;i<t.changedTouches.length;i++){var n=t.changedTouches[i],o=e(n,t,null);this.eventOutput.emit("trackstart",o),this.selective||this.touchHistory[n.identifier]||this.track(o)}}}function o(t){if(!(t.touches.length>this.touchLimit))for(var i=0;i<t.changedTouches.length;i++){var n=t.changedTouches[i],o=this.touchHistory[n.identifier];if(o){var s=e(n,t,o);this.touchHistory[n.identifier].push(s),this.eventOutput.emit("trackmove",s)}}}function s(t){if(this.isTouched){for(var i=0;i<t.changedTouches.length;i++){var n=t.changedTouches[i],o=this.touchHistory[n.identifier];if(o){var s=e(n,t,o);this.eventOutput.emit("trackend",s),delete this.touchHistory[n.identifier]}}this.isTouched=!1}}function r(){for(var t in this.touchHistory){var i=this.touchHistory[t];this.eventOutput.emit("trackend",{touch:i[i.length-1].touch,timestamp:Date.now(),count:0,history:i}),delete this.touchHistory[t]}}function a(t){this.selective=t.selective,this.touchLimit=t.touchLimit||1,this.touchHistory={},this.eventInput=new h,this.eventOutput=new h,h.setInputHandler(this,this.eventInput),h.setOutputHandler(this,this.eventOutput),this.eventInput.on("touchstart",n.bind(this)),this.eventInput.on("touchmove",o.bind(this)),this.eventInput.on("touchend",s.bind(this)),this.eventInput.on("touchcancel",s.bind(this)),this.eventInput.on("unpipe",r.bind(this)),this.isTouched=!1}var h=t("../core/EventHandler"),c=Date.now;a.prototype.track=function(t){this.touchHistory[t.identifier]=[t]},i.exports=a},{"../core/EventHandler":7}],35:[function(t,i){function e(){this._eventInput=new n,this._eventOutput=new n,n.setInputHandler(this,this._eventInput),n.setOutputHandler(this,this._eventOutput),this.touchAEnabled=!1,this.touchAId=0,this.posA=null,this.timestampA=0,this.touchBEnabled=!1,this.touchBId=0,this.posB=null,this.timestampB=0,this._eventInput.on("touchstart",this.handleStart.bind(this)),this._eventInput.on("touchmove",this.handleMove.bind(this)),this._eventInput.on("touchend",this.handleEnd.bind(this)),this._eventInput.on("touchcancel",this.handleEnd.bind(this))}var n=t("../core/EventHandler");e.calculateAngle=function(t,i){var e=i[0]-t[0],n=i[1]-t[1];return Math.atan2(n,e)},e.calculateDistance=function(t,i){var e=i[0]-t[0],n=i[1]-t[1];return Math.sqrt(e*e+n*n)},e.calculateCenter=function(t,i){return[(t[0]+i[0])/2,(t[1]+i[1])/2]};var o=Date.now;e.prototype.handleStart=function(t){for(var i=0;i<t.changedTouches.length;i++){var e=t.changedTouches[i];this.touchAEnabled?this.touchBEnabled||(this.touchBId=e.identifier,this.touchBEnabled=!0,this.posB=[e.pageX,e.pageY],this.timestampB=o(),this._startUpdate(t)):(this.touchAId=e.identifier,this.touchAEnabled=!0,this.posA=[e.pageX,e.pageY],this.timestampA=o())}},e.prototype.handleMove=function(t){if(this.touchAEnabled&&this.touchBEnabled){for(var i,e=this.timestampA,n=this.timestampB,s=0;s<t.changedTouches.length;s++){var r=t.changedTouches[s];r.identifier===this.touchAId?(this.posA=[r.pageX,r.pageY],this.timestampA=o(),i=this.timestampA-e):r.identifier===this.touchBId&&(this.posB=[r.pageX,r.pageY],this.timestampB=o(),i=this.timestampB-n)}i&&this._moveUpdate(i)}},e.prototype.handleEnd=function(t){for(var i=0;i<t.changedTouches.length;i++){var e=t.changedTouches[i];(e.identifier===this.touchAId||e.identifier===this.touchBId)&&(this.touchAEnabled&&this.touchBEnabled&&this._eventOutput.emit("end",{touches:[this.touchAId,this.touchBId],angle:this._angle}),this.touchAEnabled=!1,this.touchAId=0,this.touchBEnabled=!1,this.touchBId=0)}},i.exports=e},{"../core/EventHandler":7}],36:[function(t,i){i.exports={Accumulator:t("./Accumulator"),DesktopEmulationMode:t("./DesktopEmulationMode"),FastClick:t("./FastClick"),GenericSync:t("./GenericSync"),MouseSync:t("./MouseSync"),PinchSync:t("./PinchSync"),RotateSync:t("./RotateSync"),ScaleSync:t("./ScaleSync"),ScrollSync:t("./ScrollSync"),TouchSync:t("./TouchSync"),TouchTracker:t("./TouchTracker"),TwoFingerSync:t("./TwoFingerSync")}
},{"./Accumulator":24,"./DesktopEmulationMode":25,"./FastClick":26,"./GenericSync":27,"./MouseSync":28,"./PinchSync":29,"./RotateSync":30,"./ScaleSync":31,"./ScrollSync":32,"./TouchSync":33,"./TouchTracker":34,"./TwoFingerSync":35}],37:[function(t,i){function e(t){return this.values=t||[[1,0,0],[0,1,0],[0,0,1]],this}var n=t("./Vector"),o=new e,s=new n;e.prototype.get=function(){return this.values},e.prototype.set=function(t){this.values=t},e.prototype.vectorMultiply=function(t){var i=this.get(),e=t.x,n=t.y,o=t.z,r=i[0],a=i[1],h=i[2],c=r[0],p=r[1],u=r[2],l=a[0],f=a[1],d=a[2],_=h[0],g=h[1],y=h[2];return s.setXYZ(c*e+p*n+u*o,l*e+f*n+d*o,_*e+g*n+y*o)},e.prototype.multiply=function(t){for(var i=this.get(),e=[[]],n=0;3>n;n++){e[n]=[];for(var s=0;3>s;s++){for(var r=0,a=0;3>a;a++)r+=i[n][a]*t[a][s];e[n][s]=r}}return o.set(e)},e.prototype.transpose=function(){for(var t=[[],[],[]],i=this.get(),e=0;3>e;e++)for(var n=0;3>n;n++)t[e][n]=i[n][e];return o.set(t)},e.prototype.clone=function(){for(var t=this.get(),i=[],n=0;3>n;n++)i[n]=t[n].slice();return new e(i)},i.exports=e},{"./Vector":41}],38:[function(t,i){function e(t,i,e,n){return 1===arguments.length?this.set(t):(this.w=void 0!==t?t:1,this.x=void 0!==i?i:0,this.y=void 0!==e?e:0,this.z=void 0!==n?n:0),this}var n=t("./Matrix"),o=new e(1,0,0,0);e.prototype.add=function(t){return o.setWXYZ(this.w+t.w,this.x+t.x,this.y+t.y,this.z+t.z)},e.prototype.sub=function(t){return o.setWXYZ(this.w-t.w,this.x-t.x,this.y-t.y,this.z-t.z)},e.prototype.scalarDivide=function(t){return this.scalarMultiply(1/t)},e.prototype.scalarMultiply=function(t){return o.setWXYZ(this.w*t,this.x*t,this.y*t,this.z*t)},e.prototype.multiply=function(t){var i=this.x,e=this.y,n=this.z,s=this.w,r=t.x,a=t.y,h=t.z,c=t.w||0;return o.setWXYZ(s*c-i*r-e*a-n*h,i*c+r*s+a*n-e*h,e*c+a*s+i*h-r*n,n*c+h*s+r*e-i*a)};var s=new e(1,0,0,0);e.prototype.rotateVector=function(t){return s.set(this.conj()),o.set(this.multiply(t).multiply(s))},e.prototype.inverse=function(){return o.set(this.conj().scalarDivide(this.normSquared()))},e.prototype.negate=function(){return this.scalarMultiply(-1)},e.prototype.conj=function(){return o.setWXYZ(this.w,-this.x,-this.y,-this.z)},e.prototype.normalize=function(t){return t=void 0===t?1:t,this.scalarDivide(t*this.norm())},e.prototype.makeFromAngleAndAxis=function(t,i){var e=i.normalize(),n=.5*t,o=-Math.sin(n);return this.x=o*e.x,this.y=o*e.y,this.z=o*e.z,this.w=Math.cos(n),this},e.prototype.setWXYZ=function(t,i,e,n){return o.clear(),this.w=t,this.x=i,this.y=e,this.z=n,this},e.prototype.set=function(t){return t instanceof Array?(this.w=0,this.x=t[0],this.y=t[1],this.z=t[2]):(this.w=t.w,this.x=t.x,this.y=t.y,this.z=t.z),this!==o&&o.clear(),this},e.prototype.put=function(t){t.set(o)},e.prototype.clone=function(){return new e(this)},e.prototype.clear=function(){return this.w=1,this.x=0,this.y=0,this.z=0,this},e.prototype.isEqual=function(t){return t.w===this.w&&t.x===this.x&&t.y===this.y&&t.z===this.z},e.prototype.dot=function(t){return this.w*t.w+this.x*t.x+this.y*t.y+this.z*t.z},e.prototype.normSquared=function(){return this.dot(this)},e.prototype.norm=function(){return Math.sqrt(this.normSquared())},e.prototype.isZero=function(){return!(this.x||this.y||this.z)},e.prototype.getTransform=function(){var t=this.normalize(1),i=t.x,e=t.y,n=t.z,o=t.w;return[1-2*e*e-2*n*n,2*i*e-2*n*o,2*i*n+2*e*o,0,2*i*e+2*n*o,1-2*i*i-2*n*n,2*e*n-2*i*o,0,2*i*n-2*e*o,2*e*n+2*i*o,1-2*i*i-2*e*e,0,0,0,0,1]};var r=new n;e.prototype.getMatrix=function(){var t=this.normalize(1),i=t.x,e=t.y,n=t.z,o=t.w;return r.set([[1-2*e*e-2*n*n,2*i*e+2*n*o,2*i*n-2*e*o],[2*i*e-2*n*o,1-2*i*i-2*n*n,2*e*n+2*i*o],[2*i*n+2*e*o,2*e*n-2*i*o,1-2*i*i-2*e*e]])};var a=1e-5;e.prototype.slerp=function(t,i){var e,n,s,r,h;return n=this.dot(t),1-n>a?(e=Math.acos(n),s=Math.sin(e),r=Math.sin((1-i)*e)/s,h=Math.sin(i*e)/s):(r=1-i,h=i),o.set(this.scalarMultiply(r/h).add(t).scalarMultiply(h))},i.exports=e},{"./Matrix":37}],39:[function(t,i){function e(t,i){return t+s()*(i-t)}function n(t,i){return t+(s()*(i-t+1)>>0)}function o(t,i,e,n){if(i=void 0!==i?i:0,e=void 0!==e?e:1,void 0!==n){for(var o=[],s=0;n>s;s++)o.push(t(i,e));return o}return t(i,e)}var s=Math.random,r={};r.integer=function(t,i,e){return o(n,t,i,e)},r.range=function(t,i,n){return o(e,t,i,n)},r.sign=function(t){return r.bool(t)?1:-1},r.bool=function(t){return t=void 0!==t?t:.5,s()<t},i.exports=r},{}],40:[function(t,i){var e={};e.clamp=function(t,i){return Math.max(Math.min(t,i[1]),i[0])},e.length=function(t){for(var i=0,e=0;e<t.length;e++)i+=t[e]*t[e];return Math.sqrt(i)},i.exports=e},{}],41:[function(t,i){function e(t,i,e){return 1===arguments.length&&void 0!==t?this.set(t):(this.x=t||0,this.y=i||0,this.z=e||0),this}function n(t,i,e){return this.x=t,this.y=i,this.z=e,this}function o(t){return n.call(this,t[0],t[1],t[2]||0)}function s(t){return n.call(this,t.x,t.y,t.z)}function r(t){return n.call(this,t,0,0)}var a=new e(0,0,0);e.prototype.add=function(t){return n.call(a,this.x+t.x,this.y+t.y,this.z+t.z)},e.prototype.sub=function(t){return n.call(a,this.x-t.x,this.y-t.y,this.z-t.z)},e.prototype.mult=function(t){return n.call(a,t*this.x,t*this.y,t*this.z)},e.prototype.div=function(t){return this.mult(1/t)},e.prototype.cross=function(t){var i=this.x,e=this.y,o=this.z,s=t.x,r=t.y,h=t.z;return n.call(a,o*r-e*h,i*h-o*s,e*s-i*r)},e.prototype.equals=function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z},e.prototype.rotateX=function(t){var i=this.x,e=this.y,o=this.z,s=Math.cos(t),r=Math.sin(t);return n.call(a,i,e*s-o*r,e*r+o*s)},e.prototype.rotateY=function(t){var i=this.x,e=this.y,o=this.z,s=Math.cos(t),r=Math.sin(t);return n.call(a,o*r+i*s,e,o*s-i*r)},e.prototype.rotateZ=function(t){var i=this.x,e=this.y,o=this.z,s=Math.cos(t),r=Math.sin(t);return n.call(a,i*s-e*r,i*r+e*s,o)},e.prototype.dot=function(t){return this.x*t.x+this.y*t.y+this.z*t.z},e.prototype.normSquared=function(){return this.dot(this)},e.prototype.norm=function(){return Math.sqrt(this.normSquared())},e.prototype.normalize=function(t){0===arguments.length&&(t=1);var i=this.norm();return i>1e-7?s.call(a,this.mult(t/i)):n.call(a,t,0,0)},e.prototype.clone=function(){return new e(this)},e.prototype.isZero=function(){return!(this.x||this.y||this.z)},e.prototype.set=function(t){return t instanceof Array?o.call(this,t):"number"==typeof t?r.call(this,t):s.call(this,t)},e.prototype.setXYZ=function(){return n.apply(this,arguments)},e.prototype.set1D=function(t){return r.call(this,t)},e.prototype.put=function(t){this===a?s.call(t,a):s.call(t,this)},e.prototype.clear=function(){return n.call(this,0,0,0)},e.prototype.cap=function h(h){if(1/0===h)return s.call(a,this);var t=this.norm();return t>h?s.call(a,this.mult(h/t)):s.call(a,this)},e.prototype.project=function(t){return t.mult(this.dot(t))},e.prototype.reflectAcross=function(t){return t.normalize().put(t),s(a,this.sub(this.project(t).mult(2)))},e.prototype.get=function(){return[this.x,this.y,this.z]},e.prototype.get1D=function(){return this.x},i.exports=e},{}],42:[function(t,i){i.exports={Matrix:t("./Matrix"),Quaternion:t("./Quaternion"),Random:t("./Random"),Utilities:t("./Utilities"),Vector:t("./Vector")}},{"./Matrix":37,"./Quaternion":38,"./Random":39,"./Utilities":40,"./Vector":41}],43:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t),this._positionState=new c([0,0]),this._differential=[0,0],this._active=!0,this.sync=new l(["mouse","touch"],{scale:this.options.scale}),this.eventOutput=new p,p.setInputHandler(this,this.sync),p.setOutputHandler(this,this.eventOutput),a.call(this)}function n(t){var i=this.options,e=i.projection,n=i.snapX,o=i.snapY,s=e&_.x?t[0]:0,r=e&_.y?t[1]:0;return n>0&&(s-=s%n),o>0&&(r-=r%o),[s,r]}function o(){this._active&&(this._positionState.isActive()&&this._positionState.halt(),this.eventOutput.emit("start",{position:this.getPosition()}))}function s(t){if(this._active){var i=this.options;this._differential=t.position;var e=n.call(this,this._differential);this._differential[0]-=e[0],this._differential[1]-=e[1];var o=this.getPosition();if(o[0]+=e[0],o[1]+=e[1],i.xRange){var s=[i.xRange[0]+.5*i.snapX,i.xRange[1]-.5*i.snapX];o[0]=g(o[0],s)}if(i.yRange){var r=[i.yRange[0]+.5*i.snapY,i.yRange[1]-.5*i.snapY];o[1]=g(o[1],r)}this.eventOutput.emit("update",{position:o})}}function r(){this._active&&this.eventOutput.emit("end",{position:this.getPosition()})}function a(){this.sync.on("start",o.bind(this)),this.sync.on("update",s.bind(this)),this.sync.on("end",r.bind(this))}var h=t("../core/Transform"),c=t("../transitions/Transitionable"),p=t("../core/EventHandler"),u=t("../math/Utilities"),l=t("../inputs/GenericSync"),f=t("../inputs/MouseSync"),d=t("../inputs/TouchSync");l.register({mouse:f,touch:d});var _={x:1,y:2};e.DIRECTION_X=_.x,e.DIRECTION_Y=_.y;var g=u.clamp;e.DEFAULT_OPTIONS={projection:_.x|_.y,scale:1,xRange:null,yRange:null,snapX:0,snapY:0,transition:{duration:0}},e.prototype.setOptions=function(t){var i=this.options;if(void 0!==t.projection){var e=t.projection;this.options.projection=0,["x","y"].forEach(function(t){-1!==e.indexOf(t)&&(i.projection|=_[t])})}void 0!==t.scale&&(i.scale=t.scale,this.sync.setOptions({scale:t.scale})),void 0!==t.xRange&&(i.xRange=t.xRange),void 0!==t.yRange&&(i.yRange=t.yRange),void 0!==t.snapX&&(i.snapX=t.snapX),void 0!==t.snapY&&(i.snapY=t.snapY)},e.prototype.getPosition=function(){return this._positionState.get()},e.prototype.setRelativePosition=function(t,i,e){var n=this.getPosition(),o=[n[0]+t[0],n[1]+t[1]];this.setPosition(o,i,e)},e.prototype.setPosition=function(t,i,e){this._positionState.isActive()&&this._positionState.halt(),this._positionState.set(t,i,e)},e.prototype.activate=function(){this._active=!0},e.prototype.deactivate=function(){this._active=!1},e.prototype.toggle=function(){this._active=!this._active},e.prototype.modify=function(t){var i=this.getPosition();return{transform:h.translate(i[0],i[1]),target:t}},i.exports=e},{"../core/EventHandler":7,"../core/Transform":15,"../inputs/GenericSync":27,"../inputs/MouseSync":28,"../inputs/TouchSync":33,"../math/Utilities":40,"../transitions/Transitionable":88}],44:[function(t,i){function e(t,i){this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new o(this.options),t&&this.setOptions(t),i||(i=0),this.transitionHelper=new n(i)}var n=t("../transitions/Transitionable"),o=t("../core/OptionsManager");e.DEFAULT_OPTIONS={cull:!1,transition:!0,pulseInTransition:!0,pulseOutTransition:!0},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},e.prototype.show=function(t,i){t=t||this.options.transition,this.set(1,t,i)},e.prototype.hide=function(t,i){t=t||this.options.transition,this.set(0,t,i)},e.prototype.set=function(t,i,e){this.halt(),this.transitionHelper.set(t,i,e)},e.prototype.halt=function(){this.transitionHelper.halt()},e.prototype.isVisible=function(){return this.transitionHelper.get()>0},e.prototype.modify=function(t){var i=this.transitionHelper.get();return this.options.cull&&!i?void 0:{opacity:i,target:t}},i.exports=e},{"../core/OptionsManager":10,"../transitions/Transitionable":88}],45:[function(t,i){function e(){this._chain=[],arguments.length&&this.addModifier.apply(this,arguments)}e.prototype.addModifier=function(){Array.prototype.push.apply(this._chain,arguments)},e.prototype.removeModifier=function(t){var i=this._chain.indexOf(t);0>i||this._chain.splice(i,1)},e.prototype.modify=function(t){for(var i=this._chain,e=t,n=0;n<i.length;n++)e=i[n].modify(e);return e},i.exports=e},{}],46:[function(t,i){function e(t){this._transformState=new r(o.identity),this._opacityState=new s(1),this._originState=new s([0,0]),this._alignState=new s([0,0]),this._sizeState=new s([0,0]),this._proportionsState=new s([0,0]),this._modifier=new n({transform:this._transformState,opacity:this._opacityState,origin:null,align:null,size:null,proportions:null}),this._hasOrigin=!1,this._hasAlign=!1,this._hasSize=!1,this._hasProportions=!1,t&&(t.transform&&this.setTransform(t.transform),void 0!==t.opacity&&this.setOpacity(t.opacity),t.origin&&this.setOrigin(t.origin),t.align&&this.setAlign(t.align),t.size&&this.setSize(t.size),t.proportions&&this.setProportions(t.proportions))}var n=t("../core/Modifier"),o=t("../core/Transform"),s=t("../transitions/Transitionable"),r=t("../transitions/TransitionableTransform");e.prototype.setTransform=function(t,i,e){return this._transformState.set(t,i,e),this},e.prototype.setOpacity=function(t,i,e){return this._opacityState.set(t,i,e),this},e.prototype.setOrigin=function(t,i,e){return null===t?(this._hasOrigin&&(this._modifier.originFrom(null),this._hasOrigin=!1),this):(this._hasOrigin||(this._hasOrigin=!0,this._modifier.originFrom(this._originState)),this._originState.set(t,i,e),this)},e.prototype.setAlign=function(t,i,e){return null===t?(this._hasAlign&&(this._modifier.alignFrom(null),this._hasAlign=!1),this):(this._hasAlign||(this._hasAlign=!0,this._modifier.alignFrom(this._alignState)),this._alignState.set(t,i,e),this)},e.prototype.setSize=function(t,i,e){return null===t?(this._hasSize&&(this._modifier.sizeFrom(null),this._hasSize=!1),this):(this._hasSize||(this._hasSize=!0,this._modifier.sizeFrom(this._sizeState)),this._sizeState.set(t,i,e),this)},e.prototype.setProportions=function(t,i,e){return null===t?(this._hasProportions&&(this._modifier.proportionsFrom(null),this._hasProportions=!1),this):(this._hasProportions||(this._hasProportions=!0,this._modifier.proportionsFrom(this._proportionsState)),this._proportionsState.set(t,i,e),this)},e.prototype.halt=function(){this._transformState.halt(),this._opacityState.halt(),this._originState.halt(),this._alignState.halt(),this._sizeState.halt(),this._proportionsState.halt()},e.prototype.getTransform=function(){return this._transformState.get()},e.prototype.getFinalTransform=function(){return this._transformState.getFinal()},e.prototype.getOpacity=function(){return this._opacityState.get()},e.prototype.getOrigin=function(){return this._hasOrigin?this._originState.get():null},e.prototype.getAlign=function(){return this._hasAlign?this._alignState.get():null},e.prototype.getSize=function(){return this._hasSize?this._sizeState.get():null},e.prototype.getProportions=function(){return this._hasProportions?this._proportionsState.get():null},e.prototype.modify=function(t){return this._modifier.modify(t)},i.exports=e},{"../core/Modifier":9,"../core/Transform":15,"../transitions/Transitionable":88,"../transitions/TransitionableTransform":89}],47:[function(t,i){i.exports={Draggable:t("./Draggable"),Fader:t("./Fader"),ModifierChain:t("./ModifierChain"),StateModifier:t("./StateModifier")}},{"./Draggable":43,"./Fader":44,"./ModifierChain":45,"./StateModifier":46}],48:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t),this._particles=[],this._bodies=[],this._agentData={},this._forces=[],this._constraints=[],this._buffer=0,this._prevTime=S(),this._isSleeping=!1,this._eventHandler=null,this._currAgentId=0,this._hasBodies=!1,this._eventHandler=null}function n(t){return t.applyForce?this._forces:t.applyConstraint?this._constraints:void 0}function o(t,i,e){return void 0===i&&(i=this.getParticlesAndBodies()),i instanceof Array||(i=[i]),t.on("change",this.wake.bind(this)),this._agentData[this._currAgentId]={agent:t,id:this._currAgentId,targets:i,source:e},n.call(this,t).push(this._currAgentId),this._currAgentId++}function s(t){return this._agentData[t]}function r(t){var i=s.call(this,this._forces[t]);i.agent.applyForce(i.targets,i.source)}function a(){for(var t=this._forces.length-1;t>-1;t--)r.call(this,t)}function h(t,i){var e=this._agentData[this._constraints[t]];return e.agent.applyConstraint(e.targets,e.source,i)}function c(t){for(var i=0;i<this.options.constraintSteps;){for(var e=this._constraints.length-1;e>-1;e--)h.call(this,e,t);i++}}function p(t,i){t.integrateVelocity(i),this.options.velocityCap&&t.velocity.cap(this.options.velocityCap).put(t.velocity)}function u(t,i){t.integrateAngularMomentum(i),t.updateAngularVelocity(),this.options.angularVelocityCap&&t.angularVelocity.cap(this.options.angularVelocityCap).put(t.angularVelocity)}function l(t,i){t.integrateOrientation(i)}function f(t,i){t.integratePosition(i),t.emit(T.update,t)}function d(t){a.call(this,t),this.forEach(p,t),this.forEachBody(u,t),c.call(this,t),this.forEachBody(l,t),this.forEach(f,t)}function _(){var t=0,i=0;return this.forEach(function(e){i=e.getEnergy(),t+=i}),t}function g(){var t=0;for(var i in this._agentData)t+=this.getAgentEnergy(i);return t}var y=t("../core/EventHandler"),v=17,m=1e3/120,O=17,S=Date.now,T={start:"start",update:"update",end:"end"};e.DEFAULT_OPTIONS={constraintSteps:1,sleepTolerance:1e-7,velocityCap:void 0,angularVelocityCap:void 0},e.prototype.setOptions=function(t){for(var i in t)this.options[i]&&(this.options[i]=t[i])},e.prototype.addBody=function(t){return t._engine=this,t.isBody?(this._bodies.push(t),this._hasBodies=!0):this._particles.push(t),t.on("start",this.wake.bind(this)),t},e.prototype.removeBody=function(t){var i=t.isBody?this._bodies:this._particles,e=i.indexOf(t);if(e>-1){for(var n in this._agentData)this._agentData.hasOwnProperty(n)&&this.detachFrom(this._agentData[n].id,t);i.splice(e,1)}0===this.getBodies().length&&(this._hasBodies=!1)},e.prototype.attach=function(t,i,e){if(this.wake(),t instanceof Array){for(var n=[],s=0;s<t.length;s++)n[s]=o.call(this,t[s],i,e);return n}return o.call(this,t,i,e)},e.prototype.attachTo=function(t,i){s.call(this,t).targets.push(i)},e.prototype.detach=function(t){var i=this.getAgent(t),e=n.call(this,i),o=e.indexOf(t);e.splice(o,1),delete this._agentData[t]},e.prototype.detachFrom=function(t,i){var e=s.call(this,t);if(e.source===i)this.detach(t);else{var n=e.targets,o=n.indexOf(i);o>-1&&n.splice(o,1)}},e.prototype.detachAll=function(){this._agentData={},this._forces=[],this._constraints=[],this._currAgentId=0},e.prototype.getAgent=function(t){return s.call(this,t).agent},e.prototype.getParticles=function(){return this._particles},e.prototype.getBodies=function(){return this._bodies},e.prototype.getParticlesAndBodies=function(){return this.getParticles().concat(this.getBodies())},e.prototype.forEachParticle=function(t,i){for(var e=this.getParticles(),n=0,o=e.length;o>n;n++)t.call(this,e[n],i)},e.prototype.forEachBody=function(t,i){if(this._hasBodies)for(var e=this.getBodies(),n=0,o=e.length;o>n;n++)t.call(this,e[n],i)},e.prototype.forEach=function(t,i){this.forEachParticle(t,i),this.forEachBody(t,i)},e.prototype.getAgentEnergy=function(t){var i=s.call(this,t);return i.agent.getEnergy(i.targets,i.source)},e.prototype.getEnergy=function(){return _.call(this)+g.call(this)},e.prototype.step=function(){if(!this.isSleeping()){var t=S(),i=t-this._prevTime;this._prevTime=t,m>i||(i>O&&(i=O),d.call(this,v),this.emit(T.update,this),this.getEnergy()<this.options.sleepTolerance&&this.sleep())}},e.prototype.isSleeping=function(){return this._isSleeping},e.prototype.isActive=function(){return!this._isSleeping},e.prototype.sleep=function(){this._isSleeping||(this.forEach(function(t){t.sleep()}),this.emit(T.end,this),this._isSleeping=!0)},e.prototype.wake=function(){this._isSleeping&&(this._prevTime=S(),this.emit(T.start,this),this._isSleeping=!1)},e.prototype.emit=function(t,i){null!==this._eventHandler&&this._eventHandler.emit(t,i)},e.prototype.on=function(t,i){null===this._eventHandler&&(this._eventHandler=new y),this._eventHandler.on(t,i)},i.exports=e},{"../core/EventHandler":7}],49:[function(t,i){function e(t){n.call(this,t),t=t||{},this.orientation=new r,this.angularVelocity=new s,this.angularMomentum=new s,this.torque=new s,t.orientation&&this.orientation.set(t.orientation),t.angularVelocity&&this.angularVelocity.set(t.angularVelocity),t.angularMomentum&&this.angularMomentum.set(t.angularMomentum),t.torque&&this.torque.set(t.torque),this.angularVelocity.w=0,this.setMomentsOfInertia(),this.pWorld=new s}var n=t("./Particle"),o=t("../../core/Transform"),s=t("../../math/Vector"),r=t("../../math/Quaternion"),a=t("../../math/Matrix"),h=t("../integrators/SymplecticEuler");e.DEFAULT_OPTIONS=n.DEFAULT_OPTIONS,e.DEFAULT_OPTIONS.orientation=[0,0,0,1],e.DEFAULT_OPTIONS.angularVelocity=[0,0,0],e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.isBody=!0,e.prototype.setMass=function(){n.prototype.setMass.apply(this,arguments),this.setMomentsOfInertia()},e.prototype.setMomentsOfInertia=function(){this.inertia=new a,this.inverseInertia=new a},e.prototype.updateAngularVelocity=function(){this.angularVelocity.set(this.inverseInertia.vectorMultiply(this.angularMomentum))},e.prototype.toWorldCoordinates=function(t){return this.pWorld.set(this.orientation.rotateVector(t))},e.prototype.getEnergy=function(){return n.prototype.getEnergy.call(this)+.5*this.inertia.vectorMultiply(this.angularVelocity).dot(this.angularVelocity)},e.prototype.reset=function(t,i,e,o){n.prototype.reset.call(this,t,i),this.angularVelocity.clear(),this.setOrientation(e||[1,0,0,0]),this.setAngularMomentum(o||[0,0,0])},e.prototype.setOrientation=function(t){this.orientation.set(t)},e.prototype.setAngularVelocity=function(t){this.wake(),this.angularVelocity.set(t)},e.prototype.setAngularMomentum=function(t){this.wake(),this.angularMomentum.set(t)},e.prototype.applyForce=function(t,i){n.prototype.applyForce.call(this,t),void 0!==i&&this.applyTorque(i.cross(t))},e.prototype.applyTorque=function(t){this.wake(),this.torque.set(this.torque.add(t))},e.prototype.getTransform=function(){return o.thenMove(this.orientation.getTransform(),o.getTranslate(n.prototype.getTransform.call(this)))},e.prototype._integrate=function(t){n.prototype._integrate.call(this,t),this.integrateAngularMomentum(t),this.updateAngularVelocity(t),this.integrateOrientation(t)},e.prototype.integrateAngularMomentum=function(t){h.integrateAngularMomentum(this,t)},e.prototype.integrateOrientation=function(t){h.integrateOrientation(this,t)},i.exports=e},{"../../core/Transform":15,"../../math/Matrix":37,"../../math/Quaternion":38,"../../math/Vector":41,"../integrators/SymplecticEuler":72,"./Particle":51}],50:[function(t,i){function e(t){t=t||{},this.setRadius(t.radius||0),n.call(this,t)}var n=t("./Body"),o=t("../../math/Matrix");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.setRadius=function(t){this.radius=t,this.size=[2*this.radius,2*this.radius],this.setMomentsOfInertia()},e.prototype.setMomentsOfInertia=function(){var t=this.mass,i=this.radius;this.inertia=new o([[.25*t*i*i,0,0],[0,.25*t*i*i,0],[0,0,.5*t*i*i]]),this.inverseInertia=new o([[4/(t*i*i),0,0],[0,4/(t*i*i),0],[0,0,2/(t*i*i)]])},i.exports=e},{"../../math/Matrix":37,"./Body":49}],51:[function(t,i){function e(t){t=t||{};var i=e.DEFAULT_OPTIONS;this.position=new o,this.velocity=new o,this.force=new o,this._engine=null,this._isSleeping=!0,this._eventOutput=null,this.mass=void 0!==t.mass?t.mass:i.mass,this.inverseMass=1/this.mass,this.setPosition(t.position||i.position),this.setVelocity(t.velocity||i.velocity),this.force.set(t.force||[0,0,0]),this.transform=s.identity.slice(),this._spec={size:[!0,!0],target:{transform:this.transform,origin:[.5,.5],target:null}}}function n(){this._eventOutput=new r,this._eventOutput.bindThis(this),r.setOutputHandler(this,this._eventOutput)}var o=t("../../math/Vector"),s=t("../../core/Transform"),r=t("../../core/EventHandler"),a=t("../integrators/SymplecticEuler");e.DEFAULT_OPTIONS={position:[0,0,0],velocity:[0,0,0],mass:1};var h={start:"start",update:"update",end:"end"},c=Date.now;e.prototype.isBody=!1,e.prototype.isActive=function(){return!this._isSleeping},e.prototype.sleep=function(){this._isSleeping||(this.emit(h.end,this),this._isSleeping=!0)},e.prototype.wake=function(){this._isSleeping&&(this.emit(h.start,this),this._isSleeping=!1,this._prevTime=c(),this._engine&&this._engine.wake())},e.prototype.setPosition=function(t){this.position.set(t)},e.prototype.setPosition1D=function(t){this.position.x=t},e.prototype.getPosition=function(){return this._engine.step(),this.position.get()},e.prototype.getPosition1D=function(){return this._engine.step(),this.position.x},e.prototype.setVelocity=function(t){this.velocity.set(t),(0!==t[0]||0!==t[1]||0!==t[2])&&this.wake()},e.prototype.setVelocity1D=function(t){this.velocity.x=t,0!==t&&this.wake()},e.prototype.getVelocity=function(){return this.velocity.get()},e.prototype.setForce=function(t){this.force.set(t),this.wake()},e.prototype.getVelocity1D=function(){return this.velocity.x},e.prototype.setMass=function(t){this.mass=t,this.inverseMass=1/t},e.prototype.getMass=function(){return this.mass},e.prototype.reset=function(t,i){this.setPosition(t||[0,0,0]),this.setVelocity(i||[0,0,0])},e.prototype.applyForce=function(t){t.isZero()||(this.force.add(t).put(this.force),this.wake())},e.prototype.applyImpulse=function(t){if(!t.isZero()){var i=this.velocity;i.add(t.mult(this.inverseMass)).put(i)}},e.prototype.integrateVelocity=function(t){a.integrateVelocity(this,t)},e.prototype.integratePosition=function(t){a.integratePosition(this,t)},e.prototype._integrate=function(t){this.integrateVelocity(t),this.integratePosition(t)},e.prototype.getEnergy=function(){return.5*this.mass*this.velocity.normSquared()},e.prototype.getTransform=function(){this._engine.step();var t=this.position,i=this.transform;return i[12]=t.x,i[13]=t.y,i[14]=t.z,i},e.prototype.modify=function(t){var i=this._spec.target;return i.transform=this.getTransform(),i.target=t,this._spec},e.prototype.emit=function(t,i){this._eventOutput&&this._eventOutput.emit(t,i)},e.prototype.on=function(){return n.call(this),this.on.apply(this,arguments)},e.prototype.removeListener=function(){return n.call(this),this.removeListener.apply(this,arguments)},e.prototype.pipe=function(){return n.call(this),this.pipe.apply(this,arguments)},e.prototype.unpipe=function(){return n.call(this),this.unpipe.apply(this,arguments)},i.exports=e},{"../../core/EventHandler":7,"../../core/Transform":15,"../../math/Vector":41,"../integrators/SymplecticEuler":72}],52:[function(t,i){function e(t){t=t||{},this.size=t.size||[0,0],n.call(this,t)}var n=t("./Body"),o=t("../../math/Matrix");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.setSize=function(t){this.size=t,this.setMomentsOfInertia()},e.prototype.setMomentsOfInertia=function(){var t=this.mass,i=this.size[0],e=this.size[1];this.inertia=new o([[t*e*e/12,0,0],[0,t*i*i/12,0],[0,0,t*(i*i+e*e)/12]]),this.inverseInertia=new o([[12/(t*e*e),0,0],[0,12/(t*i*i),0],[0,0,12/(t*(i*i+e*e))]])},i.exports=e},{"../../math/Matrix":37,"./Body":49}],53:[function(t,i){i.exports={Body:t("./Body"),Circle:t("./Circle"),Particle:t("./Particle"),Rectangle:t("./Rectangle")}},{"./Body":49,"./Circle":50,"./Particle":51,"./Rectangle":52}],54:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t),this.normal=new o,this.pDiff=new o,this.vDiff=new o,this.impulse1=new o,this.impulse2=new o,n.call(this)}var n=t("./Constraint"),o=t("../../math/Vector");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={restitution:.5,drift:.5,slop:0},e.prototype.setOptions=function(t){for(var i in t)this.options[i]=t[i]},e.prototype.applyConstraint=function(t,i,e){if(void 0!==i)for(var n=i.velocity,o=i.position,s=i.inverseMass,r=i.radius,a=this.options,h=a.drift,c=-a.slop,p=a.restitution,u=this.normal,l=this.pDiff,f=this.vDiff,d=this.impulse1,_=this.impulse2,g=0;g<t.length;g++){var y=t[g];if(y!==i){var v=y.velocity,m=y.position,O=y.inverseMass,S=y.radius;l.set(m.sub(o)),f.set(v.sub(n));var T=l.norm(),w=T-(r+S),b=1/(s+O),E=0;if(0>w){if(u.set(l.normalize()),this._eventOutput){var z={target:y,source:i,overlap:w,normal:u};this._eventOutput.emit("preCollision",z),this._eventOutput.emit("collision",z)}var I=c>=w?((1+p)*u.dot(f)+h/e*(w-c))/(E+e/b):(1+p)*u.dot(f)/(E+e/b);u.mult(e*I).put(d),d.mult(-1).put(_),i.applyImpulse(d),y.applyImpulse(_),this._eventOutput&&this._eventOutput.emit("postCollision",z)}}}},i.exports=e},{"../../math/Vector":41,"./Constraint":55}],55:[function(t,i){function e(){this.options=this.options||{},this._eventOutput=new n,n.setOutputHandler(this,this._eventOutput)}var n=t("../../core/EventHandler");e.prototype.setOptions=function(t){this._eventOutput.emit("change",t)},e.prototype.applyConstraint=function(){},e.prototype.getEnergy=function(){return 0},i.exports=e},{"../../core/EventHandler":7}],56:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t),this.J=new o,this.impulse=new o,n.call(this)}var n=t("./Constraint"),o=t("../../math/Vector");e.prototype=Object.create(n.prototype),e.prototype.constructor=e;var s=1e-7,r=Math.PI;e.DEFAULT_OPTIONS={equation:function(){return 0},plane:function(t,i,e){return e},period:0,dampingRatio:0},e.prototype.setOptions=function(t){for(var i in t)this.options[i]=t[i]},e.prototype.applyConstraint=function(t,i,e){for(var n=this.options,o=this.impulse,a=this.J,h=n.equation,c=n.plane,p=n.dampingRatio,u=n.period,l=0;l<t.length;l++){var f,d,_=t[l],g=_.velocity,y=_.position,v=_.mass;if(0===u)f=0,d=1;else{var m=4*v*r*p/u,O=4*v*r*r/(u*u);f=1/(m+e*O),d=e*O/(m+e*O)}var S=y.x,T=y.y,w=y.z,b=h(S,T,w),E=(h(S+s,T,w)-b)/s,z=(h(S,T+s,w)-b)/s,I=(h(S,T,w+s)-b)/s,M=c(S,T,w),x=(c(S+s,T,w)-M)/s,C=(c(S,T+s,w)-M)/s,P=(c(S,T,w+s)-M)/s;a.setXYZ(E+x,z+C,I+P);var F=d/e*(b+M),D=-(a.dot(g)+F)/(f+e*a.normSquared()/v);o.set(a.mult(e*D)),_.applyImpulse(o)}},i.exports=e},{"../../math/Vector":41,"./Constraint":55}],57:[function(t,i){function e(t){this.options=Object.create(this.constructor.DEFAULT_OPTIONS),t&&this.setOptions(t),this.impulse=new o,this.normal=new o,this.diffP=new o,this.diffV=new o,n.call(this)}var n=t("./Constraint"),o=t("../../math/Vector");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={anchor:null,length:0,minLength:0,period:0,dampingRatio:0};var s=Math.PI;e.prototype.setOptions=function(t){t.anchor&&(t.anchor.position instanceof o&&(this.options.anchor=t.anchor.position),t.anchor instanceof o&&(this.options.anchor=t.anchor),t.anchor instanceof Array&&(this.options.anchor=new o(t.anchor))),void 0!==t.length&&(this.options.length=t.length),void 0!==t.dampingRatio&&(this.options.dampingRatio=t.dampingRatio),void 0!==t.period&&(this.options.period=t.period),void 0!==t.minLength&&(this.options.minLength=t.minLength)},e.prototype.setAnchor=function(t){this.options.anchor||(this.options.anchor=new o),this.options.anchor.set(t)},e.prototype.applyConstraint=function(t,i,e){var n,o,r=this.normal,a=this.diffP,h=this.diffV,c=this.impulse,p=this.options,u=p.dampingRatio,l=p.period,f=p.minLength;if(i){var d=i.velocity;n=i.position,o=i.inverseMass}else n=this.options.anchor,o=0;for(var _=this.options.length,g=0;g<t.length;g++){var y=t[g],v=y.velocity,m=y.position,O=y.inverseMass;a.set(m.sub(n)),r.set(a.normalize());var S=a.norm()-_;if(Math.abs(S)<f)return;i?h.set(v.sub(d)):h.set(v);var T,w,b=1/(O+o);if(0===l)T=0,w=1;else{var E=4*b*s*u/l,z=4*b*s*s/(l*l);T=1/(E+e*z),w=e*z/(E+e*z)}var I=w/e*S,M=-(r.dot(h)+I)/(T+e/b);c.set(r.mult(e*M)),y.applyImpulse(c),i&&i.applyImpulse(c.mult(-1))}},i.exports=e},{"../../math/Vector":41,"./Constraint":55}],58:[function(t,i){function e(t){n.call(this),this.options=Object.create(this.constructor.DEFAULT_OPTIONS),t&&this.setOptions(t),this.pDiff=new o,this.vDiff=new o,this.impulse1=new o,this.impulse2=new o}var n=t("./Constraint"),o=t("../../math/Vector");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={period:300,dampingRatio:.1,length:0,anchor:void 0};var s=Math.PI;e.prototype.setOptions=function(t){void 0!==t.anchor&&(t.anchor instanceof o&&(this.options.anchor=t.anchor),t.anchor.position instanceof o&&(this.options.anchor=t.anchor.position),t.anchor instanceof Array&&(this.options.anchor=new o(t.anchor))),void 0!==t.length&&(this.options.length=t.length),void 0!==t.dampingRatio&&(this.options.dampingRatio=t.dampingRatio),void 0!==t.period&&(this.options.period=t.period),n.prototype.setOptions.call(this,t)
},e.prototype.getEnergy=function(t,i){for(var e=this.options,n=e.length,o=e.anchor||i.position,r=Math.pow(2*s/e.period,2),a=0,h=0;h<t.length;h++){var c=t[h],p=o.sub(c.position).norm()-n;a+=.5*r*p*p}return a},e.prototype.applyConstraint=function(t,i,e){for(var n=this.options,o=this.pDiff,r=this.vDiff,a=this.impulse1,h=this.impulse2,c=n.length,p=n.anchor||i.position,u=n.period,l=n.dampingRatio,f=0;f<t.length;f++){var d=t[f],_=d.position,g=d.velocity,y=d.mass,v=d.inverseMass;o.set(_.sub(p));var m,O=o.norm()-c;if(i){var S=i.inverseMass,T=i.velocity;r.set(g.sub(T)),m=1/(v+S)}else r.set(g),m=y;var w,b;if(0===this.options.period)w=0,b=1;else{var E=4*m*s*s/(u*u),z=4*m*s*l/u;b=e*E/(z+e*E),w=1/(z+e*E)}var I=b/e*O;o.normalize(-I).sub(r).mult(e/(w+e/m)).put(a),d.applyImpulse(a),i&&(a.mult(-1).put(h),i.applyImpulse(h))}},i.exports=e},{"../../math/Vector":41,"./Constraint":55}],59:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t),this.J=new o,this.impulse=new o,n.call(this)}var n=t("./Constraint"),o=t("../../math/Vector");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={equation:void 0,period:0,dampingRatio:0};var s=1e-7,r=Math.PI;e.prototype.setOptions=function(t){for(var i in t)this.options[i]=t[i]},e.prototype.applyConstraint=function(t,i,e){for(var n=this.impulse,o=this.J,a=this.options,h=a.equation,c=a.dampingRatio,p=a.period,u=0;u<t.length;u++){var l,f,d=t[u],_=d.velocity,g=d.position,y=d.mass;if(0===p)l=0,f=1;else{var v=4*y*r*c/p,m=4*y*r*r/(p*p);l=1/(v+e*m),f=e*m/(v+e*m)}var O=g.x,S=g.y,T=g.z,w=h(O,S,T),b=(h(O+s,g,g)-w)/s,E=(h(O,S+s,g)-w)/s,z=(h(O,S,g+s)-w)/s;o.setXYZ(b,E,z);var I=f/e*w,M=-(o.dot(_)+I)/(l+e*o.normSquared()/y);n.set(o.mult(e*M)),d.applyImpulse(n)}},i.exports=e},{"../../math/Vector":41,"./Constraint":55}],60:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t),this.diff=new h,this.impulse=new h,a.call(this)}function n(t,i){return i.dot(t)}function o(t){var i=this.options.normal,e=this.options.distance;return t.dot(i)+e}function s(t,i,n){var o=t.position,s=t.velocity,r=t.mass,a=this.options.normal,h=this.options.onContact,c=this.options.restitution,p=this.impulse,u=this.options.drift,l=-this.options.slop,f=0;if(this._eventOutput){var d={particle:t,wall:this,overlap:i,normal:a};this._eventOutput.emit("preCollision",d),this._eventOutput.emit("collision",d)}switch(h){case e.ON_CONTACT.REFLECT:var _=l>i?-((1+c)*a.dot(s)+u/n*(i-l))/(r*n+f):-((1+c)*a.dot(s))/(r*n+f);p.set(a.mult(n*_)),t.applyImpulse(p),t.setPosition(o.add(a.mult(-i)))}this._eventOutput&&this._eventOutput.emit("postCollision",d)}function r(t,i){var n=this.options.onContact,o=t.position,s=this.options.normal;n===e.ON_CONTACT.REFLECT&&t.setPosition(o.add(s.mult(-i)))}var a=t("./Constraint"),h=t("../../math/Vector");e.prototype=Object.create(a.prototype),e.prototype.constructor=e,e.ON_CONTACT={REFLECT:0,SILENT:1},e.DEFAULT_OPTIONS={restitution:.5,drift:.5,slop:0,normal:[1,0,0],distance:0,onContact:e.ON_CONTACT.REFLECT},e.prototype.setOptions=function(t){void 0!==t.normal&&(t.normal instanceof h&&(this.options.normal=t.normal.clone()),t.normal instanceof Array&&(this.options.normal=new h(t.normal))),void 0!==t.restitution&&(this.options.restitution=t.restitution),void 0!==t.drift&&(this.options.drift=t.drift),void 0!==t.slop&&(this.options.slop=t.slop),void 0!==t.distance&&(this.options.distance=t.distance),void 0!==t.onContact&&(this.options.onContact=t.onContact)},e.prototype.applyConstraint=function(t,i,e){for(var a=this.options.normal,h=0;h<t.length;h++){var c=t[h],p=c.position,u=c.velocity,l=c.radius||0,f=o.call(this,p.add(a.mult(-l))),d=n.call(this,a,u);0>=f&&(0>d?s.call(this,c,f,e):r.call(this,c,f,e))}},i.exports=e},{"../../math/Vector":41,"./Constraint":55}],61:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t),o.call(this,t.sides||this.options.sides),r.call(this)}function n(t,i,n){var o,s=e.SIDES;switch(parseInt(t)){case s.LEFT:o=i[0]*n[0];break;case s.TOP:o=i[1]*n[1];break;case s.FRONT:o=i[2]*n[2];break;case s.RIGHT:o=i[0]*(1-n[0]);break;case s.BOTTOM:o=i[1]*(1-n[1]);break;case s.BACK:o=i[2]*(1-n[2])}return o}function o(t){this.components={};for(var i=this.components,e=0;e<t.length;e++){var o=t[e];i[e]=new a({normal:c[o].clone(),distance:n(o,this.options.size,this.options.origin)})}}function s(t){this.forEach(function(i){i.setOptions(t)});for(var i in t)this.options[i]=t[i]}var r=t("./Constraint"),a=t("./Wall"),h=t("../../math/Vector");e.prototype=Object.create(r.prototype),e.prototype.constructor=e,e.ON_CONTACT=a.ON_CONTACT,e.SIDES={LEFT:0,RIGHT:1,TOP:2,BOTTOM:3,FRONT:4,BACK:5,TWO_DIMENSIONAL:[0,1,2,3],THREE_DIMENSIONAL:[0,1,2,3,4,5]},e.DEFAULT_OPTIONS={sides:e.SIDES.TWO_DIMENSIONAL,size:[window.innerWidth,window.innerHeight,0],origin:[.5,.5,.5],drift:.5,slop:0,restitution:.5,onContact:e.ON_CONTACT.REFLECT};var c={0:new h(1,0,0),1:new h(-1,0,0),2:new h(0,1,0),3:new h(0,-1,0),4:new h(0,0,1),5:new h(0,0,-1)};e.prototype.setOptions=function(t){var i=!1;void 0!==t.restitution&&s.call(this,{restitution:t.restitution}),void 0!==t.drift&&s.call(this,{drift:t.drift}),void 0!==t.slop&&s.call(this,{slop:t.slop}),void 0!==t.onContact&&s.call(this,{onContact:t.onContact}),void 0!==t.size&&(i=!0),void 0!==t.sides&&(this.options.sides=t.sides),void 0!==t.origin&&(i=!0),i&&this.setSize(t.size,t.origin)},e.prototype.setSize=function(t,i){i=i||this.options.origin,i.length<3&&(i[2]=.5),this.forEach(function(e,o){var s=n(o,t,i);e.setOptions({distance:s})}),this.options.size=t,this.options.origin=i},e.prototype.applyConstraint=function(t,i,e){this.forEach(function(n){n.applyConstraint(t,i,e)})},e.prototype.forEach=function(t){var i=this.options.sides;for(var e in this.sides)t(i[e],e)},e.prototype.rotateZ=function(t){this.forEach(function(i){var e=i.options.normal;e.rotateZ(t).put(e)})},e.prototype.rotateX=function(t){this.forEach(function(i){var e=i.options.normal;e.rotateX(t).put(e)})},e.prototype.rotateY=function(t){this.forEach(function(i){var e=i.options.normal;e.rotateY(t).put(e)})},e.prototype.reset=function(){var t=this.options.sides;for(var i in t){var e=this.components[i];e.options.normal.set(c[i])}},i.exports=e},{"../../math/Vector":41,"./Constraint":55,"./Wall":60}],62:[function(t,i){i.exports={Collision:t("./Collision"),Constraint:t("./Constraint"),Curve:t("./Curve"),Distance:t("./Distance"),Snap:t("./Snap"),Surface:t("./Surface"),Wall:t("./Wall"),Walls:t("./Walls")}},{"./Collision":54,"./Constraint":55,"./Curve":56,"./Distance":57,"./Snap":58,"./Surface":59,"./Wall":60,"./Walls":61}],63:[function(t,i){function e(t){this.options=Object.create(this.constructor.DEFAULT_OPTIONS),t&&this.setOptions(t),n.call(this)}var n=t("./Force");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.FORCE_FUNCTIONS={LINEAR:function(t){return t},QUADRATIC:function(t){return t.mult(t.norm())}},e.DEFAULT_OPTIONS={strength:.01,forceFunction:e.FORCE_FUNCTIONS.LINEAR},e.prototype.applyForce=function(t){var i,e,n=this.options.strength,o=this.options.forceFunction,s=this.force;for(i=0;i<t.length;i++)e=t[i],o(e.velocity).mult(-n).put(s),e.applyForce(s)},e.prototype.setOptions=function(t){for(var i in t)this.options[i]=t[i]},i.exports=e},{"./Force":64}],64:[function(t,i){function e(t){this.force=new n(t),this._eventOutput=new o,o.setOutputHandler(this,this._eventOutput)}var n=t("../../math/Vector"),o=t("../../core/EventHandler");e.prototype.setOptions=function(t){this._eventOutput.emit("change",t)},e.prototype.applyForce=function(t){for(var i=t.length;i--;)t[i].applyForce(this.force)},e.prototype.getEnergy=function(){return 0},i.exports=e},{"../../core/EventHandler":7,"../../math/Vector":41}],65:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t),this.disp=new o,n.call(this)}var n=t("./Force"),o=t("../../math/Vector");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.DECAY_FUNCTIONS={LINEAR:function(t,i){return Math.max(1-1/i*t,0)},MORSE:function(t,i){var e=0===i?100:i,n=t+e*(1-Math.log(2));return Math.max(1-Math.pow(1-Math.exp(n/e-1),2),0)},INVERSE:function(t,i){return 1/(1-i+t)},GRAVITY:function(t,i){return 1/(1-i+t*t)}},e.DEFAULT_OPTIONS={strength:1,anchor:void 0,range:[0,1/0],cutoff:0,cap:1/0,decayFunction:e.DECAY_FUNCTIONS.GRAVITY},e.prototype.setOptions=function(t){void 0!==t.anchor&&(t.anchor.position instanceof o&&(this.options.anchor=t.anchor.position),t.anchor instanceof Array&&(this.options.anchor=new o(t.anchor)),delete t.anchor);for(var i in t)this.options[i]=t[i]},e.prototype.applyForce=function(t,i){var e=this.options,n=this.force,o=this.disp,s=e.strength,r=e.anchor||i.position,a=e.cap,h=e.cutoff,c=e.range[0],p=e.range[1],u=e.decayFunction;if(0!==s)for(var l,f,d,_,g=t.length;g--;)l=t[g],l!==i&&(f=l.mass,d=l.position,o.set(d.sub(r)),_=o.norm(),p>_&&_>c&&(n.set(o.normalize(s*f*u(_,h)).cap(a)),l.applyForce(n)))},i.exports=e},{"../../math/Vector":41,"./Force":64}],66:[function(t,i){function e(t){n.call(this,t)}var n=t("./Drag");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS=n.DEFAULT_OPTIONS,e.FORCE_FUNCTIONS=n.FORCE_FUNCTIONS,e.FORCE_FUNCTIONS={LINEAR:function(t){return t},QUADRATIC:function(t){return t.mult(t.norm())}},e.prototype.applyForce=function(t){var i,e,n=this.options.strength,o=this.options.forceFunction,s=this.force;for(i=0;i<t.length;i++)e=t[i],o(e.angularVelocity).mult(-100*n).put(s),e.applyTorque(s)},e.prototype.setOptions=function(t){for(var i in t)this.options[i]=t[i]},i.exports=e},{"./Drag":63}],67:[function(t,i){function e(t){a.call(this,t)}function n(){var t=this.options;t.stiffness=Math.pow(2*c/t.period,2)}function o(){var t=this.options;t.damping=4*c*t.dampingRatio/t.period}function s(){n.call(this),o.call(this)}var r=t("./Force"),a=t("./Spring"),h=t("../../math/Quaternion");e.prototype=Object.create(a.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS=a.DEFAULT_OPTIONS,e.FORCE_FUNCTIONS=a.FORCE_FUNCTIONS;var c=Math.PI;e.prototype.setOptions=function(t){void 0!==t.anchor&&(t.anchor instanceof h&&(this.options.anchor=t.anchor),t.anchor instanceof Array&&(this.options.anchor=new h(t.anchor))),void 0!==t.period&&(this.options.period=t.period),void 0!==t.dampingRatio&&(this.options.dampingRatio=t.dampingRatio),void 0!==t.length&&(this.options.length=t.length),void 0!==t.forceFunction&&(this.options.forceFunction=t.forceFunction),void 0!==t.maxLength&&(this.options.maxLength=t.maxLength),s.call(this),r.prototype.setOptions.call(this,t)},e.prototype.applyForce=function(t){var i,e,n,o,s=this.force,r=this.options,a=this.disp,h=r.stiffness,c=r.damping,p=r.length,u=r.anchor,l=r.forceFunction,f=r.maxLength;for(i=0;i<t.length;i++){if(e=t[i],a.set(u.sub(e.orientation)),n=a.norm()-p,0===n)return;o=e.mass,h*=o,c*=o,s.set(a.normalize(h*l(n,f))),c&&s.add(e.angularVelocity.mult(-c)).put(s),e.applyTorque(s)}},e.prototype.getEnergy=function(t){for(var i=this.options,e=i.length,n=i.anchor,o=i.stiffness,s=0,r=0;r<t.length;r++){var a=t[r],h=n.sub(a.orientation).norm()-e;s+=.5*o*h*h}return s},i.exports=e},{"../../math/Quaternion":38,"./Force":64,"./Spring":68}],68:[function(t,i){function e(t){r.call(this),this.options=Object.create(this.constructor.DEFAULT_OPTIONS),t&&this.setOptions(t),this.disp=new a(0,0,0),s.call(this)}function n(){var t=this.options;t.stiffness=Math.pow(2*h/t.period,2)}function o(){var t=this.options;t.damping=4*h*t.dampingRatio/t.period}function s(){n.call(this),o.call(this)}var r=t("./Force"),a=t("../../math/Vector");e.prototype=Object.create(r.prototype),e.prototype.constructor=e;var h=Math.PI,c=150;e.FORCE_FUNCTIONS={FENE:function(t,i){var e=.99*i,n=Math.max(Math.min(t,e),-e);return n/(1-n*n/(i*i))},HOOK:function(t){return t}},e.DEFAULT_OPTIONS={period:300,dampingRatio:.1,length:0,maxLength:1/0,anchor:void 0,forceFunction:e.FORCE_FUNCTIONS.HOOK},e.prototype.setOptions=function(t){void 0!==t.anchor&&(t.anchor.position instanceof a&&(this.options.anchor=t.anchor.position),t.anchor instanceof a&&(this.options.anchor=t.anchor),t.anchor instanceof Array&&(this.options.anchor=new a(t.anchor))),void 0!==t.period&&(t.period<c&&(t.period=c,console.warn("The period of a SpringTransition is capped at "+c+" ms. Use a SnapTransition for faster transitions")),this.options.period=t.period),void 0!==t.dampingRatio&&(this.options.dampingRatio=t.dampingRatio),void 0!==t.length&&(this.options.length=t.length),void 0!==t.forceFunction&&(this.options.forceFunction=t.forceFunction),void 0!==t.maxLength&&(this.options.maxLength=t.maxLength),s.call(this),r.prototype.setOptions.call(this,t)},e.prototype.applyForce=function(t,i){var e,n,o,s,r,a,h=this.force,c=this.disp,p=this.options,u=p.stiffness,l=p.damping,f=p.length,d=p.maxLength,_=p.anchor||i.position,g=p.forceFunction;for(e=0;e<t.length;e++){if(n=t[e],o=n.position,s=n.velocity,_.sub(o).put(c),r=c.norm()-f,0===r)return;a=n.mass,u*=a,l*=a,c.normalize(u*g(r,d)).put(h),l&&(i?h.add(s.sub(i.velocity).mult(-l)).put(h):h.add(s.mult(-l)).put(h)),n.applyForce(h),i&&i.applyForce(h.mult(-1))}},e.prototype.getEnergy=function(t,i){for(var e=this.options,n=e.length,o=i?i.position:e.anchor,s=e.stiffness,r=0,a=0;a<t.length;a++){var h=t[a],c=o.sub(h.position).norm()-n;r+=.5*s*c*c}return r},i.exports=e},{"../../math/Vector":41,"./Force":64}],69:[function(t,i){function e(t){o.call(this),this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t),this.evaluation=new s}function n(t){var i=e.FIELDS;switch(t){case i.CONSTANT:this.options.direction?this.options.direction instanceof Array&&(this.options.direction=new s(this.options.direction)):this.options.direction=new s(0,1,0);break;case i.POINT_ATTRACTOR:this.options.position?this.options.position instanceof Array&&(this.options.position=new s(this.options.position)):this.options.position=new s(0,0,0)}}var o=t("./Force"),s=t("../../math/Vector");e.prototype=Object.create(o.prototype),e.prototype.constructor=e,e.FIELDS={CONSTANT:function(t,i){i.direction.put(this.evaluation)},LINEAR:function(t){t.put(this.evaluation)},RADIAL:function(t){t.mult(-1).put(this.evaluation)},POINT_ATTRACTOR:function(t,i){i.position.sub(t).put(this.evaluation)}},e.DEFAULT_OPTIONS={strength:.01,field:e.FIELDS.CONSTANT},e.prototype.setOptions=function(t){void 0!==t.strength&&(this.options.strength=t.strength),void 0!==t.direction&&(this.options.direction=t.direction),void 0!==t.field&&(this.options.field=t.field,n.call(this,this.options.field))},e.prototype.applyForce=function(t){var i,e,n=this.force,o=this.options.strength,s=this.options.field;for(i=0;i<t.length;i++)e=t[i],s.call(this,e.position,this.options),this.evaluation.mult(e.mass*o).put(n),e.applyForce(n)},e.prototype.getEnergy=function(t){var i,n,o=this.options.field,s=e.FIELDS,r=0;switch(o){case s.CONSTANT:r=t.length*this.options.direction.norm();break;case s.RADIAL:for(i=0;i<t.length;i++)n=t[i],r+=n.position.norm();break;case s.POINT_ATTRACTOR:for(i=0;i<t.length;i++)n=t[i],r+=n.position.sub(this.options.position).norm()}return r*=this.options.strength},i.exports=e},{"../../math/Vector":41,"./Force":64}],70:[function(t,i){i.exports={Drag:t("./Drag"),Force:t("./Force"),Repulsion:t("./Repulsion"),RotationalDrag:t("./RotationalDrag"),RotationalSpring:t("./RotationalSpring"),Spring:t("./Spring"),VectorField:t("./VectorField")}},{"./Drag":63,"./Force":64,"./Repulsion":65,"./RotationalDrag":66,"./RotationalSpring":67,"./Spring":68,"./VectorField":69}],71:[function(t,i){i.exports={PhysicsEngine:t("./PhysicsEngine"),bodies:t("./bodies"),constraints:t("./constraints"),forces:t("./forces"),integrators:t("./integrators")}},{"./PhysicsEngine":48,"./bodies":53,"./constraints":62,"./forces":70,"./integrators":73}],72:[function(t,i){var e={};e.integrateVelocity=function(t,i){var e=t.velocity,n=t.inverseMass,o=t.force;o.isZero()||(e.add(o.mult(i*n)).put(e),o.clear())},e.integratePosition=function(t,i){var e=t.position,n=t.velocity;e.add(n.mult(i)).put(e)},e.integrateAngularMomentum=function(t,i){var e=t.angularMomentum,n=t.torque;n.isZero()||(e.add(n.mult(i)).put(e),n.clear())},e.integrateOrientation=function(t,i){var e=t.orientation,n=t.angularVelocity;n.isZero()||e.add(e.multiply(n).scalarMultiply(.5*i)).put(e)},i.exports=e},{}],73:[function(t,i){i.exports={SymplecticEuler:t("./SymplecticEuler")}},{"./SymplecticEuler":72}],74:[function(t,i){function e(t){t&&t.canvasSize&&(this._canvasSize=t.canvasSize),n.apply(this,arguments),this._canvasSize||(this._canvasSize=this.getSize()),this._backBuffer=document.createElement("canvas"),this._canvasSize&&(this._backBuffer.width=this._canvasSize[0],this._backBuffer.height=this._canvasSize[1]),this._contextId=void 0}var n=t("../core/Surface");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.elementType="canvas",e.prototype.elementClass="famous-surface",e.prototype.setContent=function(){},e.prototype.deploy=function(t){this._canvasSize&&(t.width=this._canvasSize[0],t.height=this._canvasSize[1]),"2d"===this._contextId&&(t.getContext(this._contextId).drawImage(this._backBuffer,0,0),this._backBuffer.width=0,this._backBuffer.height=0)},e.prototype.recall=function(t){this.getSize(),this._backBuffer.width=t.width,this._backBuffer.height=t.height,"2d"===this._contextId&&(this._backBuffer.getContext(this._contextId).drawImage(t,0,0),t.width=0,t.height=0)},e.prototype.getContext=function(t){return this._contextId=t,this._currentTarget?this._currentTarget.getContext(t):this._backBuffer.getContext(t)},e.prototype.setSize=function(t,i){n.prototype.setSize.apply(this,arguments),i&&(this._canvasSize=[i[0],i[1]]),this._currentTarget&&(this._currentTarget.width=this._canvasSize[0],this._currentTarget.height=this._canvasSize[1])},i.exports=e},{"../core/Surface":14}],75:[function(t,i){function e(t){n.call(this,t),this._container=document.createElement("div"),this._container.classList.add("famous-group"),this._container.classList.add("famous-container-group"),this._shouldRecalculateSize=!1,this.context=new o(this._container),this.setContent(this._container)}var n=t("../core/Surface"),o=t("../core/Context");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.elementType="div",e.prototype.elementClass="famous-surface",e.prototype.add=function(){return this.context.add.apply(this.context,arguments)},e.prototype.render=function(){return this._sizeDirty&&(this._shouldRecalculateSize=!0),n.prototype.render.apply(this,arguments)},e.prototype.deploy=function(){return this._shouldRecalculateSize=!0,n.prototype.deploy.apply(this,arguments)},e.prototype.commit=function(){var t=this._size?[this._size[0],this._size[1]]:null,i=n.prototype.commit.apply(this,arguments);return(this._shouldRecalculateSize||t&&(this._size[0]!==t[0]||this._size[1]!==t[1]))&&(this.context.setSize(),this._shouldRecalculateSize=!1),this.context.update(),i},i.exports=e},{"../core/Context":1,"../core/Surface":14}],76:[function(t,i){function e(t){t&&(this._method=t.method||""),n.apply(this,arguments)}var n=t("./ContainerSurface");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.elementType="form",e.prototype.deploy=function(t){return this._method&&(t.method=this._method),n.prototype.deploy.apply(this,arguments)},i.exports=e},{"./ContainerSurface":75}],77:[function(t,i){function e(){this._imageUrl=void 0,n.apply(this,arguments)}var n=t("../core/Surface"),o=[],s=[],r=[],a=!0;e.enableCache=function(){a=!0},e.disableCache=function(){a=!1},e.clearCache=function(){o=[],s=[],r=[]},e.getCache=function(){return{urlCache:o,countCache:s,nodeCache:r}},e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.elementType="img",e.prototype.elementClass="famous-surface",e.prototype.setContent=function(t){var i=o.indexOf(this._imageUrl);-1!==i&&(1===s[i]?(o.splice(i,1),s.splice(i,1),r.splice(i,1)):s[i]--),i=o.indexOf(t),-1===i?(o.push(t),s.push(1)):s[i]++,this._imageUrl=t,this._contentDirty=!0},e.prototype.deploy=function(t){var i=o.indexOf(this._imageUrl);if(void 0===r[i]&&a){var e=new Image;e.src=this._imageUrl||"",r[i]=e}t.src=this._imageUrl||""},e.prototype.recall=function(t){t.src=""},i.exports=e},{"../core/Surface":14}],78:[function(t,i){function e(t){this._placeholder=t.placeholder||"",this._value=t.value||"",this._type=t.type||"text",this._name=t.name||"",n.apply(this,arguments),this.on("click",this.focus.bind(this)),window.addEventListener("click",function(t){t.target!==this._currentTarget&&this.blur()}.bind(this))}var n=t("../core/Surface");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.elementType="input",e.prototype.elementClass="famous-surface",e.prototype.setPlaceholder=function(t){return this._placeholder=t,this._contentDirty=!0,this},e.prototype.focus=function(){return this._currentTarget&&this._currentTarget.focus(),this},e.prototype.blur=function(){return this._currentTarget&&this._currentTarget.blur(),this},e.prototype.setValue=function(t){return this._value=t,this._contentDirty=!0,this},e.prototype.setType=function(t){return this._type=t,this._contentDirty=!0,this},e.prototype.getValue=function(){return this._currentTarget?this._currentTarget.value:this._value},e.prototype.setName=function(t){return this._name=t,this._contentDirty=!0,this},e.prototype.getName=function(){return this._name},e.prototype.deploy=function(t){""!==this._placeholder&&(t.placeholder=this._placeholder),t.value=this._value,t.type=this._type,t.name=this._name},i.exports=e},{"../core/Surface":14}],79:[function(t,i){function e(t){n.apply(this,arguments),this._type="submit",t&&t.onClick&&this.setOnClick(t.onClick)}var n=t("./InputSurface");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.setOnClick=function(t){this.onClick=t},e.prototype.deploy=function(t){this.onclick&&(t.onClick=this.onClick),n.prototype.deploy.apply(this,arguments)},i.exports=e},{"./InputSurface":78}],80:[function(t,i){function e(t){this._placeholder=t.placeholder||"",this._value=t.value||"",this._name=t.name||"",this._wrap=t.wrap||"",this._cols=t.cols||"",this._rows=t.rows||"",n.apply(this,arguments),this.on("click",this.focus.bind(this))}var n=t("../core/Surface");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.elementType="textarea",e.prototype.elementClass="famous-surface",e.prototype.setPlaceholder=function(t){return this._placeholder=t,this._contentDirty=!0,this},e.prototype.focus=function(){return this._currentTarget&&this._currentTarget.focus(),this},e.prototype.blur=function(){return this._currentTarget&&this._currentTarget.blur(),this},e.prototype.setValue=function(t){return this._value=t,this._contentDirty=!0,this},e.prototype.getValue=function(){return this._currentTarget?this._currentTarget.value:this._value},e.prototype.setName=function(t){return this._name=t,this._contentDirty=!0,this},e.prototype.getName=function(){return this._name},e.prototype.setWrap=function(t){return this._wrap=t,this._contentDirty=!0,this},e.prototype.setColumns=function(t){return this._cols=t,this._contentDirty=!0,this},e.prototype.setRows=function(t){return this._rows=t,this._contentDirty=!0,this},e.prototype.deploy=function(t){""!==this._placeholder&&(t.placeholder=this._placeholder),""!==this._value&&(t.value=this._value),""!==this._name&&(t.name=this._name),""!==this._wrap&&(t.wrap=this._wrap),""!==this._cols&&(t.cols=this._cols),""!==this._rows&&(t.rows=this._rows)},i.exports=e},{"../core/Surface":14}],81:[function(t,i){function e(t){n.apply(this,arguments),this._videoUrl=void 0,this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t)}var n=t("../core/Surface");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={autoplay:!1},e.prototype.elementType="video",e.prototype.elementClass="famous-surface",e.prototype.setOptions=function(t){t.size&&this.setSize(t.size),t.classes&&this.setClasses(t.classes),t.properties&&this.setProperties(t.properties),t.autoplay&&(this.options.autoplay=t.autoplay),t.src&&(this._videoUrl=t.src,this._contentDirty=!0)},e.prototype.setContent=function(t){this._videoUrl=t,this._contentDirty=!0},e.prototype.deploy=function(t){t.src=this._videoUrl,t.autoplay=this.options.autoplay},e.prototype.recall=function(t){t.src=""},i.exports=e},{"../core/Surface":14}],82:[function(t,i){i.exports={CanvasSurface:t("./CanvasSurface"),ContainerSurface:t("./ContainerSurface"),FormContainerSurface:t("./FormContainerSurface"),ImageSurface:t("./ImageSurface"),InputSurface:t("./InputSurface"),SubmitInputSurface:t("./SubmitInputSurface"),TextareaSurface:t("./TextareaSurface"),VideoSurface:t("./VideoSurface")}},{"./CanvasSurface":74,"./ContainerSurface":75,"./FormContainerSurface":76,"./ImageSurface":77,"./InputSurface":78,"./SubmitInputSurface":79,"./TextareaSurface":80,"./VideoSurface":81}],83:[function(t,i){function e(t){this._map=t||null,this._cachedOutput=null,this._cachedInput=Number.NaN}e.create=function(t){var i=new e(t);return i.get.bind(i)},e.prototype.get=function(t){return t!==this._cachedInput&&(this._cachedInput=t,this._cachedOutput=this._map(t)),this._cachedOutput},i.exports=e},{}],84:[function(t,i){var e={inQuad:function(t){return t*t},outQuad:function(t){return-(t-=1)*t+1},inOutQuad:function(t){return(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1)},inCubic:function(t){return t*t*t},outCubic:function(t){return--t*t*t+1},inOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},inQuart:function(t){return t*t*t*t},outQuart:function(t){return-(--t*t*t*t-1)},inOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)},inQuint:function(t){return t*t*t*t*t},outQuint:function(t){return--t*t*t*t*t+1},inOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},inSine:function(t){return-1*Math.cos(t*(Math.PI/2))+1},outSine:function(t){return Math.sin(t*(Math.PI/2))},inOutSine:function(t){return-.5*(Math.cos(Math.PI*t)-1)},inExpo:function(t){return 0===t?0:Math.pow(2,10*(t-1))},outExpo:function(t){return 1===t?1:-Math.pow(2,-10*t)+1},inOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},inCirc:function(t){return-(Math.sqrt(1-t*t)-1)},outCirc:function(t){return Math.sqrt(1- --t*t)},inOutCirc:function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},inElastic:function(t){var i=1.70158,e=0,n=1;return 0===t?0:1===t?1:(e||(e=.3),i=e/(2*Math.PI)*Math.asin(1/n),-(n*Math.pow(2,10*(t-=1))*Math.sin((t-i)*2*Math.PI/e)))},outElastic:function(t){var i=1.70158,e=0,n=1;return 0===t?0:1===t?1:(e||(e=.3),i=e/(2*Math.PI)*Math.asin(1/n),n*Math.pow(2,-10*t)*Math.sin((t-i)*2*Math.PI/e)+1)},inOutElastic:function(t){var i=1.70158,e=0,n=1;return 0===t?0:2===(t/=.5)?1:(e||(e=.3*1.5),i=e/(2*Math.PI)*Math.asin(1/n),1>t?-.5*n*Math.pow(2,10*(t-=1))*Math.sin((t-i)*2*Math.PI/e):.5*n*Math.pow(2,-10*(t-=1))*Math.sin((t-i)*2*Math.PI/e)+1)},inBack:function(t,i){return void 0===i&&(i=1.70158),t*t*((i+1)*t-i)},outBack:function(t,i){return void 0===i&&(i=1.70158),--t*t*((i+1)*t+i)+1},inOutBack:function(t,i){return void 0===i&&(i=1.70158),(t/=.5)<1?.5*t*t*(((i*=1.525)+1)*t-i):.5*((t-=2)*t*(((i*=1.525)+1)*t+i)+2)},inBounce:function(t){return 1-e.outBounce(1-t)},outBounce:function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},inOutBounce:function(t){return.5>t?.5*e.inBounce(2*t):.5*e.outBounce(2*t-1)+.5}};i.exports=e},{}],85:[function(t,i){function e(t){this.method=t,this._instances=[],this.state=[]}var n=t("../utilities/Utility");e.SUPPORTS_MULTIPLE=!0,e.prototype.get=function(){for(var t=0;t<this._instances.length;t++)this.state[t]=this._instances[t].get();return this.state},e.prototype.set=function(t,i,e){for(var o=n.after(t.length,e),s=0;s<t.length;s++)this._instances[s]||(this._instances[s]=new this.method),this._instances[s].set(t[s],i,o)},e.prototype.reset=function(t){for(var i=0;i<t.length;i++)this._instances[i]||(this._instances[i]=new this.method),this._instances[i].reset(t[i])},i.exports=e},{"../utilities/Utility":95}],86:[function(t,i){function e(t){t=t||0,this.endState=new v(t),this.initState=new v,this._dimensions=1,this._restTolerance=1e-10,this._absRestTolerance=this._restTolerance,this._callback=void 0,this.PE=new _,this.particle=new g,this.spring=new y({anchor:this.endState}),this.PE.addBody(this.particle),this.PE.attach(this.spring,this.particle)}function n(){return this.particle.getEnergy()+this.spring.getEnergy([this.particle])}function o(){var t=this.endState.sub(this.initState).normSquared();this._absRestTolerance=0===t?this._restTolerance:this._restTolerance*t}function s(t){this.endState.set(t),o.call(this)}function r(){this.PE.wake()}function a(){this.PE.sleep()}function h(t){this.particle.position.set(t)}function c(t){this.particle.velocity.set(t)}function p(){return 0===this._dimensions?this.particle.getPosition1D():this.particle.getPosition()}function u(){return 0===this._dimensions?this.particle.getVelocity1D():this.particle.getVelocity()}function l(t){this._callback=t}function f(t){var i=e.DEFAULT_OPTIONS;void 0===t.period&&(t.period=i.period),void 0===t.dampingRatio&&(t.dampingRatio=i.dampingRatio),void 0===t.velocity&&(t.velocity=i.velocity),this.spring.setOptions({period:t.period,dampingRatio:t.dampingRatio}),c.call(this,t.velocity)}function d(){if(this.PE.isSleeping()){if(this._callback){var t=this._callback;this._callback=void 0,t()}}else n.call(this)<this._absRestTolerance&&(h.call(this,this.endState),c.call(this,[0,0,0]),a.call(this))}var _=t("../physics/PhysicsEngine"),g=t("../physics/bodies/Particle"),y=t("../physics/constraints/Snap"),v=t("../math/Vector");e.SUPPORTS_MULTIPLE=3,e.DEFAULT_OPTIONS={period:100,dampingRatio:.2,velocity:0},e.prototype.reset=function(t,i){this._dimensions=t instanceof Array?t.length:0,this.initState.set(t),h.call(this,t),s.call(this,t),i&&c.call(this,i),l.call(this,void 0)},e.prototype.getVelocity=function(){return u.call(this)},e.prototype.setVelocity=function(t){this.call(this,c(t))},e.prototype.isActive=function(){return!this.PE.isSleeping()},e.prototype.halt=function(){this.set(this.get())},e.prototype.get=function(){return d.call(this),p.call(this)},e.prototype.set=function(t,i,e){return i?(this._dimensions=t instanceof Array?t.length:0,r.call(this),f.call(this,i),s.call(this,t),l.call(this,e),void 0):(this.reset(t),e&&e(),void 0)},i.exports=e},{"../math/Vector":41,"../physics/PhysicsEngine":48,"../physics/bodies/Particle":51,"../physics/constraints/Snap":58}],87:[function(t,i){function e(t){t=t||0,this.endState=new v(t),this.initState=new v,this._dimensions=void 0,this._restTolerance=1e-10,this._absRestTolerance=this._restTolerance,this._callback=void 0,this.PE=new _,this.spring=new y({anchor:this.endState}),this.particle=new g,this.PE.addBody(this.particle),this.PE.attach(this.spring,this.particle)}function n(){return this.particle.getEnergy()+this.spring.getEnergy([this.particle])}function o(t){this.particle.setPosition(t)}function s(t){this.particle.setVelocity(t)}function r(){return 0===this._dimensions?this.particle.getPosition1D():this.particle.getPosition()}function a(){return 0===this._dimensions?this.particle.getVelocity1D():this.particle.getVelocity()}function h(t){this._callback=t}function c(){this.PE.wake()}function p(){this.PE.sleep()}function u(){if(this.PE.isSleeping()){if(this._callback){var t=this._callback;this._callback=void 0,t()}}else n.call(this)<this._absRestTolerance&&(o.call(this,this.endState),s.call(this,[0,0,0]),p.call(this))}function l(t){var i=e.DEFAULT_OPTIONS;void 0===t.period&&(t.period=i.period),void 0===t.dampingRatio&&(t.dampingRatio=i.dampingRatio),void 0===t.velocity&&(t.velocity=i.velocity),t.period<150&&(t.period=150,console.warn("The period of a SpringTransition is capped at 150 ms. Use a SnapTransition for faster transitions")),this.spring.setOptions({period:t.period,dampingRatio:t.dampingRatio}),s.call(this,t.velocity)}function f(){var t=this.endState.sub(this.initState).normSquared();
this._absRestTolerance=0===t?this._restTolerance:this._restTolerance*t}function d(t){this.endState.set(t),f.call(this)}var _=t("../physics/PhysicsEngine"),g=t("../physics/bodies/Particle"),y=t("../physics/forces/Spring"),v=t("../math/Vector");e.SUPPORTS_MULTIPLE=3,e.DEFAULT_OPTIONS={period:300,dampingRatio:.5,velocity:0},e.prototype.reset=function(t,i){this._dimensions=t instanceof Array?t.length:0,this.initState.set(t),o.call(this,t),d.call(this,t),i&&s.call(this,i),h.call(this,void 0)},e.prototype.getVelocity=function(){return a.call(this)},e.prototype.setVelocity=function(t){this.call(this,s(t))},e.prototype.isActive=function(){return!this.PE.isSleeping()},e.prototype.halt=function(){this.set(this.get())},e.prototype.get=function(){return u.call(this),r.call(this)},e.prototype.set=function(t,i,e){return i?(this._dimensions=t instanceof Array?t.length:0,c.call(this),l.call(this,i),d.call(this,t),h.call(this,e),void 0):(this.reset(t),e&&e(),void 0)},i.exports=e},{"../math/Vector":41,"../physics/PhysicsEngine":48,"../physics/bodies/Particle":51,"../physics/forces/Spring":68}],88:[function(t,i){function e(t){this.currentAction=null,this.actionQueue=[],this.callbackQueue=[],this.state=0,this.velocity=void 0,this._callback=void 0,this._engineInstance=null,this._currentMethod=null,this.set(t)}function n(){if(this._callback){var t=this._callback;this._callback=void 0,t()}if(this.actionQueue.length<=0)return this.set(this.get()),void 0;this.currentAction=this.actionQueue.shift(),this._callback=this.callbackQueue.shift();var i=null,e=this.currentAction[0],a=this.currentAction[1];a instanceof Object&&a.method?(i=a.method,"string"==typeof i&&(i=r[i])):i=s,this._currentMethod!==i&&(this._engineInstance=!(e instanceof Object)||i.SUPPORTS_MULTIPLE===!0||e.length<=i.SUPPORTS_MULTIPLE?new i:new o(i),this._currentMethod=i),this._engineInstance.reset(this.state,this.velocity),void 0!==this.velocity&&(a.velocity=this.velocity),this._engineInstance.set(e,a,n.bind(this))}var o=t("./MultipleTransition"),s=t("./TweenTransition"),r={};e.register=function(t){var i=!0;for(var n in t)e.registerMethod(n,t[n])||(i=!1);return i},e.registerMethod=function(t,i){return t in r?!1:(r[t]=i,!0)},e.unregisterMethod=function(t){return t in r?(delete r[t],!0):!1},e.prototype.set=function(t,i,e){if(!i)return this.reset(t),e&&e(),this;var o=[t,i];return this.actionQueue.push(o),this.callbackQueue.push(e),this.currentAction||n.call(this),this},e.prototype.reset=function(t,i){this._currentMethod=null,this._engineInstance=null,this._callback=void 0,this.state=t,this.velocity=i,this.currentAction=null,this.actionQueue=[],this.callbackQueue=[]},e.prototype.delay=function(t,i){var e;return e=this.actionQueue.length?this.actionQueue[this.actionQueue.length-1][0]:this.currentAction?this.currentAction[0]:this.get(),this.set(e,{duration:t,curve:function(){return 0}},i)},e.prototype.get=function(t){return this._engineInstance&&(this._engineInstance.getVelocity&&(this.velocity=this._engineInstance.getVelocity()),this.state=this._engineInstance.get(t)),this.state},e.prototype.isActive=function(){return!!this.currentAction},e.prototype.halt=function(){return this.set(this.get())},i.exports=e},{"./MultipleTransition":85,"./TweenTransition":90}],89:[function(t,i){function e(t){this._final=r.identity.slice(),this._finalTranslate=[0,0,0],this._finalRotate=[0,0,0],this._finalSkew=[0,0,0],this._finalScale=[1,1,1],this.translate=new s(this._finalTranslate),this.rotate=new s(this._finalRotate),this.skew=new s(this._finalSkew),this.scale=new s(this._finalScale),t&&this.set(t)}function n(){return r.build({translate:this.translate.get(),rotate:this.rotate.get(),skew:this.skew.get(),scale:this.scale.get()})}function o(){return r.build({translate:this._finalTranslate,rotate:this._finalRotate,skew:this._finalSkew,scale:this._finalScale})}var s=t("./Transitionable"),r=t("../core/Transform"),a=t("../utilities/Utility");e.prototype.setTranslate=function(t,i,e){return this._finalTranslate=t,this._final=o.call(this),this.translate.set(t,i,e),this},e.prototype.setScale=function(t,i,e){return this._finalScale=t,this._final=o.call(this),this.scale.set(t,i,e),this},e.prototype.setRotate=function(t,i,e){return this._finalRotate=t,this._final=o.call(this),this.rotate.set(t,i,e),this},e.prototype.setSkew=function(t,i,e){return this._finalSkew=t,this._final=o.call(this),this.skew.set(t,i,e),this},e.prototype.set=function(t,i,e){var n=r.interpret(t);this._finalTranslate=n.translate,this._finalRotate=n.rotate,this._finalSkew=n.skew,this._finalScale=n.scale,this._final=t;var o=e?a.after(4,e):null;return this.translate.set(n.translate,i,o),this.rotate.set(n.rotate,i,o),this.skew.set(n.skew,i,o),this.scale.set(n.scale,i,o),this},e.prototype.setDefaultTransition=function(t){this.translate.setDefault(t),this.rotate.setDefault(t),this.skew.setDefault(t),this.scale.setDefault(t)},e.prototype.get=function(){return this.isActive()?n.call(this):this._final},e.prototype.getFinal=function(){return this._final},e.prototype.isActive=function(){return this.translate.isActive()||this.rotate.isActive()||this.scale.isActive()||this.skew.isActive()},e.prototype.halt=function(){return this.translate.halt(),this.rotate.halt(),this.skew.halt(),this.scale.halt(),this._final=this.get(),this._finalTranslate=this.translate.get(),this._finalRotate=this.rotate.get(),this._finalSkew=this.skew.get(),this._finalScale=this.scale.get(),this},i.exports=e},{"../core/Transform":15,"../utilities/Utility":95,"./Transitionable":88}],90:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),t&&this.setOptions(t),this._startTime=0,this._startValue=0,this._updateTime=0,this._endValue=0,this._curve=void 0,this._duration=0,this._active=!1,this._callback=void 0,this.state=0,this.velocity=void 0}function n(t,i,e){return(1-e)*t+e*i}function o(t){return t instanceof Object?t instanceof Array?t.slice(0):Object.create(t):t}function s(t,i){var n={curve:i.curve};return i.duration&&(n.duration=i.duration),i.speed&&(n.speed=i.speed),t instanceof Object&&(void 0!==t.duration&&(n.duration=t.duration),t.curve&&(n.curve=t.curve),t.speed&&(n.speed=t.speed)),"string"==typeof n.curve&&(n.curve=e.getCurve(n.curve)),n}function r(t,i,e,n,o){var s,r=1e-7,a=(e(o)-e(o-r))/r;if(t instanceof Array){s=[];for(var h=0;h<t.length;h++)s[h]="number"==typeof t[h]?a*(t[h]-i[h])/n:0}else s=a*(t-i)/n;return s}function a(t,i,e){var o;if(t instanceof Array){o=[];for(var s=0;s<t.length;s++)o[s]="number"==typeof t[s]?n(t[s],i[s],e):t[s]}else o=n(t,i,e);return o}e.Curves={linear:function(t){return t},easeIn:function(t){return t*t},easeOut:function(t){return t*(2-t)},easeInOut:function(t){return.5>=t?2*t*t:-2*t*t+4*t-1},easeOutBounce:function(t){return t*(3-2*t)},spring:function(t){return(1-t)*Math.sin(6*Math.PI*t)+t}},e.SUPPORTS_MULTIPLE=!0,e.DEFAULT_OPTIONS={curve:e.Curves.linear,duration:500,speed:0};var h={};e.registerCurve=function(t,i){return h[t]?!1:(h[t]=i,!0)},e.unregisterCurve=function(t){return h[t]?(delete h[t],!0):!1},e.getCurve=function(t){var i=h[t];if(void 0!==i)return i;throw new Error("curve not registered")},e.getCurves=function(){return h},e.prototype.setOptions=function(t){void 0!==t.curve&&(this.options.curve=t.curve),void 0!==t.duration&&(this.options.duration=t.duration),void 0!==t.speed&&(this.options.speed=t.speed)},e.prototype.set=function(t,i,e){if(!i)return this.reset(t),e&&e(),void 0;if(this._startValue=o(this.get()),i=s(i,this.options),i.speed){var n=this._startValue;if(n instanceof Object){var r=0;for(var a in n)r+=(t[a]-n[a])*(t[a]-n[a]);i.duration=Math.sqrt(r)/i.speed}else i.duration=Math.abs(t-n)/i.speed}this._startTime=Date.now(),this._endValue=o(t),this._startVelocity=o(i.velocity),this._duration=i.duration,this._curve=i.curve,this._active=!0,this._callback=e},e.prototype.reset=function(t,i){if(this._callback){var e=this._callback;this._callback=void 0,e()}this.state=o(t),this.velocity=o(i),this._startTime=0,this._duration=0,this._updateTime=0,this._startValue=this.state,this._startVelocity=this.velocity,this._endValue=this.state,this._active=!1},e.prototype.getVelocity=function(){return this.velocity},e.prototype.get=function(t){return this.update(t),this.state},e.prototype.update=function(t){if(this._active){if(t||(t=Date.now()),!(this._updateTime>=t)){this._updateTime=t;var i=t-this._startTime;if(i>=this._duration)this.state=this._endValue,this.velocity=r(this.state,this._startValue,this._curve,this._duration,1),this._active=!1;else if(0>i)this.state=this._startValue,this.velocity=this._startVelocity;else{var e=i/this._duration;this.state=a(this._startValue,this._endValue,this._curve(e)),this.velocity=r(this.state,this._startValue,this._curve,this._duration,e)}}}else if(this._callback){var n=this._callback;this._callback=void 0,n()}},e.prototype.isActive=function(){return this._active},e.prototype.halt=function(){this.reset(this.get())},e.registerCurve("linear",e.Curves.linear),e.registerCurve("easeIn",e.Curves.easeIn),e.registerCurve("easeOut",e.Curves.easeOut),e.registerCurve("easeInOut",e.Curves.easeInOut),e.registerCurve("easeOutBounce",e.Curves.easeOutBounce),e.registerCurve("spring",e.Curves.spring),e.customCurve=function(t,i){return t=t||0,i=i||0,function(e){return t*e+(-2*t-i+3)*e*e+(t+i-2)*e*e*e}},i.exports=e},{}],91:[function(t,i){function e(t){t=t||0,this.endState=new m(t),this.initState=new m,this.spring=new y({anchor:this.endState}),this.wall=new v,this._restTolerance=1e-10,this._dimensions=1,this._absRestTolerance=this._restTolerance,this._callback=void 0,this.PE=new _,this.particle=new g,this.PE.addBody(this.particle),this.PE.attach([this.wall,this.spring],this.particle)}function n(){return this.particle.getEnergy()+this.spring.getEnergy([this.particle])}function o(){var t=this.endState.sub(this.initState).normSquared();this._absRestTolerance=0===t?this._restTolerance:this._restTolerance*t}function s(){this.PE.wake()}function r(){this.PE.sleep()}function a(t){this.endState.set(t);var i=this.endState.sub(this.initState).norm();this.wall.setOptions({distance:this.endState.norm(),normal:0===i?this.particle.velocity.normalize(-1):this.endState.sub(this.initState).normalize(-1)}),o.call(this)}function h(t){this.particle.position.set(t)}function c(t){this.particle.velocity.set(t)}function p(){return 0===this._dimensions?this.particle.getPosition1D():this.particle.getPosition()}function u(){return 0===this._dimensions?this.particle.getVelocity1D():this.particle.getVelocity()}function l(t){this._callback=t}function f(){if(this.PE.isSleeping()){if(this._callback){var t=this._callback;this._callback=void 0,t()}}else{var i=n.call(this);i<this._absRestTolerance&&(r.call(this),h.call(this,this.endState),c.call(this,[0,0,0]))}}function d(t){var i=e.DEFAULT_OPTIONS;void 0===t.period&&(t.period=i.period),void 0===t.dampingRatio&&(t.dampingRatio=i.dampingRatio),void 0===t.velocity&&(t.velocity=i.velocity),void 0===t.restitution&&(t.restitution=i.restitution),void 0===t.drift&&(t.drift=v.DEFAULT_OPTIONS.drift),void 0===t.slop&&(t.slop=v.DEFAULT_OPTIONS.slop),this.spring.setOptions({period:t.period,dampingRatio:t.dampingRatio}),this.wall.setOptions({restitution:t.restitution,drift:t.drift,slop:t.slop}),c.call(this,t.velocity)}var _=t("../physics/PhysicsEngine"),g=t("../physics/bodies/Particle"),y=t("../physics/forces/Spring"),v=t("../physics/constraints/Wall"),m=t("../math/Vector");e.SUPPORTS_MULTIPLE=3,e.DEFAULT_OPTIONS={period:300,dampingRatio:.5,velocity:0,restitution:.5},e.prototype.reset=function(t,i){this._dimensions=t instanceof Array?t.length:0,this.initState.set(t),h.call(this,t),i&&c.call(this,i),a.call(this,t),l.call(this,void 0)},e.prototype.getVelocity=function(){return u.call(this)},e.prototype.setVelocity=function(t){this.call(this,c(t))},e.prototype.isActive=function(){return!this.PE.isSleeping()},e.prototype.halt=function(){this.set(this.get())},e.prototype.get=function(){return f.call(this),p.call(this)},e.prototype.set=function(t,i,e){return i?(this._dimensions=t instanceof Array?t.length:0,s.call(this),d.call(this,i),a.call(this,t),l.call(this,e),void 0):(this.reset(t),e&&e(),void 0)},i.exports=e},{"../math/Vector":41,"../physics/PhysicsEngine":48,"../physics/bodies/Particle":51,"../physics/constraints/Wall":60,"../physics/forces/Spring":68}],92:[function(t,i){i.exports={CachedMap:t("./CachedMap"),Easing:t("./Easing"),MultipleTransition:t("./MultipleTransition"),SnapTransition:t("./SnapTransition"),SpringTransition:t("./SpringTransition"),Transitionable:t("./Transitionable"),TransitionableTransform:t("./TransitionableTransform"),TweenTransition:t("./TweenTransition"),WallTransition:t("./WallTransition")}},{"./CachedMap":83,"./Easing":84,"./MultipleTransition":85,"./SnapTransition":86,"./SpringTransition":87,"./Transitionable":88,"./TransitionableTransform":89,"./TweenTransition":90,"./WallTransition":91}],93:[function(t,i){var e={0:48,1:49,2:50,3:51,4:52,5:53,6:54,7:55,8:56,9:57,a:97,b:98,c:99,d:100,e:101,f:102,g:103,h:104,i:105,j:106,k:107,l:108,m:109,n:110,o:111,p:112,q:113,r:114,s:115,t:116,u:117,v:118,w:119,x:120,y:121,z:122,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,ENTER:13,LEFT_ARROW:37,RIGHT_ARROW:39,UP_ARROW:38,DOWN_ARROW:40,SPACE:32,SHIFT:16,TAB:9};i.exports=e},{}],94:[function(t,i){function e(t){return c.on(p,t),t}function n(t,i){var n=u(),o=function(){var e=u();e-n>=i&&(t.apply(this,arguments),c.removeListener(p,o))};return e(o)}function o(t,i){var n=u(),o=function(){var e=u();e-n>=i&&(t.apply(this,arguments),n=u())};return e(o)}function s(t,i){if(void 0===i)return void 0;var n=function(){i--,0>=i&&(t.apply(this,arguments),a(n))};return e(n)}function r(t,i){i=i||1;var n=i,o=function(){i--,0>=i&&(t.apply(this,arguments),i=n)};return e(o)}function a(t){c.removeListener(p,t)}function h(t,i){var e,o,s,r,h;return function(){o=this,h=arguments,s=u();var c=function(){var a=u-s;i>a?e=n(c,i-a):(e=null,r=t.apply(o,h))};return a(e),e=n(c,i),r}}var c=t("../core/Engine"),p="prerender",u=window.performance&&window.performance.now?function(){return window.performance.now()}:function(){return Date.now()};i.exports={setTimeout:n,setInterval:o,debounce:h,after:s,every:r,clear:a}},{"../core/Engine":4}],95:[function(t,i){var e={};e.Direction={X:0,Y:1,Z:2},e.after=function(t,i){var e=t;return function(){e--,0===e&&i.apply(this,arguments)}},e.loadURL=function(t,i){var e=new XMLHttpRequest;e.onreadystatechange=function(){4===this.readyState&&i&&i(this.responseText)},e.open("GET",t),e.send()},e.createDocumentFragmentFromHTML=function(t){var i=document.createElement("div");i.innerHTML=t;for(var e=document.createDocumentFragment();i.hasChildNodes();)e.appendChild(i.firstChild);return e},e.clone=function(t){var i;if("object"==typeof t){i=t instanceof Array?[]:{};for(var n in t)if("object"==typeof t[n]&&null!==t[n])if(t[n]instanceof Array){i[n]=new Array(t[n].length);for(var o=0;o<t[n].length;o++)i[n][o]=e.clone(t[n][o])}else i[n]=e.clone(t[n]);else i[n]=t[n]}else i=t;return i},i.exports=e},{}],96:[function(t,i){i.exports={KeyCodes:t("./KeyCodes"),Timer:t("./Timer"),Utility:t("./Utility")}},{"./KeyCodes":93,"./Timer":94,"./Utility":95}],97:[function(t,i){function e(t){this.options=Object.create(this.constructor.DEFAULT_OPTIONS||e.DEFAULT_OPTIONS),this._optionsManager=new s(this.options),t&&this.setOptions(t),this._eventInput=new o,this._eventOutput=new o,o.setInputHandler(this,this._eventInput),o.setOutputHandler(this,this._eventOutput),this._id=n.register(this)}var n=t("../core/Entity");t("../core/Transform");var o=t("../core/EventHandler"),s=t("../core/OptionsManager");e.DEFAULT_OPTIONS={},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},e.prototype.getOptions=function(t){return this._optionsManager.getOptions(t)},e.prototype.render=function(){return this._id},e.prototype.commit=function(){},i.exports=e},{"../core/Entity":5,"../core/EventHandler":7,"../core/OptionsManager":10,"../core/Transform":15}],98:[function(t,i){function e(){c.apply(this,arguments),this.state=new a(0),this._isOpen=!1,this.setOutputFunction(function(t,i,e){var o=n.call(this),r=this.options.direction===h.Direction.X?s.translate(o*i,0,.001*(o-1)*i):s.translate(0,o*i,.001*(o-1)*i),a=t.render();if(this.options.stackRotation){var c=this.options.stackRotation*e*(1-o);a={transform:s.rotateZ(c),origin:[.5,.5],target:a}}return{transform:r,size:t.getSize(),target:a}})}function n(t){return t?this._isOpen?1:0:this.state.get()}function o(t,i,e){this.state.halt(),this.state.set(t,i,e)}var s=t("../core/Transform"),r=t("../core/OptionsManager"),a=t("../transitions/Transitionable"),h=t("../utilities/Utility"),c=t("./SequentialLayout");e.prototype=Object.create(c.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS=r.patch(c.DEFAULT_OPTIONS,{transition:{curve:"easeOutBounce",duration:500},stackRotation:0}),e.prototype.getSize=function(){var t=c.prototype.getSize.apply(this,arguments),i=this._items?this._items.get().getSize():[0,0];i||(i=[0,0]);var e=n.call(this),o=1-e;return[i[0]*o+t[0]*e,i[1]*o+t[1]*e]},e.prototype.isOpen=function(){return this._isOpen},e.prototype.open=function(t){this._isOpen=!0,o.call(this,1,this.options.transition,t)},e.prototype.close=function(t){this._isOpen=!1,o.call(this,0,this.options.transition,t)},e.prototype.toggle=function(t){this._isOpen?this.close(t):this.open(t)},i.exports=e},{"../core/OptionsManager":10,"../core/Transform":15,"../transitions/Transitionable":88,"../utilities/Utility":95,"./SequentialLayout":110}],99:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new p(this.options),t&&this.setOptions(t),this._position=new u(0),this._direction=n(this.options.side),this._orientation=o(this.options.side),this._isOpen=!1,this._cachedLength=0,this.drawer=new h,this.content=new h,this._eventInput=new l,this._eventOutput=new l,l.setInputHandler(this,this._eventInput),l.setOutputHandler(this,this._eventOutput),this._eventInput.on("update",r.bind(this)),this._eventInput.on("end",a.bind(this))}function n(t){var i=e.SIDES;return t===i.LEFT||t===i.RIGHT?f:d}function o(t){var i=e.SIDES;return t===i.LEFT||t===i.TOP?1:-1}function s(t){var i,e=this.options;if(e.drawerLength)i=e.drawerLength;else{var n=t.getSize();i=n?n[this._direction]:e.drawerLength}return this._orientation*i}function r(t){var i,e,n=this.getPosition()+t.delta;this._cachedLength=s.call(this,this.drawer),1===this._orientation?(i=0,e=this._cachedLength):(i=this._cachedLength,e=0),n>e?n=e:i>n&&(n=i),this.setPosition(n)}function a(t){var i=t.velocity,e=this._orientation*this.getPosition(),n=this.options,o=this._orientation*this._cachedLength,s=n.positionThreshold||o/2,r=n.velocityThreshold;if(n.transition instanceof Object&&(n.transition.velocity=t.velocity),0===e)return this._isOpen=!1,void 0;if(e===o)return this._isOpen=!0,void 0;var a=Math.abs(i)>r||!this._isOpen&&e>s||this._isOpen&&s>e;a?this.toggle():this.reset()}var h=t("../core/RenderNode"),c=t("../core/Transform"),p=t("../core/OptionsManager"),u=t("../transitions/Transitionable"),l=t("../core/EventHandler"),f=0,d=1;e.SIDES={LEFT:0,TOP:1,RIGHT:2,BOTTOM:3},e.DEFAULT_OPTIONS={side:e.SIDES.LEFT,drawerLength:0,velocityThreshold:0,positionThreshold:0,transition:!0},e.prototype.setOptions=function(t){this._optionsManager.setOptions(t),void 0!==t.side&&(this._direction=n(t.side),this._orientation=o(t.side))},e.prototype.open=function(t,i){t instanceof Function&&(i=t),void 0===t&&(t=this.options.transition),this._cachedLength=s.call(this,this.drawer),this.setPosition(this._cachedLength,t,i),this._isOpen||(this._isOpen=!0,this._eventOutput.emit("open"))},e.prototype.close=function(t,i){t instanceof Function&&(i=t),void 0===t&&(t=this.options.transition),this.setPosition(0,t,i),this._isOpen&&(this._isOpen=!1,this._eventOutput.emit("close"))},e.prototype.setPosition=function(t,i,e){this._position.isActive()&&this._position.halt(),this._position.set(t,i,e)},e.prototype.getPosition=function(){return this._position.get()},e.prototype.setProgress=function(t,i,e){return this._position.set(t*this._cachedLength,i,e)},e.prototype.getProgress=function(){return this._position.get()/this._cachedLength},e.prototype.toggle=function(t){this._isOpen?this.close(t):this.open(t)},e.prototype.reset=function(t){this._isOpen?this.open(t):this.close(t)},e.prototype.isOpen=function(){return this._isOpen},e.prototype.render=function(){var t=this.getPosition();(!this._isOpen&&0>t&&1===this._orientation||t>0&&-1===this._orientation)&&(t=0,this.setPosition(t));var i=this._direction===f?c.translate(t,0,0):c.translate(0,t,0);return[{transform:c.behind,target:this.drawer.render()},{transform:i,target:this.content.render()}]},i.exports=e},{"../core/EventHandler":7,"../core/OptionsManager":10,"../core/RenderNode":11,"../core/Transform":15,"../transitions/Transitionable":88}],100:[function(t,i){function e(t){this._currentTarget=null,this._size=[void 0,void 0],this._controller=new h(t),this._controller.inTransformFrom(o.create(n.bind(this,1e-4))),this._controller.outTransformFrom(o.create(n.bind(this,-1e-4))),this._eventInput=new r,r.setInputHandler(this,this._eventInput),this._entityId=s.register(this),t&&this.setOptions(t)}function n(t,i){return a.translate(this._size[0]*(1-i),0,t*(1-i))}var o=t("../transitions/CachedMap"),s=t("../core/Entity"),r=t("../core/EventHandler"),a=t("../core/Transform"),h=t("./RenderController");e.prototype.show=function(t){this._currentTarget&&this._eventInput.unpipe(this._currentTarget),this._currentTarget=t,this._currentTarget&&this._currentTarget.trigger&&this._eventInput.pipe(this._currentTarget),this._controller.show.apply(this._controller,arguments)},e.prototype.setOptions=function(t){this._controller.setOptions(t)},e.prototype.render=function(){return this._entityId},e.prototype.commit=function(t){return this._size[0]=t.size[0],this._size[1]=t.size[1],{transform:t.transform,opacity:t.opacity,origin:t.origin,size:t.size,target:this._controller.render()}},i.exports=e},{"../core/Entity":5,"../core/EventHandler":7,"../core/Transform":15,"../transitions/CachedMap":83,"./RenderController":106}],101:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this.optionsManager=new a(this.options),t&&this.setOptions(t),this.id=s.register(this),this._ratios=new c(this.options.ratios),this._nodes=[],this._size=[0,0],this._cachedDirection=null,this._cachedLengths=[],this._cachedTransforms=null,this._ratiosDirty=!1,this._eventOutput=new h,h.setOutputHandler(this,this._eventOutput)}function n(t,i,n){var o,s,a,h,c=0,p=i,u=0;for(this._cachedLengths=[],this._cachedTransforms=[],h=0;h<t.length;h++)s=t[h],a=this._nodes[h],"number"!=typeof s?p-=a.getSize()[n]||0:u+=s;for(h=0;h<t.length;h++)a=this._nodes[h],s=t[h],i="number"==typeof s?p*s/u:a.getSize()[n],o=n===e.DIRECTION_X?r.translate(c,0,0):r.translate(0,c,0),this._cachedTransforms.push(o),this._cachedLengths.push(i),c+=i}function o(t,i){for(var e=0;e<t.length;e++)if("number"!=typeof t[e]&&this._nodes[e].getSize()[i]!==this._cachedLengths[e])return!0;return!1}var s=t("../core/Entity"),r=t("../core/Transform"),a=t("../core/OptionsManager"),h=t("../core/EventHandler"),c=t("../transitions/Transitionable");e.DIRECTION_X=0,e.DIRECTION_Y=1,e.DEFAULT_OPTIONS={direction:e.DIRECTION_X,transition:!1,ratios:[]},e.prototype.render=function(){return this.id},e.prototype.setOptions=function(t){this.optionsManager.setOptions(t)},e.prototype.sequenceFrom=function(t){if(this._nodes=t,0===this._ratios.get().length){for(var i=[],e=0;e<this._nodes.length;e++)i.push(1);this.setRatios(i)}},e.prototype.setRatios=function(t,i,e){void 0===i&&(i=this.options.transition);var n=this._ratios;0===n.get().length&&(i=void 0),n.isActive()&&n.halt(),n.set(t,i,e),this._ratiosDirty=!0},e.prototype.getSize=function(){return this._size},e.prototype.commit=function(t){var i,e=t.size,s=t.transform,a=t.origin,h=t.opacity,c=this._ratios.get(),p=this.options.direction,u=e[p];(u!==this._size[p]||this._ratiosDirty||this._ratios.isActive()||p!==this._cachedDirection||o.call(this,c,p))&&(n.call(this,c,u,p),u!==this._size[p]&&(this._size[0]=e[0],this._size[1]=e[1]),p!==this._cachedDirection&&(this._cachedDirection=p),this._ratiosDirty&&(this._ratiosDirty=!1));for(var l=[],f=0;f<c.length;f++)i=[void 0,void 0],u=this._cachedLengths[f],i[p]=u,l.push({transform:this._cachedTransforms[f],size:i,target:this._nodes[f].render()});return e&&0!==a[0]&&0!==a[1]&&(s=r.moveThen([-e[0]*a[0],-e[1]*a[1],0],s)),{transform:s,size:e,opacity:h,target:l}},i.exports=e},{"../core/Entity":5,"../core/EventHandler":7,"../core/OptionsManager":10,"../core/Transform":15,"../transitions/Transitionable":88}],102:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new s(this.options),t&&this.setOptions(t),this.angle=new o(0),this.frontNode=void 0,this.backNode=void 0,this.flipped=!1}var n=t("../core/Transform"),o=t("../transitions/Transitionable");t("../core/RenderNode");var s=t("../core/OptionsManager");e.DIRECTION_X=0,e.DIRECTION_Y=1;var r=1;e.DEFAULT_OPTIONS={transition:!0,direction:e.DIRECTION_X},e.prototype.flip=function(t,i){var e=this.flipped?0:Math.PI;this.setAngle(e,t,i),this.flipped=!this.flipped},e.prototype.setAngle=function(t,i,e){void 0===i&&(i=this.options.transition),this.angle.isActive()&&this.angle.halt(),this.angle.set(t,i,e)},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},e.prototype.setFront=function(t){this.frontNode=t},e.prototype.setBack=function(t){this.backNode=t},e.prototype.render=function(){var t,i,o=this.angle.get();this.options.direction===e.DIRECTION_X?(t=n.rotateY(o),i=n.rotateY(o+Math.PI)):(t=n.rotateX(o),i=n.rotateX(o+Math.PI));var s=[];return this.frontNode&&s.push({transform:t,target:this.frontNode.render()}),this.backNode&&s.push({transform:n.moveThen([0,0,r],i),target:this.backNode.render()}),s},i.exports=e},{"../core/OptionsManager":10,"../core/RenderNode":11,"../core/Transform":15,"../transitions/Transitionable":88}],103:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this.optionsManager=new u(this.options),t&&this.setOptions(t),this.id=r.register(this),this._modifiers=[],this._states=[],this._contextSizeCache=[0,0],this._dimensionsCache=[0,0],this._activeCount=0,this._eventOutput=new c,c.setOutputHandler(this,this._eventOutput)}function n(t,i,e){var n=[t[0],t[1]];n[0]-=this.options.gutterSize[0]*(i-1),n[1]-=this.options.gutterSize[1]*(e-1);for(var r,a=Math.round(n[1]/e),h=Math.round(n[0]/i),c=0,p=0,u=0;e>u;u++){r=0;for(var l=0;i>l;l++)void 0===this._modifiers[p]?o.call(this,p,[h,a],[r,c,0],1):s.call(this,p,[h,a],[r,c,0],1),p++,r+=h+this.options.gutterSize[0];c+=a+this.options.gutterSize[1]}for(this._dimensionsCache=[this.options.dimensions[0],this.options.dimensions[1]],this._contextSizeCache=[t[0],t[1]],this._activeCount=e*i,u=this._activeCount;u<this._modifiers.length;u++)s.call(this,u,[Math.round(h),Math.round(a)],[0,0],0);this._eventOutput.emit("reflow")}function o(t,i,e,n){var o={transform:new f(a.translate.apply(null,e)),opacity:new l(n),size:new l(i)},s=new p({transform:o.transform,opacity:o.opacity,size:o.size});this._states[t]=o,this._modifiers[t]=s}function s(t,i,e,n){var o=this._states[t],s=o.size,r=o.opacity,a=o.transform,h=this.options.transition;a.halt(),r.halt(),s.halt(),a.setTranslate(e,h),s.set(i,h),r.set(n,h)}var r=t("../core/Entity");t("../core/RenderNode");var a=t("../core/Transform"),h=t("../core/ViewSequence"),c=t("../core/EventHandler"),p=t("../core/Modifier"),u=t("../core/OptionsManager"),l=t("../transitions/Transitionable"),f=t("../transitions/TransitionableTransform");e.DEFAULT_OPTIONS={dimensions:[1,1],transition:!1,gutterSize:[0,0]},e.prototype.render=function(){return this.id},e.prototype.setOptions=function(t){return this.optionsManager.setOptions(t)},e.prototype.sequenceFrom=function(t){t instanceof Array&&(t=new h(t)),this.sequence=t},e.prototype.getSize=function(){return this._contextSizeCache},e.prototype.commit=function(t){var i=t.transform,e=t.opacity,o=t.origin,s=t.size,r=this.options.dimensions[0],h=this.options.dimensions[1];(s[0]!==this._contextSizeCache[0]||s[1]!==this._contextSizeCache[1]||r!==this._dimensionsCache[0]||h!==this._dimensionsCache[1])&&n.call(this,s,r,h);for(var c=this.sequence,p=[],u=0;c&&u<this._modifiers.length;){var l=c.get(),f=this._modifiers[u];u>=this._activeCount&&this._states[u].opacity.isActive()&&(this._modifiers.splice(u,1),this._states.splice(u,1)),l&&p.push(f.modify({origin:o,target:l.render()})),c=c.getNext(),u++}return s&&(i=a.moveThen([-s[0]*o[0],-s[1]*o[1],0],i)),{transform:i,opacity:e,size:s,target:p}},i.exports=e},{"../core/Entity":5,"../core/EventHandler":7,"../core/Modifier":9,"../core/OptionsManager":10,"../core/RenderNode":11,"../core/Transform":15,"../core/ViewSequence":17,"../transitions/Transitionable":88,"../transitions/TransitionableTransform":89}],104:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new c(this.options),t&&this.setOptions(t),this._entityId=r.register(this),this.header=new a,this.footer=new a,this.content=new a}function n(t,i){var e=t.getSize();return e?e[this.options.direction]:i}function o(t){return this.options.direction===e.DIRECTION_X?h.translate(t,0,0):h.translate(0,t,0)}function s(t,i){return this.options.direction===e.DIRECTION_X?[t,i[1]]:[i[0],t]}var r=t("../core/Entity"),a=t("../core/RenderNode"),h=t("../core/Transform"),c=t("../core/OptionsManager");e.DIRECTION_X=0,e.DIRECTION_Y=1,e.DEFAULT_OPTIONS={direction:e.DIRECTION_Y,headerSize:void 0,footerSize:void 0,defaultHeaderSize:0,defaultFooterSize:0},e.prototype.render=function(){return this._entityId},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},e.prototype.commit=function(t){var i=t.transform,e=t.origin,r=t.size,a=t.opacity,c=void 0!==this.options.headerSize?this.options.headerSize:n.call(this,this.header,this.options.defaultHeaderSize),p=void 0!==this.options.footerSize?this.options.footerSize:n.call(this,this.footer,this.options.defaultFooterSize),u=r[this.options.direction]-c-p;r&&(i=h.moveThen([-r[0]*e[0],-r[1]*e[1],0],i));var l=[{size:s.call(this,c,r),target:this.header.render()},{transform:o.call(this,c),size:s.call(this,u,r),target:this.content.render()},{transform:o.call(this,c+u),size:s.call(this,p,r),target:this.footer.render()}];return{transform:i,opacity:a,size:r,target:l}},i.exports=e},{"../core/Entity":5,"../core/OptionsManager":10,"../core/RenderNode":11,"../core/Transform":15}],105:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new a(this.options),t&&this.setOptions(t),this._showing=!1,this.nodes=[],this.transforms=[],this.states=[]}var n=t("../core/Transform"),o=t("../core/Modifier"),s=t("../core/RenderNode"),r=t("../utilities/Utility"),a=t("../core/OptionsManager"),h=t("../transitions/Transitionable"),c=t("../transitions/TransitionableTransform");e.DEFAULT_OPTIONS={inTransform:n.scale(.001,.001,.001),inOpacity:0,inOrigin:[.5,.5],inAlign:[.5,.5],outTransform:n.scale(.001,.001,.001),outOpacity:0,outOrigin:[.5,.5],outAlign:[.5,.5],showTransform:n.identity,showOpacity:1,showOrigin:[.5,.5],showAlign:[.5,.5],inTransition:!0,outTransition:!0,overlap:!1},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},e.prototype.show=function(t,i,e){if(!t)return this.hide(e);if(i instanceof Function&&(e=i,i=void 0),this._showing){if(!this.options.overlap)return this.hide(this.show.bind(this,t,i,e));this.hide()}this._showing=!0;var n={transform:new c(this.options.inTransform),origin:new h(this.options.inOrigin),align:new h(this.options.inAlign),opacity:new h(this.options.inOpacity)},a=new o({transform:n.transform,opacity:n.opacity,origin:n.origin,align:n.align}),p=new s;p.add(a).add(t),this.nodes.push(p),this.states.push(n),this.transforms.push(a);var u=e?r.after(3,e):void 0;i||(i=this.options.inTransition),n.transform.set(this.options.showTransform,i,u),n.opacity.set(this.options.showOpacity,i,u),n.origin.set(this.options.showOrigin,i,u),n.align.set(this.options.showAlign,i,u)
},e.prototype.hide=function(t,i){if(this._showing){this._showing=!1,t instanceof Function&&(i=t,t=void 0);var e=this.nodes[this.nodes.length-1],n=this.transforms[this.transforms.length-1],o=this.states[this.states.length-1],s=r.after(3,function(){this.nodes.splice(this.nodes.indexOf(e),1),this.states.splice(this.states.indexOf(o),1),this.transforms.splice(this.transforms.indexOf(n),1),i&&i.call(this)}.bind(this));t||(t=this.options.outTransition),o.transform.set(this.options.outTransform,t,s),o.opacity.set(this.options.outOpacity,t,s),o.origin.set(this.options.outOrigin,t,s),o.align.set(this.options.outAlign,t,s)}},e.prototype.render=function(){for(var t=[],i=0;i<this.nodes.length;i++)t.push(this.nodes[i].render());return t},i.exports=e},{"../core/Modifier":9,"../core/OptionsManager":10,"../core/RenderNode":11,"../core/Transform":15,"../transitions/Transitionable":88,"../transitions/TransitionableTransform":89,"../utilities/Utility":95}],106:[function(t,i){function e(){h.apply(this,arguments),this._showing=-1,this._outgoingRenderables=[],this._nextRenderable=null,this._renderables=[],this._nodes=[],this._modifiers=[],this._states=[],this.inTransformMap=e.DefaultMap.transform,this.inOpacityMap=e.DefaultMap.opacity,this.inOriginMap=e.DefaultMap.origin,this.inAlignMap=e.DefaultMap.align,this.outTransformMap=e.DefaultMap.transform,this.outOpacityMap=e.DefaultMap.opacity,this.outOriginMap=e.DefaultMap.origin,this.outAlignMap=e.DefaultMap.align,this._output=[]}function n(t,i){return t(i.get())}var o=t("../core/Modifier"),s=t("../core/RenderNode"),r=t("../core/Transform"),a=t("../transitions/Transitionable"),h=t("../core/View");e.prototype=Object.create(h.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={inTransition:!0,outTransition:!0,overlap:!0},e.DefaultMap={transform:function(){return r.identity},opacity:function(t){return t},origin:null,align:null},e.prototype.inTransformFrom=function(t){if(t instanceof Function)this.inTransformMap=t;else{if(!t||!t.get)throw new Error("inTransformFrom takes only function or getter object");this.inTransformMap=t.get.bind(t)}return this},e.prototype.inOpacityFrom=function(t){if(t instanceof Function)this.inOpacityMap=t;else{if(!t||!t.get)throw new Error("inOpacityFrom takes only function or getter object");this.inOpacityMap=t.get.bind(t)}return this},e.prototype.inOriginFrom=function(t){if(t instanceof Function)this.inOriginMap=t;else{if(!t||!t.get)throw new Error("inOriginFrom takes only function or getter object");this.inOriginMap=t.get.bind(t)}return this},e.prototype.inAlignFrom=function(t){if(t instanceof Function)this.inAlignMap=t;else{if(!t||!t.get)throw new Error("inAlignFrom takes only function or getter object");this.inAlignMap=t.get.bind(t)}return this},e.prototype.outTransformFrom=function(t){if(t instanceof Function)this.outTransformMap=t;else{if(!t||!t.get)throw new Error("outTransformFrom takes only function or getter object");this.outTransformMap=t.get.bind(t)}return this},e.prototype.outOpacityFrom=function(t){if(t instanceof Function)this.outOpacityMap=t;else{if(!t||!t.get)throw new Error("outOpacityFrom takes only function or getter object");this.outOpacityMap=t.get.bind(t)}return this},e.prototype.outOriginFrom=function(t){if(t instanceof Function)this.outOriginMap=t;else{if(!t||!t.get)throw new Error("outOriginFrom takes only function or getter object");this.outOriginMap=t.get.bind(t)}return this},e.prototype.outAlignFrom=function(t){if(t instanceof Function)this.outAlignMap=t;else{if(!t||!t.get)throw new Error("outAlignFrom takes only function or getter object");this.outAlignMap=t.get.bind(t)}return this},e.prototype.show=function(t,i,e){if(!t)return this.hide(e);if(i instanceof Function&&(e=i,i=null),this._showing>=0){if(!this.options.overlap)return this._nextRenderable?this._nextRenderable=t:(this._nextRenderable=t,this.hide(function(){this._nextRenderable===t&&this.show(this._nextRenderable,e),this._nextRenderable=null})),void 0;this.hide()}var r=null,h=this._renderables.indexOf(t);if(h>=0){this._showing=h,r=this._states[h],r.halt();var c=this._outgoingRenderables.indexOf(t);c>=0&&this._outgoingRenderables.splice(c,1)}else{r=new a(0);var p=new o({transform:this.inTransformMap?n.bind(this,this.inTransformMap,r):null,opacity:this.inOpacityMap?n.bind(this,this.inOpacityMap,r):null,origin:this.inOriginMap?n.bind(this,this.inOriginMap,r):null,align:this.inAlignMap?n.bind(this,this.inAlignMap,r):null}),u=new s;u.add(p).add(t),this._showing=this._nodes.length,this._nodes.push(u),this._modifiers.push(p),this._states.push(r),this._renderables.push(t)}i||(i=this.options.inTransition),r.set(1,i,e)},e.prototype.hide=function(t,i){if(!(this._showing<0)){var e=this._showing;this._showing=-1,t instanceof Function&&(i=t,t=void 0);var o=this._nodes[e],s=this._modifiers[e],r=this._states[e],a=this._renderables[e];s.transformFrom(this.outTransformMap?n.bind(this,this.outTransformMap,r):null),s.opacityFrom(this.outOpacityMap?n.bind(this,this.outOpacityMap,r):null),s.originFrom(this.outOriginMap?n.bind(this,this.outOriginMap,r):null),s.alignFrom(this.outAlignMap?n.bind(this,this.outAlignMap,r):null),this._outgoingRenderables.indexOf(a)<0&&this._outgoingRenderables.push(a),t||(t=this.options.outTransition),r.halt(),r.set(0,t,function(t,e,n,o){if(this._outgoingRenderables.indexOf(o)>=0){var s=this._nodes.indexOf(t);this._nodes.splice(s,1),this._modifiers.splice(s,1),this._states.splice(s,1),this._renderables.splice(s,1),this._outgoingRenderables.splice(this._outgoingRenderables.indexOf(o),1),this._showing>=s&&this._showing--}i&&i.call(this)}.bind(this,o,s,r,a))}},e.prototype.render=function(){var t=this._output;t.length>this._nodes.length&&t.splice(this._nodes.length);for(var i=0;i<this._nodes.length;i++)t[i]=this._nodes[i].render();return t},i.exports=e},{"../core/Modifier":9,"../core/RenderNode":11,"../core/Transform":15,"../core/View":16,"../transitions/Transitionable":88}],107:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new r(this.options),t&&this.setOptions(t),this.container=new n(this.options.container),this.scrollview=new s(this.options.scrollview),this.container.add(this.scrollview),this._eventInput=new o,o.setInputHandler(this,this._eventInput),this._eventInput.pipe(this.scrollview),this._eventOutput=new o,o.setOutputHandler(this,this._eventOutput),this.container.pipe(this._eventOutput),this.scrollview.pipe(this._eventOutput)}var n=t("../surfaces/ContainerSurface"),o=t("../core/EventHandler"),s=t("./Scrollview");t("../utilities/Utility");var r=t("../core/OptionsManager");e.DEFAULT_OPTIONS={container:{properties:{overflow:"hidden"}},scrollview:{}},e.prototype.setOptions=function(t){return this._optionsManager.setOptions(t)},e.prototype.sequenceFrom=function(){return this.scrollview.sequenceFrom.apply(this.scrollview,arguments)},e.prototype.getSize=function(){return this.container.getSize.apply(this.container,arguments)},e.prototype.render=function(){return this.container.render()},i.exports=e},{"../core/EventHandler":7,"../core/OptionsManager":10,"../surfaces/ContainerSurface":75,"../utilities/Utility":95,"./Scrollview":109}],108:[function(t,i){function e(t){this.options=Object.create(this.constructor.DEFAULT_OPTIONS),this._optionsManager=new c(this.options),t&&this._optionsManager.setOptions(t),this._node=null,this._position=0,this._positionOffset=0,this._positionGetter=null,this._outputFunction=null,this._masterOutputFunction=null,this.outputFrom(),this._onEdge=0,this.group=new h,this.group.add({render:r.bind(this)}),this._entityId=a.register(this),this._size=[void 0,void 0],this._contextSize=[void 0,void 0],this._eventInput=new f,this._eventOutput=new f,f.setInputHandler(this,this._eventInput),f.setOutputHandler(this,this._eventOutput)}function n(t){t||(t=this._contextSize);var i=this.options.direction;return void 0===t[i]?this._contextSize[i]:t[i]}function o(t,i,e){var o=t.getSize?t.getSize():this._contextSize,s=this._outputFunction(i);return e.push({transform:s,target:t.render()}),n.call(this,o)}function s(){return void 0!==this.options.clipSize?this.options.clipSize:this._contextSize[this.options.direction]>this.getCumulativeSize()[this.options.direction]?n.call(this,this.getCumulativeSize()):n.call(this,this._contextSize)}function r(){for(var t=null,i=this._position,e=[],r=-this._positionOffset,a=s.call(this),h=this._node;h&&r-i<a+this.options.margin;)r+=o.call(this,h,r,e),h=h.getNext?h.getNext():null;var c=this._node,p=n.call(this,c.getSize());if(a>r){for(;c&&a>p;)c=c.getPrevious(),c&&(p+=n.call(this,c.getSize()));for(c=this._node;c&&a>p;)c=c.getNext(),c&&(p+=n.call(this,c.getSize()))}for(!h&&a-d>r-i?1!==this._onEdge&&(this._onEdge=1,this._eventOutput.emit("onEdge",{position:r-a})):!this._node.getPrevious()&&-d>i?-1!==this._onEdge&&(this._onEdge=-1,this._eventOutput.emit("onEdge",{position:0})):0!==this._onEdge&&(this._onEdge=0,this._eventOutput.emit("offEdge")),h=this._node&&this._node.getPrevious?this._node.getPrevious():null,r=-this._positionOffset,h&&(t=h.getSize?h.getSize():this._contextSize,r-=n.call(this,t));h&&r-i>-(a+this.options.margin);)o.call(this,h,r,e),h=h.getPrevious?h.getPrevious():null,h&&(t=h.getSize?h.getSize():this._contextSize,r-=n.call(this,t));return e}var a=t("../core/Entity"),h=t("../core/Group"),c=t("../core/OptionsManager"),p=t("../core/Transform"),u=t("../utilities/Utility"),l=t("../core/ViewSequence"),f=t("../core/EventHandler");e.DEFAULT_OPTIONS={direction:u.Direction.Y,margin:0,clipSize:void 0,groupScroll:!1};var d=0;e.prototype.getCumulativeSize=function(t){return void 0===t&&(t=this._node._.cumulativeSizes.length-1),this._node._.getSize(t)},e.prototype.setOptions=function(t){t.groupScroll!==this.options.groupScroll&&(t.groupScroll?this.group.pipe(this._eventOutput):this.group.unpipe(this._eventOutput)),this._optionsManager.setOptions(t)},e.prototype.onEdge=function(){return this._onEdge},e.prototype.outputFrom=function(t,i){t||(t=function(t){return this.options.direction===u.Direction.X?p.translate(t,0):p.translate(0,t)}.bind(this),i||(i=t)),this._outputFunction=t,this._masterOutputFunction=i?i:function(i){return p.inverse(t(-i))}},e.prototype.positionFrom=function(t){t instanceof Function?this._positionGetter=t:t&&t.get?this._positionGetter=t.get.bind(t):(this._positionGetter=null,this._position=t),this._positionGetter&&(this._position=this._positionGetter.call(this))},e.prototype.sequenceFrom=function(t){t instanceof Array&&(t=new l({array:t})),this._node=t,this._positionOffset=0},e.prototype.getSize=function(t){return t?this._contextSize:this._size},e.prototype.render=function(){return this._node?(this._positionGetter&&(this._position=this._positionGetter.call(this)),this._entityId):null},e.prototype.commit=function(t){var i=t.transform,e=t.opacity,n=t.origin,o=t.size;this.options.clipSize||o[0]===this._contextSize[0]&&o[1]===this._contextSize[1]||(this._onEdge=0,this._contextSize[0]=o[0],this._contextSize[1]=o[1],this.options.direction===u.Direction.X?(this._size[0]=s.call(this),this._size[1]=void 0):(this._size[0]=void 0,this._size[1]=s.call(this)));var r=this._masterOutputFunction(-this._position);return{transform:p.multiply(i,r),size:o,opacity:e,origin:n,target:this.group.render()}},i.exports=e},{"../core/Entity":5,"../core/EventHandler":7,"../core/Group":8,"../core/OptionsManager":10,"../core/Transform":15,"../core/ViewSequence":17,"../utilities/Utility":95}],109:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this._optionsManager=new O(this.options),this._scroller=new T(this.options),this.sync=new b(["scroll","touch"],{direction:this.options.direction,scale:this.options.syncScale,rails:this.options.rails,preventDefault:void 0!==this.options.preventDefault?this.options.preventDefault:this.options.direction!==w.Direction.Y}),this._physicsEngine=new _,this._particle=new g,this._physicsEngine.addBody(this._particle),this.spring=new v({anchor:[0,0,0],period:this.options.edgePeriod,dampingRatio:this.options.edgeDamp}),this.drag=new y({forceFunction:y.FORCE_FUNCTIONS.QUADRATIC,strength:this.options.drag}),this.friction=new y({forceFunction:y.FORCE_FUNCTIONS.LINEAR,strength:this.options.friction}),this._node=null,this._touchCount=0,this._springState=I.NONE,this._onEdge=M.NONE,this._pageSpringPosition=0,this._edgeSpringPosition=0,this._touchVelocity=0,this._earlyEnd=!1,this._needsPaginationCheck=!1,this._displacement=0,this._totalShift=0,this._cachedIndex=0,this._scroller.positionFrom(this.getPosition.bind(this)),this._eventInput=new m,this._eventOutput=new m,this._eventInput.pipe(this.sync),this.sync.pipe(this._eventInput),m.setInputHandler(this,this._eventInput),m.setOutputHandler(this,this._eventOutput),r.call(this),t&&this.setOptions(t)}function n(t){this._touchCount=t.count,void 0===t.count&&(this._touchCount=1),h.call(this),this.setVelocity(0),this._touchVelocity=0,this._earlyEnd=!1}function o(t){var i=-t.velocity,e=-t.delta;if(this._onEdge!==M.NONE&&t.slip&&(0>i&&this._onEdge===M.TOP||i>0&&this._onEdge===M.BOTTOM?this._earlyEnd||(s.call(this,t),this._earlyEnd=!0):this._earlyEnd&&Math.abs(i)>Math.abs(this.getVelocity())&&n.call(this,t)),!this._earlyEnd){if(this._touchVelocity=i,t.slip){var o=this.options.speedLimit;-o>i?i=-o:i>o&&(i=o),this.setVelocity(i);var r=16*o;e>r?e=r:-r>e&&(e=-r)}this.setPosition(this.getPosition()+e),this._displacement+=e,this._springState===I.NONE&&f.call(this)}}function s(t){if(this._touchCount=t.count||0,!this._touchCount){h.call(this),this._onEdge!==M.NONE&&l.call(this,this._edgeSpringPosition,I.EDGE),a.call(this);var i=-t.velocity,e=this.options.speedLimit;t.slip&&(e*=this.options.edgeGrip),-e>i?i=-e:i>e&&(i=e),this.setVelocity(i),this._touchVelocity=0,this._needsPaginationCheck=!0}}function r(){this._eventInput.bindThis(this),this._eventInput.on("start",n),this._eventInput.on("update",o),this._eventInput.on("end",s),this._eventInput.on("resize",function(){this._node._.calculateSize()}.bind(this)),this._scroller.on("onEdge",function(t){this._edgeSpringPosition=t.position,p.call(this,this._scroller.onEdge()),this._eventOutput.emit("onEdge")}.bind(this)),this._scroller.on("offEdge",function(){this.sync.setOptions({scale:this.options.syncScale}),this._onEdge=this._scroller.onEdge(),this._eventOutput.emit("offEdge")}.bind(this)),this._particle.on("update",function(t){this._springState===I.NONE&&f.call(this),this._displacement=t.position.x-this._totalShift}.bind(this)),this._particle.on("end",function(){(!this.options.paginated||this.options.paginated&&this._springState!==I.NONE)&&this._eventOutput.emit("settle")}.bind(this))}function a(){this._springState?this._physicsEngine.attach([this.spring],this._particle):this._physicsEngine.attach([this.drag,this.friction],this._particle)}function h(){this._springState=I.NONE,this._physicsEngine.detachAll()}function c(t){var i=this.options.direction,e=t.getSize();return e?e[i]:this._scroller.getSize()[i]}function p(t){this.sync.setOptions({scale:this.options.edgeGrip}),this._onEdge=t,this._touchCount||this._springState===I.EDGE||l.call(this,this._edgeSpringPosition,I.EDGE),this._springState&&Math.abs(this.getVelocity())<.001&&(h.call(this),a.call(this))}function u(){if(!this._touchCount&&this._springState!==I.EDGE){var t=this.getVelocity();if(!(Math.abs(t)>=this.options.pageStopSpeed)){var i=this.getPosition(),e=Math.abs(t)>this.options.pageSwitchSpeed,n=c.call(this,this._node),o=i>.5*n,s=t>0,r=0>t;this._needsPaginationCheck=!1,o&&!e||e&&s?this.goToNextPage():e&&r?this.goToPreviousPage():l.call(this,0,I.PAGE)}}}function l(t,i){var e;i===I.EDGE?(this._edgeSpringPosition=t,e={anchor:[this._edgeSpringPosition,0,0],period:this.options.edgePeriod,dampingRatio:this.options.edgeDamp}):i===I.PAGE&&(this._pageSpringPosition=t,e={anchor:[this._pageSpringPosition,0,0],period:this.options.pagePeriod,dampingRatio:this.options.pageDamp}),this.spring.setOptions(e),i&&!this._springState&&(h.call(this),this._springState=i,a.call(this)),this._springState=i}function f(){var t=0,i=this.getPosition();i+=(0>i?-.5:.5)>>0;for(var e=c.call(this,this._node),n=this._node.getNext();t+i>=e&&n;)t-=e,this._scroller.sequenceFrom(n),this._node=n,n=this._node.getNext(),e=c.call(this,this._node);for(var o,s=this._node.getPrevious();0>=t+i&&s;)o=c.call(this,s),this._scroller.sequenceFrom(s),this._node=s,t+=o,s=this._node.getPrevious();t&&d.call(this,t),this._node&&(this._node.index!==this._cachedIndex?this.getPosition()<.5*e&&(this._cachedIndex=this._node.index,this._eventOutput.emit("pageChange",{direction:-1,index:this._cachedIndex})):this.getPosition()>.5*e&&(this._cachedIndex=this._node.index+1,this._eventOutput.emit("pageChange",{direction:1,index:this._cachedIndex})))}function d(t){this._edgeSpringPosition+=t,this._pageSpringPosition+=t,this.setPosition(this.getPosition()+t),this._totalShift+=t,this._springState===I.EDGE?this.spring.setOptions({anchor:[this._edgeSpringPosition,0,0]}):this._springState===I.PAGE&&this.spring.setOptions({anchor:[this._pageSpringPosition,0,0]})}var _=t("../physics/PhysicsEngine"),g=t("../physics/bodies/Particle"),y=t("../physics/forces/Drag"),v=t("../physics/forces/Spring"),m=t("../core/EventHandler"),O=t("../core/OptionsManager"),S=t("../core/ViewSequence"),T=t("../views/Scroller"),w=t("../utilities/Utility"),b=t("../inputs/GenericSync"),E=t("../inputs/ScrollSync"),z=t("../inputs/TouchSync");b.register({scroll:E,touch:z});var I={NONE:0,EDGE:1,PAGE:2},M={TOP:-1,NONE:0,BOTTOM:1};e.DEFAULT_OPTIONS={direction:w.Direction.Y,rails:!0,friction:.005,drag:1e-4,edgeGrip:.2,edgePeriod:300,edgeDamp:1,margin:1e3,paginated:!1,pagePeriod:500,pageDamp:.8,pageStopSpeed:10,pageSwitchSpeed:.5,speedLimit:5,groupScroll:!1,syncScale:1},e.prototype.getCurrentIndex=function(){return this._node.index},e.prototype.goToPreviousPage=function(){if(!this._node||this._onEdge===M.TOP)return null;if(this.getPosition()>1&&this._springState===I.NONE)return l.call(this,0,I.PAGE),this._node;var t=this._node.getPrevious();if(t){var i=c.call(this,t);this._scroller.sequenceFrom(t),this._node=t,d.call(this,i),l.call(this,0,I.PAGE)}return t},e.prototype.goToNextPage=function(){if(!this._node||this._onEdge===M.BOTTOM)return null;var t=this._node.getNext();if(t){var i=c.call(this,this._node);this._scroller.sequenceFrom(t),this._node=t,d.call(this,-i),l.call(this,0,I.PAGE)}return t},e.prototype.goToPage=function(t){var i,e=this.getCurrentIndex();if(e>t)for(i=0;e-t>i;i++)this.goToPreviousPage();if(t>e)for(i=0;t-e>i;i++)this.goToNextPage()},e.prototype.outputFrom=function(){return this._scroller.outputFrom.apply(this._scroller,arguments)},e.prototype.getPosition=function(){return this._particle.getPosition1D()},e.prototype.getAbsolutePosition=function(){return this._scroller.getCumulativeSize(this.getCurrentIndex())[this.options.direction]+this.getPosition()},e.prototype.getOffset=e.prototype.getPosition,e.prototype.setPosition=function(t){this._particle.setPosition1D(t)},e.prototype.setOffset=e.prototype.setPosition,e.prototype.getVelocity=function(){return this._touchCount?this._touchVelocity:this._particle.getVelocity1D()},e.prototype.setVelocity=function(t){this._particle.setVelocity1D(t)},e.prototype.setOptions=function(t){void 0!==t.direction&&("x"===t.direction?t.direction=w.Direction.X:"y"===t.direction&&(t.direction=w.Direction.Y)),t.groupScroll!==this.options.groupScroll&&(t.groupScroll?this.subscribe(this._scroller):this.unsubscribe(this._scroller)),this._optionsManager.setOptions(t),this._scroller.setOptions(t),void 0!==t.drag&&this.drag.setOptions({strength:this.options.drag}),void 0!==t.friction&&this.friction.setOptions({strength:this.options.friction}),(void 0!==t.edgePeriod||void 0!==t.edgeDamp)&&this.spring.setOptions({period:this.options.edgePeriod,dampingRatio:this.options.edgeDamp}),(t.rails||void 0!==t.direction||void 0!==t.syncScale||t.preventDefault)&&this.sync.setOptions({rails:this.options.rails,direction:this.options.direction===w.Direction.X?b.DIRECTION_X:b.DIRECTION_Y,scale:this.options.syncScale,preventDefault:this.options.preventDefault})},e.prototype.sequenceFrom=function(t){return t instanceof Array&&(t=new S({array:t,trackSize:!0})),this._node=t,this._scroller.sequenceFrom(t)},e.prototype.getSize=function(){return this._scroller.getSize.apply(this._scroller,arguments)},e.prototype.render=function(){return this.options.paginated&&this._needsPaginationCheck&&u.call(this),this._scroller.render()},i.exports=e},{"../core/EventHandler":7,"../core/OptionsManager":10,"../core/ViewSequence":17,"../inputs/GenericSync":27,"../inputs/ScrollSync":32,"../inputs/TouchSync":33,"../physics/PhysicsEngine":48,"../physics/bodies/Particle":51,"../physics/forces/Drag":63,"../physics/forces/Spring":68,"../utilities/Utility":95,"../views/Scroller":108}],110:[function(t,i){function e(t){this._items=null,this._size=null,this._outputFunction=e.DEFAULT_OUTPUT_FUNCTION,this.options=a.clone(this.constructor.DEFAULT_OPTIONS||e.DEFAULT_OPTIONS),this.optionsManager=new n(this.options),this.id=o.register(this),this.cachedSize=[void 0,void 0],t&&this.setOptions(t)}var n=t("../core/OptionsManager"),o=t("../core/Entity"),s=t("../core/Transform"),r=t("../core/ViewSequence"),a=t("../utilities/Utility");e.DEFAULT_OPTIONS={direction:a.Direction.Y,itemSpacing:0},e.DEFAULT_OUTPUT_FUNCTION=function(t,i){var e=this.options.direction===a.Direction.X?s.translate(i,0):s.translate(0,i);return{size:this.cachedSize,transform:e,target:t.render()}},e.prototype.getSize=function(){return this._size||this.render(),this._size},e.prototype.sequenceFrom=function(t){return t instanceof Array&&(t=new r(t)),this._items=t,this},e.prototype.setOptions=function(){return this.optionsManager.setOptions.apply(this.optionsManager,arguments),this},e.prototype.setOutputFunction=function(t){return this._outputFunction=t,this},e.prototype.render=function(){return this.id},e.prototype.commit=function(t){var i=0,e=1^this.options.direction,n=this._items,o=null,s=[],r={},a=[],h=0;for(this._size=[0,0],this.cachedSize=t.size;n&&(o=n.get());)o.getSize&&(s=o.getSize()),r=this._outputFunction.call(this,o,i,h++),a.push(r),s&&(s[this.options.direction]&&(i+=s[this.options.direction]),s[e]>this._size[e]&&(this._size[e]=s[e]),0===s[e]&&(this._size[e]=void 0)),n=n.getNext(),this.options.itemSpacing&&n&&(i+=this.options.itemSpacing);return this._size[this.options.direction]=i,{transform:t.transform,origin:t.origin,opacity:t.opacity,size:this.getSize(),target:a}},i.exports=e},{"../core/Entity":5,"../core/OptionsManager":10,"../core/Transform":15,"../core/ViewSequence":17,"../utilities/Utility":95}],111:[function(t,i){function e(){n.apply(this,arguments),this._id=o.register(this),this._parentSize=[]}var n=t("../core/View"),o=t("../core/Entity"),s=t("../core/Transform");e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.commit=function(t){var i=t.transform,e=t.opacity,n=t.origin;return this._parentSize&&this._parentSize[0]===t.size[0]&&this._parentSize[1]===t.size[1]||(this._parentSize[0]=t.size[0],this._parentSize[1]=t.size[1],this._eventInput.emit("parentResize",this._parentSize),this.onResize&&this.onResize(this._parentSize)),this._parentSize&&(i=s.moveThen([-this._parentSize[0]*n[0],-this._parentSize[1]*n[1],0],i)),{transform:i,opacity:e,size:this._parentSize,target:this._node.render()}},e.prototype.getParentSize=function(){return this._parentSize},e.prototype.render=function(){return this._id},i.exports=e},{"../core/Entity":5,"../core/Transform":15,"../core/View":16}],112:[function(t,i){i.exports={ContextualView:t("./ContextualView"),Deck:t("./Deck"),DrawerLayout:t("./DrawerLayout"),EdgeSwapper:t("./EdgeSwapper"),FlexibleLayout:t("./FlexibleLayout"),Flipper:t("./Flipper"),GridLayout:t("./GridLayout"),HeaderFooterLayout:t("./HeaderFooterLayout"),Lightbox:t("./Lightbox"),RenderController:t("./RenderController"),ScrollContainer:t("./ScrollContainer"),Scroller:t("./Scroller"),Scrollview:t("./Scrollview"),SequentialLayout:t("./SequentialLayout"),SizeAwareView:t("./SizeAwareView")}},{"./ContextualView":97,"./Deck":98,"./DrawerLayout":99,"./EdgeSwapper":100,"./FlexibleLayout":101,"./Flipper":102,"./GridLayout":103,"./HeaderFooterLayout":104,"./Lightbox":105,"./RenderController":106,"./ScrollContainer":107,"./Scroller":108,"./Scrollview":109,"./SequentialLayout":110,"./SizeAwareView":111}],113:[function(t,i){function e(){r.apply(this,arguments),this.title=new o({classes:this.options.classes,content:this.options.content}),this.back=new o({size:[this.options.size[1],this.options.size[1]],classes:this.options.classes,content:this.options.backContent}),this.back.on("click",function(){this._eventOutput.emit("back",{})}.bind(this)),this.more=new o({size:[this.options.size[1],this.options.size[1]],classes:this.options.classes,content:this.options.moreContent}),this.more.on("click",function(){this._eventOutput.emit("more",{})}.bind(this)),this.layout=new n({id:"master",size:this.options.size,target:[{transform:s.inFront,origin:[0,.5],align:[0,.5],target:this.back},{origin:[.5,.5],align:[.5,.5],target:this.title},{transform:s.inFront,origin:[1,.5],align:[1,.5],target:this.more}]}),this._add(this.layout),this._optionsManager.on("change",function(t){var i=t.id,e=t.value;"size"===i?(this.layout.id.master.setSize(e),this.title.setSize(e),this.back.setSize([e[1],e[1]]),this.more.setSize([e[1],e[1]])):"backClasses"===i?this.back.setOptions({classes:this.options.classes.concat(this.options.backClasses)}):"backContent"===i?this.back.setContent(this.options.backContent):"classes"===i?(this.title.setOptions({classes:this.options.classes}),this.back.setOptions({classes:this.options.classes.concat(this.options.backClasses)}),this.more.setOptions({classes:this.options.classes.concat(this.options.moreClasses)})):"content"===i?this.setContent(this.options.content):"moreClasses"===i?this.more.setOptions({classes:this.options.classes.concat(this.options.moreClasses)}):"moreContent"===i&&this.more.setContent(this.options.content)}.bind(this))}var n=t("../core/Scene"),o=t("../core/Surface"),s=t("../core/Transform"),r=t("../core/View");e.prototype=Object.create(r.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={size:[void 0,50],backClasses:["back"],backContent:"&#x25c0;",classes:["navigation"],content:"",moreClasses:["more"],moreContent:"&#x271a;"},e.prototype.setContent=function(t){return this.title.setContent(t)},i.exports=e},{"../core/Scene":12,"../core/Surface":14,"../core/Transform":15,"../core/View":16}],114:[function(t,i){function e(t){this.options=Object.create(e.DEFAULT_OPTIONS),this.optionsManager=new c(this.options),t&&this.setOptions(t),this.indicator=new s({size:this.options.indicatorSize,classes:["slider-back"]}),this.label=new o({size:this.options.labelSize,content:this.options.label,properties:{pointerEvents:"none"},classes:["slider-label"]}),this.eventOutput=new a,this.eventInput=new a,a.setInputHandler(this,this.eventInput),a.setOutputHandler(this,this.eventOutput);var i=(this.options.range[1]-this.options.range[0])/this.options.indicatorSize[0];this.sync=new l(["mouse","touch"],{scale:i,direction:l.DIRECTION_X}),this.indicator.pipe(this.sync),this.sync.pipe(this),this.eventInput.on("update",function(t){this.set(t.position)}.bind(this)),this._drawPos=0,n.call(this)}function n(){this.label.setContent(this.options.label+'<span style="float: right">'+this.get().toFixed(this.options.precision)+"</span>")}var o=t("../core/Surface"),s=t("../surfaces/CanvasSurface"),r=t("../core/Transform"),a=t("../core/EventHandler"),h=t("../math/Utilities"),c=t("../core/OptionsManager"),p=t("../inputs/MouseSync"),u=t("../inputs/TouchSync"),l=t("../inputs/GenericSync");l.register({mouse:p,touch:u}),e.DEFAULT_OPTIONS={size:[200,60],indicatorSize:[200,30],labelSize:[200,30],range:[0,1],precision:2,value:0,label:"",fillColor:"rgba(170, 170, 170, 1)"},e.prototype.setOptions=function(t){return this.optionsManager.setOptions(t)},e.prototype.get=function(){return this.options.value},e.prototype.set=function(t){t!==this.options.value&&(this.options.value=h.clamp(t,this.options.range),n.call(this),this.eventOutput.emit("change",{value:t}))},e.prototype.getSize=function(){return this.options.size},e.prototype.render=function(){var t=this.options.range,i=Math.floor((this.get()-t[0])/(t[1]-t[0])*this.options.indicatorSize[0]);if(i<this._drawPos)this.indicator.getContext("2d").clearRect(i,0,this._drawPos-i+1,this.options.indicatorSize[1]);else if(i>this._drawPos){var e=this.indicator.getContext("2d");e.fillStyle=this.options.fillColor,e.fillRect(this._drawPos-1,0,i-this._drawPos+1,this.options.indicatorSize[1])}return this._drawPos=i,{size:this.options.size,target:[{origin:[0,0],target:this.indicator.render()},{transform:r.translate(0,0,1),origin:[0,0],target:this.label.render()}]}},i.exports=e},{"../core/EventHandler":7,"../core/OptionsManager":10,"../core/Surface":14,"../core/Transform":15,"../inputs/GenericSync":27,"../inputs/MouseSync":28,"../inputs/TouchSync":33,"../math/Utilities":40,"../surfaces/CanvasSurface":74}],115:[function(t,i){function e(){r.apply(this,arguments),this.layout=new a,this.buttons=[],this._buttonIds={},this._buttonCallbacks={},this.layout.sequenceFrom(this.buttons),this._add(this.layout),this._optionsManager.on("change",n.bind(this))}function n(t){var i=t.id,e=t.value;if("direction"===i)this.layout.setOptions({dimensions:o.call(this.buttons.length,this.options.direction)});else if("buttons"===i)for(var n in this.buttons)this.buttons[n].setOptions(e);else if("sections"===i)for(var s in this.options.sections)this.defineSection(s,this.options.sections[s])}function o(t,i){return i===s.Direction.X?[t,1]:[1,t]}var s=t("../utilities/Utility"),r=t("../core/View"),a=t("../views/GridLayout"),h=t("./ToggleButton");e.prototype=Object.create(r.prototype),e.prototype.constructor=e,e.DEFAULT_OPTIONS={sections:[],widget:h,size:[void 0,50],direction:s.Direction.X,buttons:{toggleMode:h.ON}},e.prototype.defineSection=function(t,i){var e,n=this._buttonIds[t];if(void 0===n){n=this.buttons.length,this._buttonIds[t]=n;var s=this.options.widget;e=new s,this.buttons[n]=e,this.layout.setOptions({dimensions:o(this.buttons.length,this.options.direction)})}else e=this.buttons[n],e.unbind("select",this._buttonCallbacks[t]);this.options.buttons&&e.setOptions(this.options.buttons),e.setOptions(i),this._buttonCallbacks[t]=this.select.bind(this,t),e.on("select",this._buttonCallbacks[t])},e.prototype.select=function(t){var i=this._buttonIds[t];this.buttons[i]&&this.buttons[i].isSelected()?this._eventOutput.emit("select",{id:t}):this.buttons[i]&&this.buttons[i].select();for(var e=0;e<this.buttons.length;e++)e!==i&&this.buttons[e].deselect()},i.exports=e},{"../core/View":16,"../utilities/Utility":95,"../views/GridLayout":103,"./ToggleButton":116}],116:[function(t,i){function e(t){this.options={content:["",""],offClasses:["off"],onClasses:["on"],size:void 0,outTransition:{curve:"easeInOut",duration:300},inTransition:{curve:"easeInOut",duration:300},toggleMode:e.TOGGLE,crossfade:!0},this._eventOutput=new o,o.setOutputHandler(this,this._eventOutput),this.offSurface=new n,this.offSurface.on("click",function(){this.options.toggleMode!==e.OFF&&this.select()}.bind(this)),this.offSurface.pipe(this._eventOutput),this.onSurface=new n,this.onSurface.on("click",function(){this.options.toggleMode!==e.ON&&this.deselect()}.bind(this)),this.onSurface.pipe(this._eventOutput),this.arbiter=new s({overlap:this.options.crossfade}),this.deselect(),t&&this.setOptions(t)}var n=t("../core/Surface"),o=t("../core/EventHandler"),s=t("../views/RenderController");e.OFF=0,e.ON=1,e.TOGGLE=2,e.prototype.select=function(t){this.selected=!0,this.arbiter.show(this.onSurface,this.options.inTransition),t||this._eventOutput.emit("select")},e.prototype.deselect=function(t){this.selected=!1,this.arbiter.show(this.offSurface,this.options.outTransition),t||this._eventOutput.emit("deselect")},e.prototype.isSelected=function(){return this.selected},e.prototype.setOptions=function(t){void 0!==t.content&&(t.content instanceof Array||(t.content=[t.content,t.content]),this.options.content=t.content,this.offSurface.setContent(this.options.content[0]),this.onSurface.setContent(this.options.content[1])),t.offClasses&&(this.options.offClasses=t.offClasses,this.offSurface.setClasses(this.options.offClasses)),t.onClasses&&(this.options.onClasses=t.onClasses,this.onSurface.setClasses(this.options.onClasses)),void 0!==t.size&&(this.options.size=t.size,this.onSurface.setSize(this.options.size),this.offSurface.setSize(this.options.size)),void 0!==t.toggleMode&&(this.options.toggleMode=t.toggleMode),void 0!==t.outTransition&&(this.options.outTransition=t.outTransition),void 0!==t.inTransition&&(this.options.inTransition=t.inTransition),void 0!==t.crossfade&&(this.options.crossfade=t.crossfade,this.arbiter.setOptions({overlap:this.options.crossfade}))
},e.prototype.getSize=function(){return this.options.size},e.prototype.render=function(){return this.arbiter.render()},i.exports=e},{"../core/EventHandler":7,"../core/Surface":14,"../views/RenderController":106}],117:[function(t,i){i.exports={NavigationBar:t("./NavigationBar"),Slider:t("./Slider"),TabBar:t("./TabBar"),ToggleButton:t("./ToggleButton")}},{"./NavigationBar":113,"./Slider":114,"./TabBar":115,"./ToggleButton":116}]},{},[23])(23)});
(function(e){if("function"==typeof bootstrap)bootstrap("simplewebrtc",e);else if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else if("undefined"!=typeof ses){if(!ses.ok())return;ses.makeSimpleWebRTC=e}else"undefined"!=typeof window?window.SimpleWebRTC=e():global.SimpleWebRTC=e()})(function(){var define,ses,bootstrap,module,exports;
return (function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
var WebRTC = require('./webrtc');
var WildEmitter = require('wildemitter');
var webrtcSupport = require('webrtcsupport');
var attachMediaStream = require('attachmediastream');
var mockconsole = require('mockconsole');
var SocketIoConnection = require('./socketioconnection');

function SimpleWebRTC(opts) {
    var self = this;
    var options = opts || {};
    var config = this.config = {
            url: 'https://signaling.simplewebrtc.com:443/',
            socketio: {/* 'force new connection':true*/},
            connection: null,
            debug: false,
            localVideoEl: '',
            remoteVideosEl: '',
            enableDataChannels: true,
            autoRequestMedia: false,
            autoRemoveVideos: true,
            adjustPeerVolume: true,
            peerVolumeWhenSpeaking: 0.25,
            media: {
                video: true,
                audio: true
            },
            receiveMedia: { // FIXME: remove old chrome <= 37 constraints format
                mandatory: {
                    OfferToReceiveAudio: true,
                    OfferToReceiveVideo: true
                }
            },
            localVideo: {
                autoplay: true,
                mirror: true,
                muted: true
            }
        };
    var item, connection;

    // We also allow a 'logger' option. It can be any object that implements
    // log, warn, and error methods.
    // We log nothing by default, following "the rule of silence":
    // http://www.linfo.org/rule_of_silence.html
    this.logger = function () {
        // we assume that if you're in debug mode and you didn't
        // pass in a logger, you actually want to log as much as
        // possible.
        if (opts.debug) {
            return opts.logger || console;
        } else {
        // or we'll use your logger which should have its own logic
        // for output. Or we'll return the no-op.
            return opts.logger || mockconsole;
        }
    }();

    // set our config from options
    for (item in options) {
        this.config[item] = options[item];
    }

    // attach detected support for convenience
    this.capabilities = webrtcSupport;

    // call WildEmitter constructor
    WildEmitter.call(this);

    // create default SocketIoConnection if it's not passed in
    if (this.config.connection === null) {
        connection = this.connection = new SocketIoConnection(this.config);
    } else {
        connection = this.connection = this.config.connection;
    }

    connection.on('connect', function () {
        self.emit('connectionReady', connection.getSessionid());
        self.sessionReady = true;
        self.testReadiness();
    });

    connection.on('message', function (message) {
        var peers = self.webrtc.getPeers(message.from, message.roomType);
        var peer;

        if (message.type === 'offer') {
            if (peers.length) {
                peers.forEach(function (p) {
                    if (p.sid == message.sid) peer = p;
                });
                //if (!peer) peer = peers[0]; // fallback for old protocol versions
            }
            if (!peer) {
                peer = self.webrtc.createPeer({
                    id: message.from,
                    sid: message.sid,
                    type: message.roomType,
                    enableDataChannels: self.config.enableDataChannels && message.roomType !== 'screen',
                    sharemyscreen: message.roomType === 'screen' && !message.broadcaster,
                    broadcaster: message.roomType === 'screen' && !message.broadcaster ? self.connection.getSessionid() : null
                });
                self.emit('createdPeer', peer);
            }
            peer.handleMessage(message);
        } else if (peers.length) {
            peers.forEach(function (peer) {
                if (message.sid) {
                    if (peer.sid === message.sid) {
                        peer.handleMessage(message);
                    }
                } else {
                    peer.handleMessage(message);
                }
            });
        }
    });

    connection.on('remove', function (room) {
        if (room.id !== self.connection.getSessionid()) {
            self.webrtc.removePeers(room.id, room.type);
        }
    });

    // instantiate our main WebRTC helper
    // using same logger from logic here
    opts.logger = this.logger;
    opts.debug = false;
    this.webrtc = new WebRTC(opts);

    // attach a few methods from underlying lib to simple.
    ['mute', 'unmute', 'pauseVideo', 'resumeVideo', 'pause', 'resume', 'sendToAll', 'sendDirectlyToAll', 'getPeers'].forEach(function (method) {
        self[method] = self.webrtc[method].bind(self.webrtc);
    });

    // proxy events from WebRTC
    this.webrtc.on('*', function () {
        self.emit.apply(self, arguments);
    });

    // log all events in debug mode
    if (config.debug) {
        this.on('*', this.logger.log.bind(this.logger, 'SimpleWebRTC event:'));
    }

    // check for readiness
    this.webrtc.on('localStream', function () {
        self.testReadiness();
    });

    this.webrtc.on('message', function (payload) {
        self.connection.emit('message', payload);
    });

    this.webrtc.on('peerStreamAdded', this.handlePeerStreamAdded.bind(this));
    this.webrtc.on('peerStreamRemoved', this.handlePeerStreamRemoved.bind(this));

    // echo cancellation attempts
    if (this.config.adjustPeerVolume) {
        this.webrtc.on('speaking', this.setVolumeForAll.bind(this, this.config.peerVolumeWhenSpeaking));
        this.webrtc.on('stoppedSpeaking', this.setVolumeForAll.bind(this, 1));
    }

    connection.on('stunservers', function (args) {
        // resets/overrides the config
        self.webrtc.config.peerConnectionConfig.iceServers = args;
        self.emit('stunservers', args);
    });
    connection.on('turnservers', function (args) {
        // appends to the config
        self.webrtc.config.peerConnectionConfig.iceServers = self.webrtc.config.peerConnectionConfig.iceServers.concat(args);
        self.emit('turnservers', args);
    });

    this.webrtc.on('iceFailed', function (peer) {
        // local ice failure
    });
    this.webrtc.on('connectivityError', function (peer) {
        // remote ice failure
    });


    // sending mute/unmute to all peers
    this.webrtc.on('audioOn', function () {
        self.webrtc.sendToAll('unmute', {name: 'audio'});
    });
    this.webrtc.on('audioOff', function () {
        self.webrtc.sendToAll('mute', {name: 'audio'});
    });
    this.webrtc.on('videoOn', function () {
        self.webrtc.sendToAll('unmute', {name: 'video'});
    });
    this.webrtc.on('videoOff', function () {
        self.webrtc.sendToAll('mute', {name: 'video'});
    });

    // screensharing events
    this.webrtc.on('localScreen', function (stream) {
        var item,
            el = document.createElement('video'),
            container = self.getRemoteVideoContainer();

        el.oncontextmenu = function () { return false; };
        el.id = 'localScreen';
        attachMediaStream(stream, el);
        if (container) {
            container.appendChild(el);
        }

        self.emit('localScreenAdded', el);
        self.connection.emit('shareScreen');

        self.webrtc.peers.forEach(function (existingPeer) {
            var peer;
            if (existingPeer.type === 'video') {
                peer = self.webrtc.createPeer({
                    id: existingPeer.id,
                    type: 'screen',
                    sharemyscreen: true,
                    enableDataChannels: false,
                    receiveMedia: {
                        mandatory: {
                            OfferToReceiveAudio: false,
                            OfferToReceiveVideo: false
                        }
                    },
                    broadcaster: self.connection.getSessionid(),
                });
                self.emit('createdPeer', peer);
                peer.start();
            }
        });
    });
    this.webrtc.on('localScreenStopped', function (stream) {
        self.stopScreenShare();
        /*
        self.connection.emit('unshareScreen');
        self.webrtc.peers.forEach(function (peer) {
            if (peer.sharemyscreen) {
                peer.end();
            }
        });
        */
    });

    this.webrtc.on('channelMessage', function (peer, label, data) {
        if (data.type == 'volume') {
            self.emit('remoteVolumeChange', peer, data.volume);
        }
    });

    if (this.config.autoRequestMedia) this.startLocalVideo();
}


SimpleWebRTC.prototype = Object.create(WildEmitter.prototype, {
    constructor: {
        value: SimpleWebRTC
    }
});

SimpleWebRTC.prototype.leaveRoom = function () {
    if (this.roomName) {
        this.connection.emit('leave');
        this.webrtc.peers.forEach(function (peer) {
            peer.end();
        });
        if (this.getLocalScreen()) {
            this.stopScreenShare();
        }
        this.emit('leftRoom', this.roomName);
        this.roomName = undefined;
    }
};

SimpleWebRTC.prototype.disconnect = function () {
    this.connection.disconnect();
    delete this.connection;
};

SimpleWebRTC.prototype.handlePeerStreamAdded = function (peer) {
    var self = this;
    var container = this.getRemoteVideoContainer();
    var video = attachMediaStream(peer.stream);

    // store video element as part of peer for easy removal
    peer.videoEl = video;
    video.id = this.getDomId(peer);

    if (container) container.appendChild(video);

    this.emit('videoAdded', video, peer);

    // send our mute status to new peer if we're muted
    // currently called with a small delay because it arrives before
    // the video element is created otherwise (which happens after
    // the async setRemoteDescription-createAnswer)
    window.setTimeout(function () {
        if (!self.webrtc.isAudioEnabled()) {
            peer.send('mute', {name: 'audio'});
        }
        if (!self.webrtc.isVideoEnabled()) {
            peer.send('mute', {name: 'video'});
        }
    }, 250);
};

SimpleWebRTC.prototype.handlePeerStreamRemoved = function (peer) {
    var container = this.getRemoteVideoContainer();
    var videoEl = peer.videoEl;
    if (this.config.autoRemoveVideos && container && videoEl) {
        container.removeChild(videoEl);
    }
    if (videoEl) this.emit('videoRemoved', videoEl, peer);
};

SimpleWebRTC.prototype.getDomId = function (peer) {
    return [peer.id, peer.type, peer.broadcaster ? 'broadcasting' : 'incoming'].join('_');
};

// set volume on video tag for all peers takse a value between 0 and 1
SimpleWebRTC.prototype.setVolumeForAll = function (volume) {
    this.webrtc.peers.forEach(function (peer) {
        if (peer.videoEl) peer.videoEl.volume = volume;
    });
};

SimpleWebRTC.prototype.joinRoom = function (name, cb) {
    var self = this;
    this.roomName = name;
    this.connection.emit('join', name, function (err, roomDescription) {
        if (err) {
            self.emit('error', err);
        } else {
            var id,
                client,
                type,
                peer;
            for (id in roomDescription.clients) {
                client = roomDescription.clients[id];
                for (type in client) {
                    if (client[type]) {
                        peer = self.webrtc.createPeer({
                            id: id,
                            type: type,
                            enableDataChannels: self.config.enableDataChannels && type !== 'screen',
                            receiveMedia: {
                                mandatory: {
                                    OfferToReceiveAudio: type !== 'screen' && self.config.receiveMedia.mandatory.OfferToReceiveAudio,
                                    OfferToReceiveVideo: self.config.receiveMedia.mandatory.OfferToReceiveVideo
                                }
                            }
                        });
                        self.emit('createdPeer', peer);
                        peer.start();
                    }
                }
            }
        }

        if (cb) cb(err, roomDescription);
        self.emit('joinedRoom', name);
    });
};

SimpleWebRTC.prototype.getEl = function (idOrEl) {
    if (typeof idOrEl === 'string') {
        return document.getElementById(idOrEl);
    } else {
        return idOrEl;
    }
};

SimpleWebRTC.prototype.startLocalVideo = function () {
    var self = this;
    this.webrtc.startLocalMedia(this.config.media, function (err, stream) {
        if (err) {
            self.emit('localMediaError', err);
        } else {
            attachMediaStream(stream, self.getLocalVideoContainer(), self.config.localVideo);
        }
    });
};

SimpleWebRTC.prototype.stopLocalVideo = function () {
    this.webrtc.stopLocalMedia();
};

// this accepts either element ID or element
// and either the video tag itself or a container
// that will be used to put the video tag into.
SimpleWebRTC.prototype.getLocalVideoContainer = function () {
    var el = this.getEl(this.config.localVideoEl);
    if (el && el.tagName === 'VIDEO') {
        el.oncontextmenu = function () { return false; };
        return el;
    } else if (el) {
        var video = document.createElement('video');
        video.oncontextmenu = function () { return false; };
        el.appendChild(video);
        return video;
    } else {
        return;
    }
};

SimpleWebRTC.prototype.getRemoteVideoContainer = function () {
    return this.getEl(this.config.remoteVideosEl);
};

SimpleWebRTC.prototype.shareScreen = function (cb) {
    this.webrtc.startScreenShare(cb);
};

SimpleWebRTC.prototype.getLocalScreen = function () {
    return this.webrtc.localScreen;
};

SimpleWebRTC.prototype.stopScreenShare = function () {
    this.connection.emit('unshareScreen');
    var videoEl = document.getElementById('localScreen');
    var container = this.getRemoteVideoContainer();
    var stream = this.getLocalScreen();

    if (this.config.autoRemoveVideos && container && videoEl) {
        container.removeChild(videoEl);
    }

    // a hack to emit the event the removes the video
    // element that we want
    if (videoEl) this.emit('videoRemoved', videoEl);
    if (stream) stream.stop();
    this.webrtc.peers.forEach(function (peer) {
        if (peer.broadcaster) {
            peer.end();
        }
    });
    //delete this.webrtc.localScreen;
};

SimpleWebRTC.prototype.testReadiness = function () {
    var self = this;
    if (this.webrtc.localStream && this.sessionReady) {
        self.emit('readyToCall', self.connection.getSessionid());
    }
};

SimpleWebRTC.prototype.createRoom = function (name, cb) {
    if (arguments.length === 2) {
        this.connection.emit('create', name, cb);
    } else {
        this.connection.emit('create', name);
    }
};

SimpleWebRTC.prototype.sendFile = function () {
    if (!webrtcSupport.dataChannel) {
        return this.emit('error', new Error('DataChannelNotSupported'));
    }

};

module.exports = SimpleWebRTC;

},{"./socketioconnection":3,"./webrtc":2,"attachmediastream":7,"mockconsole":6,"webrtcsupport":5,"wildemitter":4}],5:[function(require,module,exports){
// created by @HenrikJoreteg
var prefix;
var version;

if (window.mozRTCPeerConnection || navigator.mozGetUserMedia) {
    prefix = 'moz';
    version = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);
} else if (window.webkitRTCPeerConnection || navigator.webkitGetUserMedia) {
    prefix = 'webkit';
    version = navigator.userAgent.match(/Chrom(e|ium)/) && parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);
}

var PC = window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
var SessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
var MediaStream = window.webkitMediaStream || window.MediaStream;
var screenSharing = window.location.protocol === 'https:' &&
    ((prefix === 'webkit' && version >= 26) ||
     (prefix === 'moz' && version >= 33))
var AudioContext = window.AudioContext || window.webkitAudioContext;
var videoEl = document.createElement('video');
var supportVp8 = videoEl && videoEl.canPlayType && videoEl.canPlayType('video/webm; codecs="vp8", vorbis') === "probably";
var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia;

// export support flags and constructors.prototype && PC
module.exports = {
    prefix: prefix,
    browserVersion: version,
    support: !!PC && supportVp8 && !!getUserMedia,
    // new support style
    supportRTCPeerConnection: !!PC,
    supportVp8: supportVp8,
    supportGetUserMedia: !!getUserMedia,
    supportDataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
    supportWebAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
    supportMediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
    supportScreenSharing: !!screenSharing,
    // old deprecated style. Dont use this anymore
    dataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
    webAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
    mediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
    screenSharing: !!screenSharing,
    // constructors
    AudioContext: AudioContext,
    PeerConnection: PC,
    SessionDescription: SessionDescription,
    IceCandidate: IceCandidate,
    MediaStream: MediaStream,
    getUserMedia: getUserMedia
};

},{}],4:[function(require,module,exports){
/*
WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based 
on @visionmedia's Emitter from UI Kit.

Why? I wanted it standalone.

I also wanted support for wildcard emitters like this:

emitter.on('*', function (eventName, other, event, payloads) {
    
});

emitter.on('somenamespace*', function (eventName, payloads) {
    
});

Please note that callbacks triggered by wildcard registered events also get 
the event name as the first argument.
*/
module.exports = WildEmitter;

function WildEmitter() {
    this.isWildEmitter = true;
    this.callbacks = {};
}

// Listen on the given `event` with `fn`. Store a group name if present.
WildEmitter.prototype.on = function (event, groupName, fn) {
    var hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    func._groupName = group;
    (this.callbacks[event] = this.callbacks[event] || []).push(func);
    return this;
};

// Adds an `event` listener that will be invoked a single
// time then automatically removed.
WildEmitter.prototype.once = function (event, groupName, fn) {
    var self = this,
        hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    function on() {
        self.off(event, on);
        func.apply(this, arguments);
    }
    this.on(event, group, on);
    return this;
};

// Unbinds an entire group
WildEmitter.prototype.releaseGroup = function (groupName) {
    var item, i, len, handlers;
    for (item in this.callbacks) {
        handlers = this.callbacks[item];
        for (i = 0, len = handlers.length; i < len; i++) {
            if (handlers[i]._groupName === groupName) {
                //console.log('removing');
                // remove it and shorten the array we're looping through
                handlers.splice(i, 1);
                i--;
                len--;
            }
        }
    }
    return this;
};

// Remove the given callback for `event` or all
// registered callbacks.
WildEmitter.prototype.off = function (event, fn) {
    var callbacks = this.callbacks[event],
        i;

    if (!callbacks) return this;

    // remove all handlers
    if (arguments.length === 1) {
        delete this.callbacks[event];
        return this;
    }

    // remove specific handler
    i = callbacks.indexOf(fn);
    callbacks.splice(i, 1);
    if (callbacks.length === 0) {
        delete this.callbacks[event];
    }
    return this;
};

/// Emit `event` with the given args.
// also calls any `*` handlers
WildEmitter.prototype.emit = function (event) {
    var args = [].slice.call(arguments, 1),
        callbacks = this.callbacks[event],
        specialCallbacks = this.getWildcardCallbacks(event),
        i,
        len,
        item,
        listeners;

    if (callbacks) {
        listeners = callbacks.slice();
        for (i = 0, len = listeners.length; i < len; ++i) {
            if (listeners[i]) {
                listeners[i].apply(this, args);
            } else {
                break;
            }
        }
    }

    if (specialCallbacks) {
        len = specialCallbacks.length;
        listeners = specialCallbacks.slice();
        for (i = 0, len = listeners.length; i < len; ++i) {
            if (listeners[i]) {
                listeners[i].apply(this, [event].concat(args));
            } else {
                break;
            }
        }
    }

    return this;
};

// Helper for for finding special wildcard event handlers that match the event
WildEmitter.prototype.getWildcardCallbacks = function (eventName) {
    var item,
        split,
        result = [];

    for (item in this.callbacks) {
        split = item.split('*');
        if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
            result = result.concat(this.callbacks[item]);
        }
    }
    return result;
};

},{}],7:[function(require,module,exports){
module.exports = function (stream, el, options) {
    var URL = window.URL;
    var opts = {
        autoplay: true,
        mirror: false,
        muted: false
    };
    var element = el || document.createElement('video');
    var item;

    if (options) {
        for (item in options) {
            opts[item] = options[item];
        }
    }

    if (opts.autoplay) element.autoplay = 'autoplay';
    if (opts.muted) element.muted = true;
    if (opts.mirror) {
        ['', 'moz', 'webkit', 'o', 'ms'].forEach(function (prefix) {
            var styleName = prefix ? prefix + 'Transform' : 'transform';
            element.style[styleName] = 'scaleX(-1)';
        });
    }

    // this first one should work most everywhere now
    // but we have a few fallbacks just in case.
    if (URL && URL.createObjectURL) {
        element.src = URL.createObjectURL(stream);
    } else if (element.srcObject) {
        element.srcObject = stream;
    } else if (element.mozSrcObject) {
        element.mozSrcObject = stream;
    } else {
        return false;
    }

    return element;
};

},{}],6:[function(require,module,exports){
var methods = "assert,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profileEnd,time,timeEnd,trace,warn".split(",");
var l = methods.length;
var fn = function () {};
var mockconsole = {};

while (l--) {
    mockconsole[methods[l]] = fn;
}

module.exports = mockconsole;

},{}],2:[function(require,module,exports){
var util = require('util');
var webrtc = require('webrtcsupport');
var WildEmitter = require('wildemitter');
var mockconsole = require('mockconsole');
var localMedia = require('localmedia');
var Peer = require('./peer');


function WebRTC(opts) {
    var self = this;
    var options = opts || {};
    var config = this.config = {
            debug: false,
            // makes the entire PC config overridable
            peerConnectionConfig: {
                iceServers: [{"url": "stun:stun.l.google.com:19302"}]
            },
            peerConnectionConstraints: {
                optional: [
                    {DtlsSrtpKeyAgreement: true}
                ]
            },
            receiveMedia: {
                mandatory: {
                    OfferToReceiveAudio: true,
                    OfferToReceiveVideo: true
                }
            },
            enableDataChannels: true
        };
    var item;

    // expose screensharing check
    this.screenSharingSupport = webrtc.screenSharing;

    // We also allow a 'logger' option. It can be any object that implements
    // log, warn, and error methods.
    // We log nothing by default, following "the rule of silence":
    // http://www.linfo.org/rule_of_silence.html
    this.logger = function () {
        // we assume that if you're in debug mode and you didn't
        // pass in a logger, you actually want to log as much as
        // possible.
        if (opts.debug) {
            return opts.logger || console;
        } else {
        // or we'll use your logger which should have its own logic
        // for output. Or we'll return the no-op.
            return opts.logger || mockconsole;
        }
    }();

    // set options
    for (item in options) {
        this.config[item] = options[item];
    }

    // check for support
    if (!webrtc.support) {
        this.logger.error('Your browser doesn\'t seem to support WebRTC');
    }

    // where we'll store our peer connections
    this.peers = [];

    // call localMedia constructor
    localMedia.call(this, this.config);

    this.on('speaking', function () {
        if (!self.hardMuted) {
            // FIXME: should use sendDirectlyToAll, but currently has different semantics wrt payload
            self.peers.forEach(function (peer) {
                if (peer.enableDataChannels) {
                    var dc = peer.getDataChannel('hark');
                    if (dc.readyState != 'open') return;
                    dc.send(JSON.stringify({type: 'speaking'}));
                }
            });
        }
    });
    this.on('stoppedSpeaking', function () {
        if (!self.hardMuted) {
            // FIXME: should use sendDirectlyToAll, but currently has different semantics wrt payload
            self.peers.forEach(function (peer) {
                if (peer.enableDataChannels) {
                    var dc = peer.getDataChannel('hark');
                    if (dc.readyState != 'open') return;
                    dc.send(JSON.stringify({type: 'stoppedSpeaking'}));
                }
            });
        }
    });
    this.on('volumeChange', function (volume, treshold) {
        if (!self.hardMuted) {
            // FIXME: should use sendDirectlyToAll, but currently has different semantics wrt payload
            self.peers.forEach(function (peer) {
                if (peer.enableDataChannels) {
                    var dc = peer.getDataChannel('hark');
                    if (dc.readyState != 'open') return;
                    dc.send(JSON.stringify({type: 'volume', volume: volume }));
                }
            });
        }
    });

    // log events in debug mode
    if (this.config.debug) {
        this.on('*', function (event, val1, val2) {
            var logger;
            // if you didn't pass in a logger and you explicitly turning on debug
            // we're just going to assume you're wanting log output with console
            if (self.config.logger === mockconsole) {
                logger = console;
            } else {
                logger = self.logger;
            }
            logger.log('event:', event, val1, val2);
        });
    }
}

util.inherits(WebRTC, localMedia);

WebRTC.prototype.createPeer = function (opts) {
    var peer;
    opts.parent = this;
    peer = new Peer(opts);
    this.peers.push(peer);
    return peer;
};

// removes peers
WebRTC.prototype.removePeers = function (id, type) {
    this.getPeers(id, type).forEach(function (peer) {
        peer.end();
    });
};

// fetches all Peer objects by session id and/or type
WebRTC.prototype.getPeers = function (sessionId, type) {
    return this.peers.filter(function (peer) {
        return (!sessionId || peer.id === sessionId) && (!type || peer.type === type);
    });
};

// sends message to all
WebRTC.prototype.sendToAll = function (message, payload) {
    this.peers.forEach(function (peer) {
        peer.send(message, payload);
    });
};

// sends message to all using a datachannel
// only sends to anyone who has an open datachannel
WebRTC.prototype.sendDirectlyToAll = function (channel, message, payload) {
    this.peers.forEach(function (peer) {
        if (peer.enableDataChannels) {
            peer.sendDirectly(channel, message, payload);
        }
    });
};

module.exports = WebRTC;

},{"./peer":9,"localmedia":10,"mockconsole":6,"util":8,"webrtcsupport":5,"wildemitter":4}],3:[function(require,module,exports){
var io = require('socket.io-client');

function SocketIoConnection(config) {
    this.connection = io.connect(config.url, config.socketio);
}

SocketIoConnection.prototype.on = function (ev, fn) {
    this.connection.on(ev, fn);
};

SocketIoConnection.prototype.emit = function () {
    this.connection.emit.apply(this.connection, arguments);
};

SocketIoConnection.prototype.getSessionid = function () {
    return this.connection.socket.sessionid;
};

SocketIoConnection.prototype.disconnect = function () {
    return this.connection.disconnect();
};

module.exports = SocketIoConnection;

},{"socket.io-client":11}],8:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\u001b[' + styles[style][0] + 'm' + str +
             '\u001b[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && Object.prototype.toString.call(ar) === '[object Array]');
}


function isRegExp(re) {
  typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]';
}


function isDate(d) {
  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":12}],11:[function(require,module,exports){
/*! Socket.IO.js build:0.9.16, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */

var io = ('undefined' === typeof module ? {} : module.exports);
(function() {

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, global) {

  /**
   * IO namespace.
   *
   * @namespace
   */

  var io = exports;

  /**
   * Socket.IO version
   *
   * @api public
   */

  io.version = '0.9.16';

  /**
   * Protocol implemented.
   *
   * @api public
   */

  io.protocol = 1;

  /**
   * Available transports, these will be populated with the available transports
   *
   * @api public
   */

  io.transports = [];

  /**
   * Keep track of jsonp callbacks.
   *
   * @api private
   */

  io.j = [];

  /**
   * Keep track of our io.Sockets
   *
   * @api private
   */
  io.sockets = {};


  /**
   * Manages connections to hosts.
   *
   * @param {String} uri
   * @Param {Boolean} force creation of new socket (defaults to false)
   * @api public
   */

  io.connect = function (host, details) {
    var uri = io.util.parseUri(host)
      , uuri
      , socket;

    if (global && global.location) {
      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);
      uri.host = uri.host || (global.document
        ? global.document.domain : global.location.hostname);
      uri.port = uri.port || global.location.port;
    }

    uuri = io.util.uniqueUri(uri);

    var options = {
        host: uri.host
      , secure: 'https' == uri.protocol
      , port: uri.port || ('https' == uri.protocol ? 443 : 80)
      , query: uri.query || ''
    };

    io.util.merge(options, details);

    if (options['force new connection'] || !io.sockets[uuri]) {
      socket = new io.Socket(options);
    }

    if (!options['force new connection'] && socket) {
      io.sockets[uuri] = socket;
    }

    socket = socket || io.sockets[uuri];

    // if path is different from '' or /
    return socket.of(uri.path.length > 1 ? uri.path : '');
  };

})('object' === typeof module ? module.exports : (this.io = {}), this);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, global) {

  /**
   * Utilities namespace.
   *
   * @namespace
   */

  var util = exports.util = {};

  /**
   * Parses an URI
   *
   * @author Steven Levithan <stevenlevithan.com> (MIT license)
   * @api public
   */

  var re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',
               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',
               'anchor'];

  util.parseUri = function (str) {
    var m = re.exec(str || '')
      , uri = {}
      , i = 14;

    while (i--) {
      uri[parts[i]] = m[i] || '';
    }

    return uri;
  };

  /**
   * Produces a unique url that identifies a Socket.IO connection.
   *
   * @param {Object} uri
   * @api public
   */

  util.uniqueUri = function (uri) {
    var protocol = uri.protocol
      , host = uri.host
      , port = uri.port;

    if ('document' in global) {
      host = host || document.domain;
      port = port || (protocol == 'https'
        && document.location.protocol !== 'https:' ? 443 : document.location.port);
    } else {
      host = host || 'localhost';

      if (!port && protocol == 'https') {
        port = 443;
      }
    }

    return (protocol || 'http') + '://' + host + ':' + (port || 80);
  };

  /**
   * Mergest 2 query strings in to once unique query string
   *
   * @param {String} base
   * @param {String} addition
   * @api public
   */

  util.query = function (base, addition) {
    var query = util.chunkQuery(base || '')
      , components = [];

    util.merge(query, util.chunkQuery(addition || ''));
    for (var part in query) {
      if (query.hasOwnProperty(part)) {
        components.push(part + '=' + query[part]);
      }
    }

    return components.length ? '?' + components.join('&') : '';
  };

  /**
   * Transforms a querystring in to an object
   *
   * @param {String} qs
   * @api public
   */

  util.chunkQuery = function (qs) {
    var query = {}
      , params = qs.split('&')
      , i = 0
      , l = params.length
      , kv;

    for (; i < l; ++i) {
      kv = params[i].split('=');
      if (kv[0]) {
        query[kv[0]] = kv[1];
      }
    }

    return query;
  };

  /**
   * Executes the given function when the page is loaded.
   *
   *     io.util.load(function () { console.log('page loaded'); });
   *
   * @param {Function} fn
   * @api public
   */

  var pageLoaded = false;

  util.load = function (fn) {
    if ('document' in global && document.readyState === 'complete' || pageLoaded) {
      return fn();
    }

    util.on(global, 'load', fn, false);
  };

  /**
   * Adds an event.
   *
   * @api private
   */

  util.on = function (element, event, fn, capture) {
    if (element.attachEvent) {
      element.attachEvent('on' + event, fn);
    } else if (element.addEventListener) {
      element.addEventListener(event, fn, capture);
    }
  };

  /**
   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.
   *
   * @param {Boolean} [xdomain] Create a request that can be used cross domain.
   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.
   * @api private
   */

  util.request = function (xdomain) {

    if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {
      return new XDomainRequest();
    }

    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {
      return new XMLHttpRequest();
    }

    if (!xdomain) {
      try {
        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');
      } catch(e) { }
    }

    return null;
  };

  /**
   * XHR based transport constructor.
   *
   * @constructor
   * @api public
   */

  /**
   * Change the internal pageLoaded value.
   */

  if ('undefined' != typeof window) {
    util.load(function () {
      pageLoaded = true;
    });
  }

  /**
   * Defers a function to ensure a spinner is not displayed by the browser
   *
   * @param {Function} fn
   * @api public
   */

  util.defer = function (fn) {
    if (!util.ua.webkit || 'undefined' != typeof importScripts) {
      return fn();
    }

    util.load(function () {
      setTimeout(fn, 100);
    });
  };

  /**
   * Merges two objects.
   *
   * @api public
   */

  util.merge = function merge (target, additional, deep, lastseen) {
    var seen = lastseen || []
      , depth = typeof deep == 'undefined' ? 2 : deep
      , prop;

    for (prop in additional) {
      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {
        if (typeof target[prop] !== 'object' || !depth) {
          target[prop] = additional[prop];
          seen.push(additional[prop]);
        } else {
          util.merge(target[prop], additional[prop], depth - 1, seen);
        }
      }
    }

    return target;
  };

  /**
   * Merges prototypes from objects
   *
   * @api public
   */

  util.mixin = function (ctor, ctor2) {
    util.merge(ctor.prototype, ctor2.prototype);
  };

  /**
   * Shortcut for prototypical and static inheritance.
   *
   * @api private
   */

  util.inherit = function (ctor, ctor2) {
    function f() {};
    f.prototype = ctor2.prototype;
    ctor.prototype = new f;
  };

  /**
   * Checks if the given object is an Array.
   *
   *     io.util.isArray([]); // true
   *     io.util.isArray({}); // false
   *
   * @param Object obj
   * @api public
   */

  util.isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  /**
   * Intersects values of two arrays into a third
   *
   * @api public
   */

  util.intersect = function (arr, arr2) {
    var ret = []
      , longest = arr.length > arr2.length ? arr : arr2
      , shortest = arr.length > arr2.length ? arr2 : arr;

    for (var i = 0, l = shortest.length; i < l; i++) {
      if (~util.indexOf(longest, shortest[i]))
        ret.push(shortest[i]);
    }

    return ret;
  };

  /**
   * Array indexOf compatibility.
   *
   * @see bit.ly/a5Dxa2
   * @api public
   */

  util.indexOf = function (arr, o, i) {

    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;
         i < j && arr[i] !== o; i++) {}

    return j <= i ? -1 : i;
  };

  /**
   * Converts enumerables to array.
   *
   * @api public
   */

  util.toArray = function (enu) {
    var arr = [];

    for (var i = 0, l = enu.length; i < l; i++)
      arr.push(enu[i]);

    return arr;
  };

  /**
   * UA / engines detection namespace.
   *
   * @namespace
   */

  util.ua = {};

  /**
   * Whether the UA supports CORS for XHR.
   *
   * @api public
   */

  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {
    try {
      var a = new XMLHttpRequest();
    } catch (e) {
      return false;
    }

    return a.withCredentials != undefined;
  })();

  /**
   * Detect webkit.
   *
   * @api public
   */

  util.ua.webkit = 'undefined' != typeof navigator
    && /webkit/i.test(navigator.userAgent);

   /**
   * Detect iPad/iPhone/iPod.
   *
   * @api public
   */

  util.ua.iDevice = 'undefined' != typeof navigator
      && /iPad|iPhone|iPod/i.test(navigator.userAgent);

})('undefined' != typeof io ? io : module.exports, this);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.EventEmitter = EventEmitter;

  /**
   * Event emitter constructor.
   *
   * @api public.
   */

  function EventEmitter () {};

  /**
   * Adds a listener
   *
   * @api public
   */

  EventEmitter.prototype.on = function (name, fn) {
    if (!this.$events) {
      this.$events = {};
    }

    if (!this.$events[name]) {
      this.$events[name] = fn;
    } else if (io.util.isArray(this.$events[name])) {
      this.$events[name].push(fn);
    } else {
      this.$events[name] = [this.$events[name], fn];
    }

    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  /**
   * Adds a volatile listener.
   *
   * @api public
   */

  EventEmitter.prototype.once = function (name, fn) {
    var self = this;

    function on () {
      self.removeListener(name, on);
      fn.apply(this, arguments);
    };

    on.listener = fn;
    this.on(name, on);

    return this;
  };

  /**
   * Removes a listener.
   *
   * @api public
   */

  EventEmitter.prototype.removeListener = function (name, fn) {
    if (this.$events && this.$events[name]) {
      var list = this.$events[name];

      if (io.util.isArray(list)) {
        var pos = -1;

        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {
            pos = i;
            break;
          }
        }

        if (pos < 0) {
          return this;
        }

        list.splice(pos, 1);

        if (!list.length) {
          delete this.$events[name];
        }
      } else if (list === fn || (list.listener && list.listener === fn)) {
        delete this.$events[name];
      }
    }

    return this;
  };

  /**
   * Removes all listeners for an event.
   *
   * @api public
   */

  EventEmitter.prototype.removeAllListeners = function (name) {
    if (name === undefined) {
      this.$events = {};
      return this;
    }

    if (this.$events && this.$events[name]) {
      this.$events[name] = null;
    }

    return this;
  };

  /**
   * Gets all listeners for a certain event.
   *
   * @api publci
   */

  EventEmitter.prototype.listeners = function (name) {
    if (!this.$events) {
      this.$events = {};
    }

    if (!this.$events[name]) {
      this.$events[name] = [];
    }

    if (!io.util.isArray(this.$events[name])) {
      this.$events[name] = [this.$events[name]];
    }

    return this.$events[name];
  };

  /**
   * Emits an event.
   *
   * @api public
   */

  EventEmitter.prototype.emit = function (name) {
    if (!this.$events) {
      return false;
    }

    var handler = this.$events[name];

    if (!handler) {
      return false;
    }

    var args = Array.prototype.slice.call(arguments, 1);

    if ('function' == typeof handler) {
      handler.apply(this, args);
    } else if (io.util.isArray(handler)) {
      var listeners = handler.slice();

      for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i].apply(this, args);
      }
    } else {
      return false;
    }

    return true;
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Based on JSON2 (http://www.JSON.org/js.html).
 */

(function (exports, nativeJSON) {
  "use strict";

  // use native JSON if it's available
  if (nativeJSON && nativeJSON.parse){
    return exports.JSON = {
      parse: nativeJSON.parse
    , stringify: nativeJSON.stringify
    };
  }

  var JSON = exports.JSON = {};

  function f(n) {
      // Format integers to have at least two digits.
      return n < 10 ? '0' + n : n;
  }

  function date(d, key) {
    return isFinite(d.valueOf()) ?
        d.getUTCFullYear()     + '-' +
        f(d.getUTCMonth() + 1) + '-' +
        f(d.getUTCDate())      + 'T' +
        f(d.getUTCHours())     + ':' +
        f(d.getUTCMinutes())   + ':' +
        f(d.getUTCSeconds())   + 'Z' : null;
  };

  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      gap,
      indent,
      meta = {    // table of character substitutions
          '\b': '\\b',
          '\t': '\\t',
          '\n': '\\n',
          '\f': '\\f',
          '\r': '\\r',
          '"' : '\\"',
          '\\': '\\\\'
      },
      rep;


  function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
          var c = meta[a];
          return typeof c === 'string' ? c :
              '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
  }


  function str(key, holder) {

// Produce a string from holder[key].

      var i,          // The loop counter.
          k,          // The member key.
          v,          // The member value.
          length,
          mind = gap,
          partial,
          value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

      if (value instanceof Date) {
          value = date(key);
      }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

      if (typeof rep === 'function') {
          value = rep.call(holder, key, value);
      }

// What happens next depends on the value's type.

      switch (typeof value) {
      case 'string':
          return quote(value);

      case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

          return isFinite(value) ? String(value) : 'null';

      case 'boolean':
      case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

          return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

      case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

          if (!value) {
              return 'null';
          }

// Make an array to hold the partial results of stringifying this object value.

          gap += indent;
          partial = [];

// Is the value an array?

          if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

              length = value.length;
              for (i = 0; i < length; i += 1) {
                  partial[i] = str(i, value) || 'null';
              }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

              v = partial.length === 0 ? '[]' : gap ?
                  '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                  '[' + partial.join(',') + ']';
              gap = mind;
              return v;
          }

// If the replacer is an array, use it to select the members to be stringified.

          if (rep && typeof rep === 'object') {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                  if (typeof rep[i] === 'string') {
                      k = rep[i];
                      v = str(k, value);
                      if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                      }
                  }
              }
          } else {

// Otherwise, iterate through all of the keys in the object.

              for (k in value) {
                  if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = str(k, value);
                      if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                      }
                  }
              }
          }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

          v = partial.length === 0 ? '{}' : gap ?
              '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
              '{' + partial.join(',') + '}';
          gap = mind;
          return v;
      }
  }

// If the JSON object does not yet have a stringify method, give it one.

  JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

      var i;
      gap = '';
      indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

      if (typeof space === 'number') {
          for (i = 0; i < space; i += 1) {
              indent += ' ';
          }

// If the space parameter is a string, it will be used as the indent string.

      } else if (typeof space === 'string') {
          indent = space;
      }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

      rep = replacer;
      if (replacer && typeof replacer !== 'function' &&
              (typeof replacer !== 'object' ||
              typeof replacer.length !== 'number')) {
          throw new Error('JSON.stringify');
      }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

      return str('', {'': value});
  };

// If the JSON object does not yet have a parse method, give it one.

  JSON.parse = function (text, reviver) {
  // The parse method takes a text and an optional reviver function, and returns
  // a JavaScript value if the text is a valid JSON text.

      var j;

      function walk(holder, key) {

  // The walk method is used to recursively walk the resulting structure so
  // that modifications can be made.

          var k, v, value = holder[key];
          if (value && typeof value === 'object') {
              for (k in value) {
                  if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = walk(value, k);
                      if (v !== undefined) {
                          value[k] = v;
                      } else {
                          delete value[k];
                      }
                  }
              }
          }
          return reviver.call(holder, key, value);
      }


  // Parsing happens in four stages. In the first stage, we replace certain
  // Unicode characters with escape sequences. JavaScript handles many characters
  // incorrectly, either silently deleting them, or treating them as line endings.

      text = String(text);
      cx.lastIndex = 0;
      if (cx.test(text)) {
          text = text.replace(cx, function (a) {
              return '\\u' +
                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
          });
      }

  // In the second stage, we run the text against regular expressions that look
  // for non-JSON patterns. We are especially concerned with '()' and 'new'
  // because they can cause invocation, and '=' because it can cause mutation.
  // But just to be safe, we want to reject all unexpected forms.

  // We split the second stage into 4 regexp operations in order to work around
  // crippling inefficiencies in IE's and Safari's regexp engines. First we
  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
  // replace all simple value tokens with ']' characters. Third, we delete all
  // open brackets that follow a colon or comma or that begin the text. Finally,
  // we look to see that the remaining characters are only whitespace or ']' or
  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

      if (/^[\],:{}\s]*$/
              .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                  .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                  .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

  // In the third stage we use the eval function to compile the text into a
  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
  // in JavaScript: it can begin a block or an object literal. We wrap the text
  // in parens to eliminate the ambiguity.

          j = eval('(' + text + ')');

  // In the optional fourth stage, we recursively walk the new structure, passing
  // each name/value pair to a reviver function for possible transformation.

          return typeof reviver === 'function' ?
              walk({'': j}, '') : j;
      }

  // If the text is not JSON parseable, then a SyntaxError is thrown.

      throw new SyntaxError('JSON.parse');
  };

})(
    'undefined' != typeof io ? io : module.exports
  , typeof JSON !== 'undefined' ? JSON : undefined
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Parser namespace.
   *
   * @namespace
   */

  var parser = exports.parser = {};

  /**
   * Packet types.
   */

  var packets = parser.packets = [
      'disconnect'
    , 'connect'
    , 'heartbeat'
    , 'message'
    , 'json'
    , 'event'
    , 'ack'
    , 'error'
    , 'noop'
  ];

  /**
   * Errors reasons.
   */

  var reasons = parser.reasons = [
      'transport not supported'
    , 'client not handshaken'
    , 'unauthorized'
  ];

  /**
   * Errors advice.
   */

  var advice = parser.advice = [
      'reconnect'
  ];

  /**
   * Shortcuts.
   */

  var JSON = io.JSON
    , indexOf = io.util.indexOf;

  /**
   * Encodes a packet.
   *
   * @api private
   */

  parser.encodePacket = function (packet) {
    var type = indexOf(packets, packet.type)
      , id = packet.id || ''
      , endpoint = packet.endpoint || ''
      , ack = packet.ack
      , data = null;

    switch (packet.type) {
      case 'error':
        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''
          , adv = packet.advice ? indexOf(advice, packet.advice) : '';

        if (reason !== '' || adv !== '')
          data = reason + (adv !== '' ? ('+' + adv) : '');

        break;

      case 'message':
        if (packet.data !== '')
          data = packet.data;
        break;

      case 'event':
        var ev = { name: packet.name };

        if (packet.args && packet.args.length) {
          ev.args = packet.args;
        }

        data = JSON.stringify(ev);
        break;

      case 'json':
        data = JSON.stringify(packet.data);
        break;

      case 'connect':
        if (packet.qs)
          data = packet.qs;
        break;

      case 'ack':
        data = packet.ackId
          + (packet.args && packet.args.length
              ? '+' + JSON.stringify(packet.args) : '');
        break;
    }

    // construct packet with required fragments
    var encoded = [
        type
      , id + (ack == 'data' ? '+' : '')
      , endpoint
    ];

    // data fragment is optional
    if (data !== null && data !== undefined)
      encoded.push(data);

    return encoded.join(':');
  };

  /**
   * Encodes multiple messages (payload).
   *
   * @param {Array} messages
   * @api private
   */

  parser.encodePayload = function (packets) {
    var decoded = '';

    if (packets.length == 1)
      return packets[0];

    for (var i = 0, l = packets.length; i < l; i++) {
      var packet = packets[i];
      decoded += '\ufffd' + packet.length + '\ufffd' + packets[i];
    }

    return decoded;
  };

  /**
   * Decodes a packet
   *
   * @api private
   */

  var regexp = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;

  parser.decodePacket = function (data) {
    var pieces = data.match(regexp);

    if (!pieces) return {};

    var id = pieces[2] || ''
      , data = pieces[5] || ''
      , packet = {
            type: packets[pieces[1]]
          , endpoint: pieces[4] || ''
        };

    // whether we need to acknowledge the packet
    if (id) {
      packet.id = id;
      if (pieces[3])
        packet.ack = 'data';
      else
        packet.ack = true;
    }

    // handle different packet types
    switch (packet.type) {
      case 'error':
        var pieces = data.split('+');
        packet.reason = reasons[pieces[0]] || '';
        packet.advice = advice[pieces[1]] || '';
        break;

      case 'message':
        packet.data = data || '';
        break;

      case 'event':
        try {
          var opts = JSON.parse(data);
          packet.name = opts.name;
          packet.args = opts.args;
        } catch (e) { }

        packet.args = packet.args || [];
        break;

      case 'json':
        try {
          packet.data = JSON.parse(data);
        } catch (e) { }
        break;

      case 'connect':
        packet.qs = data || '';
        break;

      case 'ack':
        var pieces = data.match(/^([0-9]+)(\+)?(.*)/);
        if (pieces) {
          packet.ackId = pieces[1];
          packet.args = [];

          if (pieces[3]) {
            try {
              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];
            } catch (e) { }
          }
        }
        break;

      case 'disconnect':
      case 'heartbeat':
        break;
    };

    return packet;
  };

  /**
   * Decodes data payload. Detects multiple messages
   *
   * @return {Array} messages
   * @api public
   */

  parser.decodePayload = function (data) {
    // IE doesn't like data[i] for unicode chars, charAt works fine
    if (data.charAt(0) == '\ufffd') {
      var ret = [];

      for (var i = 1, length = ''; i < data.length; i++) {
        if (data.charAt(i) == '\ufffd') {
          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));
          i += Number(length) + 1;
          length = '';
        } else {
          length += data.charAt(i);
        }
      }

      return ret;
    } else {
      return [parser.decodePacket(data)];
    }
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.Transport = Transport;

  /**
   * This is the transport template for all supported transport methods.
   *
   * @constructor
   * @api public
   */

  function Transport (socket, sessid) {
    this.socket = socket;
    this.sessid = sessid;
  };

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(Transport, io.EventEmitter);


  /**
   * Indicates whether heartbeats is enabled for this transport
   *
   * @api private
   */

  Transport.prototype.heartbeats = function () {
    return true;
  };

  /**
   * Handles the response from the server. When a new response is received
   * it will automatically update the timeout, decode the message and
   * forwards the response to the onMessage function for further processing.
   *
   * @param {String} data Response from the server.
   * @api private
   */

  Transport.prototype.onData = function (data) {
    this.clearCloseTimeout();

    // If the connection in currently open (or in a reopening state) reset the close
    // timeout since we have just received data. This check is necessary so
    // that we don't reset the timeout on an explicitly disconnected connection.
    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {
      this.setCloseTimeout();
    }

    if (data !== '') {
      // todo: we should only do decodePayload for xhr transports
      var msgs = io.parser.decodePayload(data);

      if (msgs && msgs.length) {
        for (var i = 0, l = msgs.length; i < l; i++) {
          this.onPacket(msgs[i]);
        }
      }
    }

    return this;
  };

  /**
   * Handles packets.
   *
   * @api private
   */

  Transport.prototype.onPacket = function (packet) {
    this.socket.setHeartbeatTimeout();

    if (packet.type == 'heartbeat') {
      return this.onHeartbeat();
    }

    if (packet.type == 'connect' && packet.endpoint == '') {
      this.onConnect();
    }

    if (packet.type == 'error' && packet.advice == 'reconnect') {
      this.isOpen = false;
    }

    this.socket.onPacket(packet);

    return this;
  };

  /**
   * Sets close timeout
   *
   * @api private
   */

  Transport.prototype.setCloseTimeout = function () {
    if (!this.closeTimeout) {
      var self = this;

      this.closeTimeout = setTimeout(function () {
        self.onDisconnect();
      }, this.socket.closeTimeout);
    }
  };

  /**
   * Called when transport disconnects.
   *
   * @api private
   */

  Transport.prototype.onDisconnect = function () {
    if (this.isOpen) this.close();
    this.clearTimeouts();
    this.socket.onDisconnect();
    return this;
  };

  /**
   * Called when transport connects
   *
   * @api private
   */

  Transport.prototype.onConnect = function () {
    this.socket.onConnect();
    return this;
  };

  /**
   * Clears close timeout
   *
   * @api private
   */

  Transport.prototype.clearCloseTimeout = function () {
    if (this.closeTimeout) {
      clearTimeout(this.closeTimeout);
      this.closeTimeout = null;
    }
  };

  /**
   * Clear timeouts
   *
   * @api private
   */

  Transport.prototype.clearTimeouts = function () {
    this.clearCloseTimeout();

    if (this.reopenTimeout) {
      clearTimeout(this.reopenTimeout);
    }
  };

  /**
   * Sends a packet
   *
   * @param {Object} packet object.
   * @api private
   */

  Transport.prototype.packet = function (packet) {
    this.send(io.parser.encodePacket(packet));
  };

  /**
   * Send the received heartbeat message back to server. So the server
   * knows we are still connected.
   *
   * @param {String} heartbeat Heartbeat response from the server.
   * @api private
   */

  Transport.prototype.onHeartbeat = function (heartbeat) {
    this.packet({ type: 'heartbeat' });
  };

  /**
   * Called when the transport opens.
   *
   * @api private
   */

  Transport.prototype.onOpen = function () {
    this.isOpen = true;
    this.clearCloseTimeout();
    this.socket.onOpen();
  };

  /**
   * Notifies the base when the connection with the Socket.IO server
   * has been disconnected.
   *
   * @api private
   */

  Transport.prototype.onClose = function () {
    var self = this;

    /* FIXME: reopen delay causing a infinit loop
    this.reopenTimeout = setTimeout(function () {
      self.open();
    }, this.socket.options['reopen delay']);*/

    this.isOpen = false;
    this.socket.onClose();
    this.onDisconnect();
  };

  /**
   * Generates a connection url based on the Socket.IO URL Protocol.
   * See <https://github.com/learnboost/socket.io-node/> for more details.
   *
   * @returns {String} Connection url
   * @api private
   */

  Transport.prototype.prepareUrl = function () {
    var options = this.socket.options;

    return this.scheme() + '://'
      + options.host + ':' + options.port + '/'
      + options.resource + '/' + io.protocol
      + '/' + this.name + '/' + this.sessid;
  };

  /**
   * Checks if the transport is ready to start a connection.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  Transport.prototype.ready = function (socket, fn) {
    fn.call(this);
  };
})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports.Socket = Socket;

  /**
   * Create a new `Socket.IO client` which can establish a persistent
   * connection with a Socket.IO enabled server.
   *
   * @api public
   */

  function Socket (options) {
    this.options = {
        port: 80
      , secure: false
      , document: 'document' in global ? document : false
      , resource: 'socket.io'
      , transports: io.transports
      , 'connect timeout': 10000
      , 'try multiple transports': true
      , 'reconnect': true
      , 'reconnection delay': 500
      , 'reconnection limit': Infinity
      , 'reopen delay': 3000
      , 'max reconnection attempts': 10
      , 'sync disconnect on unload': false
      , 'auto connect': true
      , 'flash policy port': 10843
      , 'manualFlush': false
    };

    io.util.merge(this.options, options);

    this.connected = false;
    this.open = false;
    this.connecting = false;
    this.reconnecting = false;
    this.namespaces = {};
    this.buffer = [];
    this.doBuffer = false;

    if (this.options['sync disconnect on unload'] &&
        (!this.isXDomain() || io.util.ua.hasCORS)) {
      var self = this;
      io.util.on(global, 'beforeunload', function () {
        self.disconnectSync();
      }, false);
    }

    if (this.options['auto connect']) {
      this.connect();
    }
};

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(Socket, io.EventEmitter);

  /**
   * Returns a namespace listener/emitter for this socket
   *
   * @api public
   */

  Socket.prototype.of = function (name) {
    if (!this.namespaces[name]) {
      this.namespaces[name] = new io.SocketNamespace(this, name);

      if (name !== '') {
        this.namespaces[name].packet({ type: 'connect' });
      }
    }

    return this.namespaces[name];
  };

  /**
   * Emits the given event to the Socket and all namespaces
   *
   * @api private
   */

  Socket.prototype.publish = function () {
    this.emit.apply(this, arguments);

    var nsp;

    for (var i in this.namespaces) {
      if (this.namespaces.hasOwnProperty(i)) {
        nsp = this.of(i);
        nsp.$emit.apply(nsp, arguments);
      }
    }
  };

  /**
   * Performs the handshake
   *
   * @api private
   */

  function empty () { };

  Socket.prototype.handshake = function (fn) {
    var self = this
      , options = this.options;

    function complete (data) {
      if (data instanceof Error) {
        self.connecting = false;
        self.onError(data.message);
      } else {
        fn.apply(null, data.split(':'));
      }
    };

    var url = [
          'http' + (options.secure ? 's' : '') + ':/'
        , options.host + ':' + options.port
        , options.resource
        , io.protocol
        , io.util.query(this.options.query, 't=' + +new Date)
      ].join('/');

    if (this.isXDomain() && !io.util.ua.hasCORS) {
      var insertAt = document.getElementsByTagName('script')[0]
        , script = document.createElement('script');

      script.src = url + '&jsonp=' + io.j.length;
      insertAt.parentNode.insertBefore(script, insertAt);

      io.j.push(function (data) {
        complete(data);
        script.parentNode.removeChild(script);
      });
    } else {
      var xhr = io.util.request();

      xhr.open('GET', url, true);
      if (this.isXDomain()) {
        xhr.withCredentials = true;
      }
      xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
          xhr.onreadystatechange = empty;

          if (xhr.status == 200) {
            complete(xhr.responseText);
          } else if (xhr.status == 403) {
            self.onError(xhr.responseText);
          } else {
            self.connecting = false;            
            !self.reconnecting && self.onError(xhr.responseText);
          }
        }
      };
      xhr.send(null);
    }
  };

  /**
   * Find an available transport based on the options supplied in the constructor.
   *
   * @api private
   */

  Socket.prototype.getTransport = function (override) {
    var transports = override || this.transports, match;

    for (var i = 0, transport; transport = transports[i]; i++) {
      if (io.Transport[transport]
        && io.Transport[transport].check(this)
        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {
        return new io.Transport[transport](this, this.sessionid);
      }
    }

    return null;
  };

  /**
   * Connects to the server.
   *
   * @param {Function} [fn] Callback.
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.connect = function (fn) {
    if (this.connecting) {
      return this;
    }

    var self = this;
    self.connecting = true;
    
    this.handshake(function (sid, heartbeat, close, transports) {
      self.sessionid = sid;
      self.closeTimeout = close * 1000;
      self.heartbeatTimeout = heartbeat * 1000;
      if(!self.transports)
          self.transports = self.origTransports = (transports ? io.util.intersect(
              transports.split(',')
            , self.options.transports
          ) : self.options.transports);

      self.setHeartbeatTimeout();

      function connect (transports){
        if (self.transport) self.transport.clearTimeouts();

        self.transport = self.getTransport(transports);
        if (!self.transport) return self.publish('connect_failed');

        // once the transport is ready
        self.transport.ready(self, function () {
          self.connecting = true;
          self.publish('connecting', self.transport.name);
          self.transport.open();

          if (self.options['connect timeout']) {
            self.connectTimeoutTimer = setTimeout(function () {
              if (!self.connected) {
                self.connecting = false;

                if (self.options['try multiple transports']) {
                  var remaining = self.transports;

                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=
                         self.transport.name) {}

                    if (remaining.length){
                      connect(remaining);
                    } else {
                      self.publish('connect_failed');
                    }
                }
              }
            }, self.options['connect timeout']);
          }
        });
      }

      connect(self.transports);

      self.once('connect', function (){
        clearTimeout(self.connectTimeoutTimer);

        fn && typeof fn == 'function' && fn();
      });
    });

    return this;
  };

  /**
   * Clears and sets a new heartbeat timeout using the value given by the
   * server during the handshake.
   *
   * @api private
   */

  Socket.prototype.setHeartbeatTimeout = function () {
    clearTimeout(this.heartbeatTimeoutTimer);
    if(this.transport && !this.transport.heartbeats()) return;

    var self = this;
    this.heartbeatTimeoutTimer = setTimeout(function () {
      self.transport.onClose();
    }, this.heartbeatTimeout);
  };

  /**
   * Sends a message.
   *
   * @param {Object} data packet.
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.packet = function (data) {
    if (this.connected && !this.doBuffer) {
      this.transport.packet(data);
    } else {
      this.buffer.push(data);
    }

    return this;
  };

  /**
   * Sets buffer state
   *
   * @api private
   */

  Socket.prototype.setBuffer = function (v) {
    this.doBuffer = v;

    if (!v && this.connected && this.buffer.length) {
      if (!this.options['manualFlush']) {
        this.flushBuffer();
      }
    }
  };

  /**
   * Flushes the buffer data over the wire.
   * To be invoked manually when 'manualFlush' is set to true.
   *
   * @api public
   */

  Socket.prototype.flushBuffer = function() {
    this.transport.payload(this.buffer);
    this.buffer = [];
  };
  

  /**
   * Disconnect the established connect.
   *
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.disconnect = function () {
    if (this.connected || this.connecting) {
      if (this.open) {
        this.of('').packet({ type: 'disconnect' });
      }

      // handle disconnection immediately
      this.onDisconnect('booted');
    }

    return this;
  };

  /**
   * Disconnects the socket with a sync XHR.
   *
   * @api private
   */

  Socket.prototype.disconnectSync = function () {
    // ensure disconnection
    var xhr = io.util.request();
    var uri = [
        'http' + (this.options.secure ? 's' : '') + ':/'
      , this.options.host + ':' + this.options.port
      , this.options.resource
      , io.protocol
      , ''
      , this.sessionid
    ].join('/') + '/?disconnect=1';

    xhr.open('GET', uri, false);
    xhr.send(null);

    // handle disconnection immediately
    this.onDisconnect('booted');
  };

  /**
   * Check if we need to use cross domain enabled transports. Cross domain would
   * be a different port or different domain name.
   *
   * @returns {Boolean}
   * @api private
   */

  Socket.prototype.isXDomain = function () {

    var port = global.location.port ||
      ('https:' == global.location.protocol ? 443 : 80);

    return this.options.host !== global.location.hostname 
      || this.options.port != port;
  };

  /**
   * Called upon handshake.
   *
   * @api private
   */

  Socket.prototype.onConnect = function () {
    if (!this.connected) {
      this.connected = true;
      this.connecting = false;
      if (!this.doBuffer) {
        // make sure to flush the buffer
        this.setBuffer(false);
      }
      this.emit('connect');
    }
  };

  /**
   * Called when the transport opens
   *
   * @api private
   */

  Socket.prototype.onOpen = function () {
    this.open = true;
  };

  /**
   * Called when the transport closes.
   *
   * @api private
   */

  Socket.prototype.onClose = function () {
    this.open = false;
    clearTimeout(this.heartbeatTimeoutTimer);
  };

  /**
   * Called when the transport first opens a connection
   *
   * @param text
   */

  Socket.prototype.onPacket = function (packet) {
    this.of(packet.endpoint).onPacket(packet);
  };

  /**
   * Handles an error.
   *
   * @api private
   */

  Socket.prototype.onError = function (err) {
    if (err && err.advice) {
      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {
        this.disconnect();
        if (this.options.reconnect) {
          this.reconnect();
        }
      }
    }

    this.publish('error', err && err.reason ? err.reason : err);
  };

  /**
   * Called when the transport disconnects.
   *
   * @api private
   */

  Socket.prototype.onDisconnect = function (reason) {
    var wasConnected = this.connected
      , wasConnecting = this.connecting;

    this.connected = false;
    this.connecting = false;
    this.open = false;

    if (wasConnected || wasConnecting) {
      this.transport.close();
      this.transport.clearTimeouts();
      if (wasConnected) {
        this.publish('disconnect', reason);

        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {
          this.reconnect();
        }
      }
    }
  };

  /**
   * Called upon reconnection.
   *
   * @api private
   */

  Socket.prototype.reconnect = function () {
    this.reconnecting = true;
    this.reconnectionAttempts = 0;
    this.reconnectionDelay = this.options['reconnection delay'];

    var self = this
      , maxAttempts = this.options['max reconnection attempts']
      , tryMultiple = this.options['try multiple transports']
      , limit = this.options['reconnection limit'];

    function reset () {
      if (self.connected) {
        for (var i in self.namespaces) {
          if (self.namespaces.hasOwnProperty(i) && '' !== i) {
              self.namespaces[i].packet({ type: 'connect' });
          }
        }
        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);
      }

      clearTimeout(self.reconnectionTimer);

      self.removeListener('connect_failed', maybeReconnect);
      self.removeListener('connect', maybeReconnect);

      self.reconnecting = false;

      delete self.reconnectionAttempts;
      delete self.reconnectionDelay;
      delete self.reconnectionTimer;
      delete self.redoTransports;

      self.options['try multiple transports'] = tryMultiple;
    };

    function maybeReconnect () {
      if (!self.reconnecting) {
        return;
      }

      if (self.connected) {
        return reset();
      };

      if (self.connecting && self.reconnecting) {
        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);
      }

      if (self.reconnectionAttempts++ >= maxAttempts) {
        if (!self.redoTransports) {
          self.on('connect_failed', maybeReconnect);
          self.options['try multiple transports'] = true;
          self.transports = self.origTransports;
          self.transport = self.getTransport();
          self.redoTransports = true;
          self.connect();
        } else {
          self.publish('reconnect_failed');
          reset();
        }
      } else {
        if (self.reconnectionDelay < limit) {
          self.reconnectionDelay *= 2; // exponential back off
        }

        self.connect();
        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);
        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);
      }
    };

    this.options['try multiple transports'] = false;
    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);

    this.on('connect', maybeReconnect);
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.SocketNamespace = SocketNamespace;

  /**
   * Socket namespace constructor.
   *
   * @constructor
   * @api public
   */

  function SocketNamespace (socket, name) {
    this.socket = socket;
    this.name = name || '';
    this.flags = {};
    this.json = new Flag(this, 'json');
    this.ackPackets = 0;
    this.acks = {};
  };

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(SocketNamespace, io.EventEmitter);

  /**
   * Copies emit since we override it
   *
   * @api private
   */

  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;

  /**
   * Creates a new namespace, by proxying the request to the socket. This
   * allows us to use the synax as we do on the server.
   *
   * @api public
   */

  SocketNamespace.prototype.of = function () {
    return this.socket.of.apply(this.socket, arguments);
  };

  /**
   * Sends a packet.
   *
   * @api private
   */

  SocketNamespace.prototype.packet = function (packet) {
    packet.endpoint = this.name;
    this.socket.packet(packet);
    this.flags = {};
    return this;
  };

  /**
   * Sends a message
   *
   * @api public
   */

  SocketNamespace.prototype.send = function (data, fn) {
    var packet = {
        type: this.flags.json ? 'json' : 'message'
      , data: data
    };

    if ('function' == typeof fn) {
      packet.id = ++this.ackPackets;
      packet.ack = true;
      this.acks[packet.id] = fn;
    }

    return this.packet(packet);
  };

  /**
   * Emits an event
   *
   * @api public
   */
  
  SocketNamespace.prototype.emit = function (name) {
    var args = Array.prototype.slice.call(arguments, 1)
      , lastArg = args[args.length - 1]
      , packet = {
            type: 'event'
          , name: name
        };

    if ('function' == typeof lastArg) {
      packet.id = ++this.ackPackets;
      packet.ack = 'data';
      this.acks[packet.id] = lastArg;
      args = args.slice(0, args.length - 1);
    }

    packet.args = args;

    return this.packet(packet);
  };

  /**
   * Disconnects the namespace
   *
   * @api private
   */

  SocketNamespace.prototype.disconnect = function () {
    if (this.name === '') {
      this.socket.disconnect();
    } else {
      this.packet({ type: 'disconnect' });
      this.$emit('disconnect');
    }

    return this;
  };

  /**
   * Handles a packet
   *
   * @api private
   */

  SocketNamespace.prototype.onPacket = function (packet) {
    var self = this;

    function ack () {
      self.packet({
          type: 'ack'
        , args: io.util.toArray(arguments)
        , ackId: packet.id
      });
    };

    switch (packet.type) {
      case 'connect':
        this.$emit('connect');
        break;

      case 'disconnect':
        if (this.name === '') {
          this.socket.onDisconnect(packet.reason || 'booted');
        } else {
          this.$emit('disconnect', packet.reason);
        }
        break;

      case 'message':
      case 'json':
        var params = ['message', packet.data];

        if (packet.ack == 'data') {
          params.push(ack);
        } else if (packet.ack) {
          this.packet({ type: 'ack', ackId: packet.id });
        }

        this.$emit.apply(this, params);
        break;

      case 'event':
        var params = [packet.name].concat(packet.args);

        if (packet.ack == 'data')
          params.push(ack);

        this.$emit.apply(this, params);
        break;

      case 'ack':
        if (this.acks[packet.ackId]) {
          this.acks[packet.ackId].apply(this, packet.args);
          delete this.acks[packet.ackId];
        }
        break;

      case 'error':
        if (packet.advice){
          this.socket.onError(packet);
        } else {
          if (packet.reason == 'unauthorized') {
            this.$emit('connect_failed', packet.reason);
          } else {
            this.$emit('error', packet.reason);
          }
        }
        break;
    }
  };

  /**
   * Flag interface.
   *
   * @api private
   */

  function Flag (nsp, name) {
    this.namespace = nsp;
    this.name = name;
  };

  /**
   * Send a message
   *
   * @api public
   */

  Flag.prototype.send = function () {
    this.namespace.flags[this.name] = true;
    this.namespace.send.apply(this.namespace, arguments);
  };

  /**
   * Emit an event
   *
   * @api public
   */

  Flag.prototype.emit = function () {
    this.namespace.flags[this.name] = true;
    this.namespace.emit.apply(this.namespace, arguments);
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports.websocket = WS;

  /**
   * The WebSocket transport uses the HTML5 WebSocket API to establish an
   * persistent connection with the Socket.IO server. This transport will also
   * be inherited by the FlashSocket fallback as it provides a API compatible
   * polyfill for the WebSockets.
   *
   * @constructor
   * @extends {io.Transport}
   * @api public
   */

  function WS (socket) {
    io.Transport.apply(this, arguments);
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(WS, io.Transport);

  /**
   * Transport name
   *
   * @api public
   */

  WS.prototype.name = 'websocket';

  /**
   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach
   * all the appropriate listeners to handle the responses from the server.
   *
   * @returns {Transport}
   * @api public
   */

  WS.prototype.open = function () {
    var query = io.util.query(this.socket.options.query)
      , self = this
      , Socket


    if (!Socket) {
      Socket = global.MozWebSocket || global.WebSocket;
    }

    this.websocket = new Socket(this.prepareUrl() + query);

    this.websocket.onopen = function () {
      self.onOpen();
      self.socket.setBuffer(false);
    };
    this.websocket.onmessage = function (ev) {
      self.onData(ev.data);
    };
    this.websocket.onclose = function () {
      self.onClose();
      self.socket.setBuffer(true);
    };
    this.websocket.onerror = function (e) {
      self.onError(e);
    };

    return this;
  };

  /**
   * Send a message to the Socket.IO server. The message will automatically be
   * encoded in the correct message format.
   *
   * @returns {Transport}
   * @api public
   */

  // Do to a bug in the current IDevices browser, we need to wrap the send in a 
  // setTimeout, when they resume from sleeping the browser will crash if 
  // we don't allow the browser time to detect the socket has been closed
  if (io.util.ua.iDevice) {
    WS.prototype.send = function (data) {
      var self = this;
      setTimeout(function() {
         self.websocket.send(data);
      },0);
      return this;
    };
  } else {
    WS.prototype.send = function (data) {
      this.websocket.send(data);
      return this;
    };
  }

  /**
   * Payload
   *
   * @api private
   */

  WS.prototype.payload = function (arr) {
    for (var i = 0, l = arr.length; i < l; i++) {
      this.packet(arr[i]);
    }
    return this;
  };

  /**
   * Disconnect the established `WebSocket` connection.
   *
   * @returns {Transport}
   * @api public
   */

  WS.prototype.close = function () {
    this.websocket.close();
    return this;
  };

  /**
   * Handle the errors that `WebSocket` might be giving when we
   * are attempting to connect or send messages.
   *
   * @param {Error} e The error.
   * @api private
   */

  WS.prototype.onError = function (e) {
    this.socket.onError(e);
  };

  /**
   * Returns the appropriate scheme for the URI generation.
   *
   * @api private
   */
  WS.prototype.scheme = function () {
    return this.socket.options.secure ? 'wss' : 'ws';
  };

  /**
   * Checks if the browser has support for native `WebSockets` and that
   * it's not the polyfill created for the FlashSocket transport.
   *
   * @return {Boolean}
   * @api public
   */

  WS.check = function () {
    return ('WebSocket' in global && !('__addTask' in WebSocket))
          || 'MozWebSocket' in global;
  };

  /**
   * Check if the `WebSocket` transport support cross domain communications.
   *
   * @returns {Boolean}
   * @api public
   */

  WS.xdomainCheck = function () {
    return true;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('websocket');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.flashsocket = Flashsocket;

  /**
   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket
   * specification. It uses a .swf file to communicate with the server. If you want
   * to serve the .swf file from a other server than where the Socket.IO script is
   * coming from you need to use the insecure version of the .swf. More information
   * about this can be found on the github page.
   *
   * @constructor
   * @extends {io.Transport.websocket}
   * @api public
   */

  function Flashsocket () {
    io.Transport.websocket.apply(this, arguments);
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(Flashsocket, io.Transport.websocket);

  /**
   * Transport name
   *
   * @api public
   */

  Flashsocket.prototype.name = 'flashsocket';

  /**
   * Disconnect the established `FlashSocket` connection. This is done by adding a 
   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` 
   * transport.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.open = function () {
    var self = this
      , args = arguments;

    WebSocket.__addTask(function () {
      io.Transport.websocket.prototype.open.apply(self, args);
    });
    return this;
  };
  
  /**
   * Sends a message to the Socket.IO server. This is done by adding a new
   * task to the FlashSocket. The rest will be handled off by the `WebSocket` 
   * transport.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.send = function () {
    var self = this, args = arguments;
    WebSocket.__addTask(function () {
      io.Transport.websocket.prototype.send.apply(self, args);
    });
    return this;
  };

  /**
   * Disconnects the established `FlashSocket` connection.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.close = function () {
    WebSocket.__tasks.length = 0;
    io.Transport.websocket.prototype.close.call(this);
    return this;
  };

  /**
   * The WebSocket fall back needs to append the flash container to the body
   * element, so we need to make sure we have access to it. Or defer the call
   * until we are sure there is a body element.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  Flashsocket.prototype.ready = function (socket, fn) {
    function init () {
      var options = socket.options
        , port = options['flash policy port']
        , path = [
              'http' + (options.secure ? 's' : '') + ':/'
            , options.host + ':' + options.port
            , options.resource
            , 'static/flashsocket'
            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'
          ];

      // Only start downloading the swf file when the checked that this browser
      // actually supports it
      if (!Flashsocket.loaded) {
        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {
          // Set the correct file based on the XDomain settings
          WEB_SOCKET_SWF_LOCATION = path.join('/');
        }

        if (port !== 843) {
          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);
        }

        WebSocket.__initialize();
        Flashsocket.loaded = true;
      }

      fn.call(self);
    }

    var self = this;
    if (document.body) return init();

    io.util.load(init);
  };

  /**
   * Check if the FlashSocket transport is supported as it requires that the Adobe
   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if
   * the polyfill is correctly loaded.
   *
   * @returns {Boolean}
   * @api public
   */

  Flashsocket.check = function () {
    if (
        typeof WebSocket == 'undefined'
      || !('__initialize' in WebSocket) || !swfobject
    ) return false;

    return swfobject.getFlashPlayerVersion().major >= 10;
  };

  /**
   * Check if the FlashSocket transport can be used as cross domain / cross origin 
   * transport. Because we can't see which type (secure or insecure) of .swf is used
   * we will just return true.
   *
   * @returns {Boolean}
   * @api public
   */

  Flashsocket.xdomainCheck = function () {
    return true;
  };

  /**
   * Disable AUTO_INITIALIZATION
   */

  if (typeof window != 'undefined') {
    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;
  }

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('flashsocket');
})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/
if ('undefined' != typeof window) {
var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O[(['Active'].concat('Object').join('X'))]!=D){try{var ad=new window[(['Active'].concat('Object').join('X'))](W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?(['Active'].concat('').join('X')):"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();
}
// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>
// License: New BSD License
// Reference: http://dev.w3.org/html5/websockets/
// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol

(function() {
  
  if ('undefined' == typeof window || window.WebSocket) return;

  var console = window.console;
  if (!console || !console.log || !console.error) {
    console = {log: function(){ }, error: function(){ }};
  }
  
  if (!swfobject.hasFlashPlayerVersion("10.0.0")) {
    console.error("Flash Player >= 10.0.0 is required.");
    return;
  }
  if (location.protocol == "file:") {
    console.error(
      "WARNING: web-socket-js doesn't work in file:///... URL " +
      "unless you set Flash Security Settings properly. " +
      "Open the page via Web server i.e. http://...");
  }

  /**
   * This class represents a faux web socket.
   * @param {string} url
   * @param {array or string} protocols
   * @param {string} proxyHost
   * @param {int} proxyPort
   * @param {string} headers
   */
  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {
    var self = this;
    self.__id = WebSocket.__nextId++;
    WebSocket.__instances[self.__id] = self;
    self.readyState = WebSocket.CONNECTING;
    self.bufferedAmount = 0;
    self.__events = {};
    if (!protocols) {
      protocols = [];
    } else if (typeof protocols == "string") {
      protocols = [protocols];
    }
    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.
    // Otherwise, when onopen fires immediately, onopen is called before it is set.
    setTimeout(function() {
      WebSocket.__addTask(function() {
        WebSocket.__flash.create(
            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);
      });
    }, 0);
  };

  /**
   * Send data to the web socket.
   * @param {string} data  The data to send to the socket.
   * @return {boolean}  True for success, false for failure.
   */
  WebSocket.prototype.send = function(data) {
    if (this.readyState == WebSocket.CONNECTING) {
      throw "INVALID_STATE_ERR: Web Socket connection has not been established";
    }
    // We use encodeURIComponent() here, because FABridge doesn't work if
    // the argument includes some characters. We don't use escape() here
    // because of this:
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions
    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't
    // preserve all Unicode characters either e.g. "\uffff" in Firefox.
    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require
    // additional testing.
    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));
    if (result < 0) { // success
      return true;
    } else {
      this.bufferedAmount += result;
      return false;
    }
  };

  /**
   * Close this web socket gracefully.
   */
  WebSocket.prototype.close = function() {
    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {
      return;
    }
    this.readyState = WebSocket.CLOSING;
    WebSocket.__flash.close(this.__id);
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {string} type
   * @param {function} listener
   * @param {boolean} useCapture
   * @return void
   */
  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {
    if (!(type in this.__events)) {
      this.__events[type] = [];
    }
    this.__events[type].push(listener);
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {string} type
   * @param {function} listener
   * @param {boolean} useCapture
   * @return void
   */
  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {
    if (!(type in this.__events)) return;
    var events = this.__events[type];
    for (var i = events.length - 1; i >= 0; --i) {
      if (events[i] === listener) {
        events.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {Event} event
   * @return void
   */
  WebSocket.prototype.dispatchEvent = function(event) {
    var events = this.__events[event.type] || [];
    for (var i = 0; i < events.length; ++i) {
      events[i](event);
    }
    var handler = this["on" + event.type];
    if (handler) handler(event);
  };

  /**
   * Handles an event from Flash.
   * @param {Object} flashEvent
   */
  WebSocket.prototype.__handleEvent = function(flashEvent) {
    if ("readyState" in flashEvent) {
      this.readyState = flashEvent.readyState;
    }
    if ("protocol" in flashEvent) {
      this.protocol = flashEvent.protocol;
    }
    
    var jsEvent;
    if (flashEvent.type == "open" || flashEvent.type == "error") {
      jsEvent = this.__createSimpleEvent(flashEvent.type);
    } else if (flashEvent.type == "close") {
      // TODO implement jsEvent.wasClean
      jsEvent = this.__createSimpleEvent("close");
    } else if (flashEvent.type == "message") {
      var data = decodeURIComponent(flashEvent.message);
      jsEvent = this.__createMessageEvent("message", data);
    } else {
      throw "unknown event type: " + flashEvent.type;
    }
    
    this.dispatchEvent(jsEvent);
  };
  
  WebSocket.prototype.__createSimpleEvent = function(type) {
    if (document.createEvent && window.Event) {
      var event = document.createEvent("Event");
      event.initEvent(type, false, false);
      return event;
    } else {
      return {type: type, bubbles: false, cancelable: false};
    }
  };
  
  WebSocket.prototype.__createMessageEvent = function(type, data) {
    if (document.createEvent && window.MessageEvent && !window.opera) {
      var event = document.createEvent("MessageEvent");
      event.initMessageEvent("message", false, false, data, null, null, window, null);
      return event;
    } else {
      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.
      return {type: type, data: data, bubbles: false, cancelable: false};
    }
  };
  
  /**
   * Define the WebSocket readyState enumeration.
   */
  WebSocket.CONNECTING = 0;
  WebSocket.OPEN = 1;
  WebSocket.CLOSING = 2;
  WebSocket.CLOSED = 3;

  WebSocket.__flash = null;
  WebSocket.__instances = {};
  WebSocket.__tasks = [];
  WebSocket.__nextId = 0;
  
  /**
   * Load a new flash security policy file.
   * @param {string} url
   */
  WebSocket.loadFlashPolicyFile = function(url){
    WebSocket.__addTask(function() {
      WebSocket.__flash.loadManualPolicyFile(url);
    });
  };

  /**
   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.
   */
  WebSocket.__initialize = function() {
    if (WebSocket.__flash) return;
    
    if (WebSocket.__swfLocation) {
      // For backword compatibility.
      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;
    }
    if (!window.WEB_SOCKET_SWF_LOCATION) {
      console.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
      return;
    }
    var container = document.createElement("div");
    container.id = "webSocketContainer";
    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents
    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).
    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash
    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is
    // the best we can do as far as we know now.
    container.style.position = "absolute";
    if (WebSocket.__isFlashLite()) {
      container.style.left = "0px";
      container.style.top = "0px";
    } else {
      container.style.left = "-100px";
      container.style.top = "-100px";
    }
    var holder = document.createElement("div");
    holder.id = "webSocketFlash";
    container.appendChild(holder);
    document.body.appendChild(container);
    // See this article for hasPriority:
    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html
    swfobject.embedSWF(
      WEB_SOCKET_SWF_LOCATION,
      "webSocketFlash",
      "1" /* width */,
      "1" /* height */,
      "10.0.0" /* SWF version */,
      null,
      null,
      {hasPriority: true, swliveconnect : true, allowScriptAccess: "always"},
      null,
      function(e) {
        if (!e.success) {
          console.error("[WebSocket] swfobject.embedSWF failed");
        }
      });
  };
  
  /**
   * Called by Flash to notify JS that it's fully loaded and ready
   * for communication.
   */
  WebSocket.__onFlashInitialized = function() {
    // We need to set a timeout here to avoid round-trip calls
    // to flash during the initialization process.
    setTimeout(function() {
      WebSocket.__flash = document.getElementById("webSocketFlash");
      WebSocket.__flash.setCallerUrl(location.href);
      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
      for (var i = 0; i < WebSocket.__tasks.length; ++i) {
        WebSocket.__tasks[i]();
      }
      WebSocket.__tasks = [];
    }, 0);
  };
  
  /**
   * Called by Flash to notify WebSockets events are fired.
   */
  WebSocket.__onFlashEvent = function() {
    setTimeout(function() {
      try {
        // Gets events using receiveEvents() instead of getting it from event object
        // of Flash event. This is to make sure to keep message order.
        // It seems sometimes Flash events don't arrive in the same order as they are sent.
        var events = WebSocket.__flash.receiveEvents();
        for (var i = 0; i < events.length; ++i) {
          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);
        }
      } catch (e) {
        console.error(e);
      }
    }, 0);
    return true;
  };
  
  // Called by Flash.
  WebSocket.__log = function(message) {
    console.log(decodeURIComponent(message));
  };
  
  // Called by Flash.
  WebSocket.__error = function(message) {
    console.error(decodeURIComponent(message));
  };
  
  WebSocket.__addTask = function(task) {
    if (WebSocket.__flash) {
      task();
    } else {
      WebSocket.__tasks.push(task);
    }
  };
  
  /**
   * Test if the browser is running flash lite.
   * @return {boolean} True if flash lite is running, false otherwise.
   */
  WebSocket.__isFlashLite = function() {
    if (!window.navigator || !window.navigator.mimeTypes) {
      return false;
    }
    var mimeType = window.navigator.mimeTypes["application/x-shockwave-flash"];
    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {
      return false;
    }
    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;
  };
  
  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {
    if (window.addEventListener) {
      window.addEventListener("load", function(){
        WebSocket.__initialize();
      }, false);
    } else {
      window.attachEvent("onload", function(){
        WebSocket.__initialize();
      });
    }
  }
  
})();

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   *
   * @api public
   */

  exports.XHR = XHR;

  /**
   * XHR constructor
   *
   * @costructor
   * @api public
   */

  function XHR (socket) {
    if (!socket) return;

    io.Transport.apply(this, arguments);
    this.sendBuffer = [];
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(XHR, io.Transport);

  /**
   * Establish a connection
   *
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.open = function () {
    this.socket.setBuffer(false);
    this.onOpen();
    this.get();

    // we need to make sure the request succeeds since we have no indication
    // whether the request opened or not until it succeeded.
    this.setCloseTimeout();

    return this;
  };

  /**
   * Check if we need to send data to the Socket.IO server, if we have data in our
   * buffer we encode it and forward it to the `post` method.
   *
   * @api private
   */

  XHR.prototype.payload = function (payload) {
    var msgs = [];

    for (var i = 0, l = payload.length; i < l; i++) {
      msgs.push(io.parser.encodePacket(payload[i]));
    }

    this.send(io.parser.encodePayload(msgs));
  };

  /**
   * Send data to the Socket.IO server.
   *
   * @param data The message
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.send = function (data) {
    this.post(data);
    return this;
  };

  /**
   * Posts a encoded message to the Socket.IO server.
   *
   * @param {String} data A encoded message.
   * @api private
   */

  function empty () { };

  XHR.prototype.post = function (data) {
    var self = this;
    this.socket.setBuffer(true);

    function stateChange () {
      if (this.readyState == 4) {
        this.onreadystatechange = empty;
        self.posting = false;

        if (this.status == 200){
          self.socket.setBuffer(false);
        } else {
          self.onClose();
        }
      }
    }

    function onload () {
      this.onload = empty;
      self.socket.setBuffer(false);
    };

    this.sendXHR = this.request('POST');

    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {
      this.sendXHR.onload = this.sendXHR.onerror = onload;
    } else {
      this.sendXHR.onreadystatechange = stateChange;
    }

    this.sendXHR.send(data);
  };

  /**
   * Disconnects the established `XHR` connection.
   *
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.close = function () {
    this.onClose();
    return this;
  };

  /**
   * Generates a configured XHR request
   *
   * @param {String} url The url that needs to be requested.
   * @param {String} method The method the request should use.
   * @returns {XMLHttpRequest}
   * @api private
   */

  XHR.prototype.request = function (method) {
    var req = io.util.request(this.socket.isXDomain())
      , query = io.util.query(this.socket.options.query, 't=' + +new Date);

    req.open(method || 'GET', this.prepareUrl() + query, true);

    if (method == 'POST') {
      try {
        if (req.setRequestHeader) {
          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        } else {
          // XDomainRequest
          req.contentType = 'text/plain';
        }
      } catch (e) {}
    }

    return req;
  };

  /**
   * Returns the scheme to use for the transport URLs.
   *
   * @api private
   */

  XHR.prototype.scheme = function () {
    return this.socket.options.secure ? 'https' : 'http';
  };

  /**
   * Check if the XHR transports are supported
   *
   * @param {Boolean} xdomain Check if we support cross domain requests.
   * @returns {Boolean}
   * @api public
   */

  XHR.check = function (socket, xdomain) {
    try {
      var request = io.util.request(xdomain),
          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),
          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),
          isXProtocol = (global.location && socketProtocol != global.location.protocol);
      if (request && !(usesXDomReq && isXProtocol)) {
        return true;
      }
    } catch(e) {}

    return false;
  };

  /**
   * Check if the XHR transport supports cross domain requests.
   *
   * @returns {Boolean}
   * @api public
   */

  XHR.xdomainCheck = function (socket) {
    return XHR.check(socket, true);
  };

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.htmlfile = HTMLFile;

  /**
   * The HTMLFile transport creates a `forever iframe` based transport
   * for Internet Explorer. Regular forever iframe implementations will 
   * continuously trigger the browsers buzy indicators. If the forever iframe
   * is created inside a `htmlfile` these indicators will not be trigged.
   *
   * @constructor
   * @extends {io.Transport.XHR}
   * @api public
   */

  function HTMLFile (socket) {
    io.Transport.XHR.apply(this, arguments);
  };

  /**
   * Inherits from XHR transport.
   */

  io.util.inherit(HTMLFile, io.Transport.XHR);

  /**
   * Transport name
   *
   * @api public
   */

  HTMLFile.prototype.name = 'htmlfile';

  /**
   * Creates a new Ac...eX `htmlfile` with a forever loading iframe
   * that can be used to listen to messages. Inside the generated
   * `htmlfile` a reference will be made to the HTMLFile transport.
   *
   * @api private
   */

  HTMLFile.prototype.get = function () {
    this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
    this.doc.open();
    this.doc.write('<html></html>');
    this.doc.close();
    this.doc.parentWindow.s = this;

    var iframeC = this.doc.createElement('div');
    iframeC.className = 'socketio';

    this.doc.body.appendChild(iframeC);
    this.iframe = this.doc.createElement('iframe');

    iframeC.appendChild(this.iframe);

    var self = this
      , query = io.util.query(this.socket.options.query, 't='+ +new Date);

    this.iframe.src = this.prepareUrl() + query;

    io.util.on(window, 'unload', function () {
      self.destroy();
    });
  };

  /**
   * The Socket.IO server will write script tags inside the forever
   * iframe, this function will be used as callback for the incoming
   * information.
   *
   * @param {String} data The message
   * @param {document} doc Reference to the context
   * @api private
   */

  HTMLFile.prototype._ = function (data, doc) {
    // unescape all forward slashes. see GH-1251
    data = data.replace(/\\\//g, '/');
    this.onData(data);
    try {
      var script = doc.getElementsByTagName('script')[0];
      script.parentNode.removeChild(script);
    } catch (e) { }
  };

  /**
   * Destroy the established connection, iframe and `htmlfile`.
   * And calls the `CollectGarbage` function of Internet Explorer
   * to release the memory.
   *
   * @api private
   */

  HTMLFile.prototype.destroy = function () {
    if (this.iframe){
      try {
        this.iframe.src = 'about:blank';
      } catch(e){}

      this.doc = null;
      this.iframe.parentNode.removeChild(this.iframe);
      this.iframe = null;

      CollectGarbage();
    }
  };

  /**
   * Disconnects the established connection.
   *
   * @returns {Transport} Chaining.
   * @api public
   */

  HTMLFile.prototype.close = function () {
    this.destroy();
    return io.Transport.XHR.prototype.close.call(this);
  };

  /**
   * Checks if the browser supports this transport. The browser
   * must have an `Ac...eXObject` implementation.
   *
   * @return {Boolean}
   * @api public
   */

  HTMLFile.check = function (socket) {
    if (typeof window != "undefined" && (['Active'].concat('Object').join('X')) in window){
      try {
        var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
        return a && io.Transport.XHR.check(socket);
      } catch(e){}
    }
    return false;
  };

  /**
   * Check if cross domain requests are supported.
   *
   * @returns {Boolean}
   * @api public
   */

  HTMLFile.xdomainCheck = function () {
    // we can probably do handling for sub-domains, we should
    // test that it's cross domain but a subdomain here
    return false;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('htmlfile');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports['xhr-polling'] = XHRPolling;

  /**
   * The XHR-polling transport uses long polling XHR requests to create a
   * "persistent" connection with the server.
   *
   * @constructor
   * @api public
   */

  function XHRPolling () {
    io.Transport.XHR.apply(this, arguments);
  };

  /**
   * Inherits from XHR transport.
   */

  io.util.inherit(XHRPolling, io.Transport.XHR);

  /**
   * Merge the properties from XHR transport
   */

  io.util.merge(XHRPolling, io.Transport.XHR);

  /**
   * Transport name
   *
   * @api public
   */

  XHRPolling.prototype.name = 'xhr-polling';

  /**
   * Indicates whether heartbeats is enabled for this transport
   *
   * @api private
   */

  XHRPolling.prototype.heartbeats = function () {
    return false;
  };

  /** 
   * Establish a connection, for iPhone and Android this will be done once the page
   * is loaded.
   *
   * @returns {Transport} Chaining.
   * @api public
   */

  XHRPolling.prototype.open = function () {
    var self = this;

    io.Transport.XHR.prototype.open.call(self);
    return false;
  };

  /**
   * Starts a XHR request to wait for incoming messages.
   *
   * @api private
   */

  function empty () {};

  XHRPolling.prototype.get = function () {
    if (!this.isOpen) return;

    var self = this;

    function stateChange () {
      if (this.readyState == 4) {
        this.onreadystatechange = empty;

        if (this.status == 200) {
          self.onData(this.responseText);
          self.get();
        } else {
          self.onClose();
        }
      }
    };

    function onload () {
      this.onload = empty;
      this.onerror = empty;
      self.retryCounter = 1;
      self.onData(this.responseText);
      self.get();
    };

    function onerror () {
      self.retryCounter ++;
      if(!self.retryCounter || self.retryCounter > 3) {
        self.onClose();  
      } else {
        self.get();
      }
    };

    this.xhr = this.request();

    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {
      this.xhr.onload = onload;
      this.xhr.onerror = onerror;
    } else {
      this.xhr.onreadystatechange = stateChange;
    }

    this.xhr.send(null);
  };

  /**
   * Handle the unclean close behavior.
   *
   * @api private
   */

  XHRPolling.prototype.onClose = function () {
    io.Transport.XHR.prototype.onClose.call(this);

    if (this.xhr) {
      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;
      try {
        this.xhr.abort();
      } catch(e){}
      this.xhr = null;
    }
  };

  /**
   * Webkit based browsers show a infinit spinner when you start a XHR request
   * before the browsers onload event is called so we need to defer opening of
   * the transport until the onload event is called. Wrapping the cb in our
   * defer method solve this.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  XHRPolling.prototype.ready = function (socket, fn) {
    var self = this;

    io.util.defer(function () {
      fn.call(self);
    });
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('xhr-polling');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {
  /**
   * There is a way to hide the loading indicator in Firefox. If you create and
   * remove a iframe it will stop showing the current loading indicator.
   * Unfortunately we can't feature detect that and UA sniffing is evil.
   *
   * @api private
   */

  var indicator = global.document && "MozAppearance" in
    global.document.documentElement.style;

  /**
   * Expose constructor.
   */

  exports['jsonp-polling'] = JSONPPolling;

  /**
   * The JSONP transport creates an persistent connection by dynamically
   * inserting a script tag in the page. This script tag will receive the
   * information of the Socket.IO server. When new information is received
   * it creates a new script tag for the new data stream.
   *
   * @constructor
   * @extends {io.Transport.xhr-polling}
   * @api public
   */

  function JSONPPolling (socket) {
    io.Transport['xhr-polling'].apply(this, arguments);

    this.index = io.j.length;

    var self = this;

    io.j.push(function (msg) {
      self._(msg);
    });
  };

  /**
   * Inherits from XHR polling transport.
   */

  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);

  /**
   * Transport name
   *
   * @api public
   */

  JSONPPolling.prototype.name = 'jsonp-polling';

  /**
   * Posts a encoded message to the Socket.IO server using an iframe.
   * The iframe is used because script tags can create POST based requests.
   * The iframe is positioned outside of the view so the user does not
   * notice it's existence.
   *
   * @param {String} data A encoded message.
   * @api private
   */

  JSONPPolling.prototype.post = function (data) {
    var self = this
      , query = io.util.query(
             this.socket.options.query
          , 't='+ (+new Date) + '&i=' + this.index
        );

    if (!this.form) {
      var form = document.createElement('form')
        , area = document.createElement('textarea')
        , id = this.iframeId = 'socketio_iframe_' + this.index
        , iframe;

      form.className = 'socketio';
      form.style.position = 'absolute';
      form.style.top = '0px';
      form.style.left = '0px';
      form.style.display = 'none';
      form.target = id;
      form.method = 'POST';
      form.setAttribute('accept-charset', 'utf-8');
      area.name = 'd';
      form.appendChild(area);
      document.body.appendChild(form);

      this.form = form;
      this.area = area;
    }

    this.form.action = this.prepareUrl() + query;

    function complete () {
      initIframe();
      self.socket.setBuffer(false);
    };

    function initIframe () {
      if (self.iframe) {
        self.form.removeChild(self.iframe);
      }

      try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        iframe = document.createElement('<iframe name="'+ self.iframeId +'">');
      } catch (e) {
        iframe = document.createElement('iframe');
        iframe.name = self.iframeId;
      }

      iframe.id = self.iframeId;

      self.form.appendChild(iframe);
      self.iframe = iframe;
    };

    initIframe();

    // we temporarily stringify until we figure out how to prevent
    // browsers from turning `\n` into `\r\n` in form inputs
    this.area.value = io.JSON.stringify(data);

    try {
      this.form.submit();
    } catch(e) {}

    if (this.iframe.attachEvent) {
      iframe.onreadystatechange = function () {
        if (self.iframe.readyState == 'complete') {
          complete();
        }
      };
    } else {
      this.iframe.onload = complete;
    }

    this.socket.setBuffer(true);
  };

  /**
   * Creates a new JSONP poll that can be used to listen
   * for messages from the Socket.IO server.
   *
   * @api private
   */

  JSONPPolling.prototype.get = function () {
    var self = this
      , script = document.createElement('script')
      , query = io.util.query(
             this.socket.options.query
          , 't='+ (+new Date) + '&i=' + this.index
        );

    if (this.script) {
      this.script.parentNode.removeChild(this.script);
      this.script = null;
    }

    script.async = true;
    script.src = this.prepareUrl() + query;
    script.onerror = function () {
      self.onClose();
    };

    var insertAt = document.getElementsByTagName('script')[0];
    insertAt.parentNode.insertBefore(script, insertAt);
    this.script = script;

    if (indicator) {
      setTimeout(function () {
        var iframe = document.createElement('iframe');
        document.body.appendChild(iframe);
        document.body.removeChild(iframe);
      }, 100);
    }
  };

  /**
   * Callback function for the incoming message stream from the Socket.IO server.
   *
   * @param {String} data The message
   * @api private
   */

  JSONPPolling.prototype._ = function (msg) {
    this.onData(msg);
    if (this.isOpen) {
      this.get();
    }
    return this;
  };

  /**
   * The indicator hack only works after onload
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  JSONPPolling.prototype.ready = function (socket, fn) {
    var self = this;
    if (!indicator) return fn.call(this);

    io.util.load(function () {
      fn.call(self);
    });
  };

  /**
   * Checks if browser supports this transport.
   *
   * @return {Boolean}
   * @api public
   */

  JSONPPolling.check = function () {
    return 'document' in global;
  };

  /**
   * Check if cross domain requests are supported
   *
   * @returns {Boolean}
   * @api public
   */

  JSONPPolling.xdomainCheck = function () {
    return true;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('jsonp-polling');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

if (typeof define === "function" && define.amd) {
  define([], function () { return io; });
}
})();
},{}],13:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],12:[function(require,module,exports){
var process=require("__browserify_process");if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (typeof emitter._events[type] === 'function')
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

},{"__browserify_process":13}],9:[function(require,module,exports){
var util = require('util');
var webrtc = require('webrtcsupport');
var PeerConnection = require('rtcpeerconnection');
var WildEmitter = require('wildemitter');
var FileTransfer = require('filetransfer');

// the inband-v1 protocol is sending metadata inband in a serialized JSON object
// followed by the actual data. Receiver closes the datachannel upon completion
var INBAND_FILETRANSFER_V1 = 'https://simplewebrtc.com/protocol/filetransfer#inband-v1';

function Peer(options) {
    var self = this;

    this.id = options.id;
    this.parent = options.parent;
    this.type = options.type || 'video';
    this.oneway = options.oneway || false;
    this.sharemyscreen = options.sharemyscreen || false;
    this.browserPrefix = options.prefix;
    this.stream = options.stream;
    this.enableDataChannels = options.enableDataChannels === undefined ? this.parent.config.enableDataChannels : options.enableDataChannels;
    this.receiveMedia = options.receiveMedia || this.parent.config.receiveMedia;
    this.channels = {};
    this.sid = options.sid || Date.now().toString();
    // Create an RTCPeerConnection via the polyfill
    this.pc = new PeerConnection(this.parent.config.peerConnectionConfig, this.parent.config.peerConnectionConstraints);
    this.pc.on('ice', this.onIceCandidate.bind(this));
    this.pc.on('offer', function (offer) {
        self.send('offer', offer);
    });
    this.pc.on('answer', function (offer) {
        self.send('answer', offer);
    });
    this.pc.on('addStream', this.handleRemoteStreamAdded.bind(this));
    this.pc.on('addChannel', this.handleDataChannelAdded.bind(this));
    this.pc.on('removeStream', this.handleStreamRemoved.bind(this));
    // Just fire negotiation needed events for now
    // When browser re-negotiation handling seems to work
    // we can use this as the trigger for starting the offer/answer process
    // automatically. We'll just leave it be for now while this stabalizes.
    this.pc.on('negotiationNeeded', this.emit.bind(this, 'negotiationNeeded'));
    this.pc.on('iceConnectionStateChange', this.emit.bind(this, 'iceConnectionStateChange'));
    this.pc.on('iceConnectionStateChange', function () {
        switch (self.pc.iceConnectionState) {
        case 'failed':
            // currently, in chrome only the initiator goes to failed
            // so we need to signal this to the peer
            if (self.pc.pc.peerconnection.localDescription.type === 'offer') {
                self.parent.emit('iceFailed', self);
                self.send('connectivityError');
            }
            break;
        }
    });
    this.pc.on('signalingStateChange', this.emit.bind(this, 'signalingStateChange'));
    this.logger = this.parent.logger;

    // handle screensharing/broadcast mode
    if (options.type === 'screen') {
        if (this.parent.localScreen && this.sharemyscreen) {
            this.logger.log('adding local screen stream to peer connection');
            this.pc.addStream(this.parent.localScreen);
            this.broadcaster = options.broadcaster;
        }
    } else {
        this.parent.localStreams.forEach(function (stream) {
            self.pc.addStream(stream);
        });
    }

    // call emitter constructor
    WildEmitter.call(this);

    this.on('channelOpen', function (channel) {
        if (channel.protocol === INBAND_FILETRANSFER_V1) {
            channel.onmessage = function (event) {
                var metadata = JSON.parse(event.data);
                var receiver = new FileTransfer.Receiver();
                receiver.receive(metadata, channel);
                self.emit('fileTransfer', metadata, receiver);
                receiver.on('receivedFile', function (file, metadata) {
                    receiver.channel.close();
                });
            };
        }
    });

    // proxy events to parent
    this.on('*', function () {
        self.parent.emit.apply(self.parent, arguments);
    });
}

util.inherits(Peer, WildEmitter);

Peer.prototype.handleMessage = function (message) {
    var self = this;

    this.logger.log('getting', message.type, message);

    if (message.prefix) this.browserPrefix = message.prefix;

    if (message.type === 'offer') {
        // workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=1064247
        message.payload.sdp = message.payload.sdp.replace('a=fmtp:0 profile-level-id=0x42e00c;packetization-mode=1\r\n', '');
        this.pc.handleOffer(message.payload, function (err) {
            if (err) {
                return;
            }
            // auto-accept
            self.pc.answer(self.receiveMedia, function (err, sessionDescription) {
                //self.send('answer', sessionDescription);
            });
        });
    } else if (message.type === 'answer') {
        this.pc.handleAnswer(message.payload);
    } else if (message.type === 'candidate') {
        this.pc.processIce(message.payload);
    } else if (message.type === 'connectivityError') {
        this.parent.emit('connectivityError', self);
    } else if (message.type === 'mute') {
        this.parent.emit('mute', {id: message.from, name: message.payload.name});
    } else if (message.type === 'unmute') {
        this.parent.emit('unmute', {id: message.from, name: message.payload.name});
    }
};

// send via signalling channel
Peer.prototype.send = function (messageType, payload) {
    var message = {
        to: this.id,
        sid: this.sid,
        broadcaster: this.broadcaster,
        roomType: this.type,
        type: messageType,
        payload: payload,
        prefix: webrtc.prefix
    };
    this.logger.log('sending', messageType, message);
    this.parent.emit('message', message);
};

// send via data channel
// returns true when message was sent and false if channel is not open
Peer.prototype.sendDirectly = function (channel, messageType, payload) {
    var message = {
        type: messageType,
        payload: payload
    };
    this.logger.log('sending via datachannel', channel, messageType, message);
    var dc = this.getDataChannel(channel);
    if (dc.readyState != 'open') return false;
    dc.send(JSON.stringify(message));
    return true;
};

// Internal method registering handlers for a data channel and emitting events on the peer
Peer.prototype._observeDataChannel = function (channel) {
    var self = this;
    channel.onclose = this.emit.bind(this, 'channelClose', channel);
    channel.onerror = this.emit.bind(this, 'channelError', channel);
    channel.onmessage = function (event) {
        self.emit('channelMessage', self, channel.label, JSON.parse(event.data), channel, event);
    };
    channel.onopen = this.emit.bind(this, 'channelOpen', channel);
};

// Fetch or create a data channel by the given name
Peer.prototype.getDataChannel = function (name, opts) {
    if (!webrtc.supportDataChannel) return this.emit('error', new Error('createDataChannel not supported'));
    var channel = this.channels[name];
    opts || (opts = {});
    if (channel) return channel;
    // if we don't have one by this label, create it
    channel = this.channels[name] = this.pc.createDataChannel(name, opts);
    this._observeDataChannel(channel);
    return channel;
};

Peer.prototype.onIceCandidate = function (candidate) {
    if (this.closed) return;
    if (candidate) {
        var pcConfig = this.parent.config.peerConnectionConfig;
        if (webrtc.prefix === 'moz' && pcConfig &&
                candidate.candidate && candidate.candidate.candidate &&
                candidate.candidate.candidate.indexOf(pcConfig.iceTransports) < 0) {
            this.logger.log('Ignoring ice candidate not matching pcConfig iceTransports type: ', pcConfig.iceTransports);
        } else {
            this.send('candidate', candidate);
        }
    } else {
        this.logger.log("End of candidates.");
    }
};

Peer.prototype.start = function () {
    var self = this;

    // well, the webrtc api requires that we either
    // a) create a datachannel a priori
    // b) do a renegotiation later to add the SCTP m-line
    // Let's do (a) first...
    if (this.enableDataChannels) {
        this.getDataChannel('simplewebrtc');
    }

    this.pc.offer(this.receiveMedia, function (err, sessionDescription) {
        //self.send('offer', sessionDescription);
    });
};

Peer.prototype.icerestart = function () {
    var constraints = this.receiveMedia;
    constraints.mandatory.IceRestart = true;
    this.pc.offer(constraints, function (err, success) { });
};

Peer.prototype.end = function () {
    if (this.closed) return;
    this.pc.close();
    this.handleStreamRemoved();
};

Peer.prototype.handleRemoteStreamAdded = function (event) {
    var self = this;
    if (this.stream) {
        this.logger.warn('Already have a remote stream');
    } else {
        this.stream = event.stream;
        // FIXME: addEventListener('ended', ...) would be nicer
        // but does not work in firefox
        this.stream.onended = function () {
            self.end();
        };
        this.parent.emit('peerStreamAdded', this);
    }
};

Peer.prototype.handleStreamRemoved = function () {
    this.parent.peers.splice(this.parent.peers.indexOf(this), 1);
    this.closed = true;
    this.parent.emit('peerStreamRemoved', this);
};

Peer.prototype.handleDataChannelAdded = function (channel) {
    this.channels[channel.label] = channel;
    this._observeDataChannel(channel);
};

Peer.prototype.sendFile = function (file) {
    var sender = new FileTransfer.Sender();
    var dc = this.getDataChannel('filetransfer' + (new Date()).getTime(), {
        protocol: INBAND_FILETRANSFER_V1
    });
    // override onopen
    dc.onopen = function () {
        dc.send(JSON.stringify({
            size: file.size,
            name: file.name
        }));
        sender.send(file, dc);
    };
    // override onclose
    dc.onclose = function () {
        console.log('sender received transfer');
        sender.emit('complete');
    };
    return sender;
};

module.exports = Peer;

},{"filetransfer":15,"rtcpeerconnection":14,"util":8,"webrtcsupport":5,"wildemitter":4}],16:[function(require,module,exports){
// getUserMedia helper by @HenrikJoreteg
var func = (window.navigator.getUserMedia ||
            window.navigator.webkitGetUserMedia ||
            window.navigator.mozGetUserMedia ||
            window.navigator.msGetUserMedia);


module.exports = function (constraints, cb) {
    var options, error;
    var haveOpts = arguments.length === 2;
    var defaultOpts = {video: true, audio: true};

    var denied = 'PermissionDeniedError';
    var altDenied = 'PERMISSION_DENIED';
    var notSatisfied = 'ConstraintNotSatisfiedError';

    // make constraints optional
    if (!haveOpts) {
        cb = constraints;
        constraints = defaultOpts;
    }

    // treat lack of browser support like an error
    if (!func) {
        // throw proper error per spec
        error = new Error('MediaStreamError');
        error.name = 'NotSupportedError';

        // keep all callbacks async
        return window.setTimeout(function () {
            cb(error);
        }, 0);
    }

    // normalize error handling when no media types are requested
    if (!constraints.audio && !constraints.video) {
        error = new Error('MediaStreamError');
        error.name = 'NoMediaRequestedError';

        // keep all callbacks async
        return window.setTimeout(function () {
            cb(error);
        }, 0);
    }

    if (localStorage && localStorage.useFirefoxFakeDevice === "true") {
        constraints.fake = true;
    }

    func.call(window.navigator, constraints, function (stream) {
        cb(null, stream);
    }, function (err) {
        var error;
        // coerce into an error object since FF gives us a string
        // there are only two valid names according to the spec
        // we coerce all non-denied to "constraint not satisfied".
        if (typeof err === 'string') {
            error = new Error('MediaStreamError');
            if (err === denied || err === altDenied) {
                error.name = denied;
            } else {
                error.name = notSatisfied;
            }
        } else {
            // if we get an error object make sure '.name' property is set
            // according to spec: http://dev.w3.org/2011/webrtc/editor/getusermedia.html#navigatorusermediaerror-and-navigatorusermediaerrorcallback
            error = err;
            if (!error.name) {
                // this is likely chrome which
                // sets a property called "ERROR_DENIED" on the error object
                // if so we make sure to set a name
                if (error[denied]) {
                    err.name = denied;
                } else {
                    err.name = notSatisfied;
                }
            }
        }

        cb(error);
    });
};

},{}],10:[function(require,module,exports){
var util = require('util');
var hark = require('hark');
var webrtc = require('webrtcsupport');
var getUserMedia = require('getusermedia');
var getScreenMedia = require('getscreenmedia');
var WildEmitter = require('wildemitter');
var GainController = require('mediastream-gain');
var mockconsole = require('mockconsole');


function LocalMedia(opts) {
    WildEmitter.call(this);

    var config = this.config = {
        autoAdjustMic: false,
        detectSpeakingEvents: true,
        media: {
            audio: true,
            video: true
        },
        logger: mockconsole
    };

    var item;
    for (item in opts) {
        this.config[item] = opts[item];
    }

    this.logger = config.logger;
    this._log = this.logger.log.bind(this.logger, 'LocalMedia:');
    this._logerror = this.logger.error.bind(this.logger, 'LocalMedia:');

    this.screenSharingSupport = webrtc.screenSharing;

    this.localStreams = [];
    this.localScreens = [];

    if (!webrtc.support) {
        this._logerror('Your browser does not support local media capture.');
    }
}

util.inherits(LocalMedia, WildEmitter);


LocalMedia.prototype.start = function (mediaConstraints, cb) {
    var self = this;
    var constraints = mediaConstraints || this.config.media;

    getUserMedia(constraints, function (err, stream) {
        if (!err) {
            if (constraints.audio && self.config.detectSpeakingEvents) {
                self.setupAudioMonitor(stream, self.config.harkOptions);
            }
            self.localStreams.push(stream);

            if (self.config.autoAdjustMic) {
                self.gainController = new GainController(stream);
                // start out somewhat muted if we can track audio
                self.setMicIfEnabled(0.5);
            }

            // TODO: might need to migrate to the video tracks onended
            // FIXME: firefox does not seem to trigger this...
            stream.onended = function () {
                /*
                var idx = self.localStreams.indexOf(stream);
                if (idx > -1) {
                    self.localScreens.splice(idx, 1);
                }
                self.emit('localStreamStopped', stream);
                */
            };

            self.emit('localStream', stream);
        }
        if (cb) {
            return cb(err, stream);
        }
    });
};

LocalMedia.prototype.stop = function (stream) {
    var self = this;
    // FIXME: duplicates cleanup code until fixed in FF
    if (stream) {
        stream.stop();
        self.emit('localStreamStopped', stream);
        var idx = self.localStreams.indexOf(stream);
        if (idx > -1) {
            self.localStreams = self.localStreams.splice(idx, 1);
        }
    } else {
        if (this.audioMonitor) {
            this.audioMonitor.stop();
            delete this.audioMonitor;
        }
        this.localStreams.forEach(function (stream) {
            stream.stop();
            self.emit('localStreamStopped', stream);
        });
        this.localStreams = [];
    }
};

LocalMedia.prototype.startScreenShare = function (cb) {
    var self = this;
    getScreenMedia(function (err, stream) {
        if (!err) {
            self.localScreens.push(stream);

            // TODO: might need to migrate to the video tracks onended
            // Firefox does not support .onended but it does not support
            // screensharing either
            stream.onended = function () {
                var idx = self.localScreens.indexOf(stream);
                if (idx > -1) {
                    self.localScreens.splice(idx, 1);
                }
                self.emit('localScreenStopped', stream);
            };
            self.emit('localScreen', stream);
        }

        // enable the callback
        if (cb) {
            return cb(err, stream);
        }
    });
};

LocalMedia.prototype.stopScreenShare = function (stream) {
    if (stream) {
        stream.stop();
    } else {
        this.localScreens.forEach(function (stream) {
            stream.stop();
        });
        this.localScreens = [];
    }
};

// Audio controls
LocalMedia.prototype.mute = function () {
    this._audioEnabled(false);
    this.hardMuted = true;
    this.emit('audioOff');
};

LocalMedia.prototype.unmute = function () {
    this._audioEnabled(true);
    this.hardMuted = false;
    this.emit('audioOn');
};

LocalMedia.prototype.setupAudioMonitor = function (stream, harkOptions) {
    this._log('Setup audio');
    var audio = this.audioMonitor = hark(stream, harkOptions);
    var self = this;
    var timeout;

    audio.on('speaking', function () {
        self.emit('speaking');
        if (self.hardMuted) {
            return;
        }
        self.setMicIfEnabled(1);
    });

    audio.on('stopped_speaking', function () {
        if (timeout) {
            clearTimeout(timeout);
        }

        timeout = setTimeout(function () {
            self.emit('stoppedSpeaking');
            if (self.hardMuted) {
                return;
            }
            self.setMicIfEnabled(0.5);
        }, 1000);
    });
    audio.on('volume_change', function (volume, treshold) {
        self.emit('volumeChange', volume, treshold);
    });
};

// We do this as a seperate method in order to
// still leave the "setMicVolume" as a working
// method.
LocalMedia.prototype.setMicIfEnabled = function (volume) {
    if (!this.config.autoAdjustMic) {
        return;
    }
    this.gainController.setGain(volume);
};

// Video controls
LocalMedia.prototype.pauseVideo = function () {
    this._videoEnabled(false);
    this.emit('videoOff');
};
LocalMedia.prototype.resumeVideo = function () {
    this._videoEnabled(true);
    this.emit('videoOn');
};

// Combined controls
LocalMedia.prototype.pause = function () {
    this.mute();
    this.pauseVideo();
};
LocalMedia.prototype.resume = function () {
    this.unmute();
    this.resumeVideo();
};

// Internal methods for enabling/disabling audio/video
LocalMedia.prototype._audioEnabled = function (bool) {
    // work around for chrome 27 bug where disabling tracks
    // doesn't seem to work (works in canary, remove when working)
    this.setMicIfEnabled(bool ? 1 : 0);
    this.localStreams.forEach(function (stream) {
        stream.getAudioTracks().forEach(function (track) {
            track.enabled = !!bool;
        });
    });
};
LocalMedia.prototype._videoEnabled = function (bool) {
    this.localStreams.forEach(function (stream) {
        stream.getVideoTracks().forEach(function (track) {
            track.enabled = !!bool;
        });
    });
};

// check if all audio streams are enabled
LocalMedia.prototype.isAudioEnabled = function () {
    var enabled = true;
    this.localStreams.forEach(function (stream) {
        stream.getAudioTracks().forEach(function (track) {
            enabled = enabled && track.enabled;
        });
    });
    return enabled;
};

// check if all video streams are enabled
LocalMedia.prototype.isVideoEnabled = function () {
    var enabled = true;
    this.localStreams.forEach(function (stream) {
        stream.getVideoTracks().forEach(function (track) {
            enabled = enabled && track.enabled;
        });
    });
    return enabled;
};

// Backwards Compat
LocalMedia.prototype.startLocalMedia = LocalMedia.prototype.start;
LocalMedia.prototype.stopLocalMedia = LocalMedia.prototype.stop;

// fallback for old .localStream behaviour
Object.defineProperty(LocalMedia.prototype, 'localStream', {
    get: function () {
        return this.localStreams.length > 0 ? this.localStreams[0] : null;
    }
});
// fallback for old .localScreen behaviour
Object.defineProperty(LocalMedia.prototype, 'localScreen', {
    get: function () {
        return this.localScreens.length > 0 ? this.localScreens[0] : null;
    }
});

module.exports = LocalMedia;

},{"getscreenmedia":18,"getusermedia":16,"hark":17,"mediastream-gain":19,"mockconsole":6,"util":8,"webrtcsupport":5,"wildemitter":4}],15:[function(require,module,exports){
var WildEmitter = require('wildemitter');
var util = require('util');

function Sender(opts) {
    WildEmitter.call(this);
    var options = opts || {};
    this.config = {
        chunksize: 16384,
        pacing: 0
    };
    // set our config from options
    var item;
    for (item in options) {
        this.config[item] = options[item];
    }

    this.file = null;
    this.channel = null;
}
util.inherits(Sender, WildEmitter);

Sender.prototype.send = function (file, channel) {
    var self = this;
    this.file = file;
    this.channel = channel;
    var sliceFile = function(offset) {
        var reader = new window.FileReader();
        reader.onload = (function() {
            return function(e) {
                self.channel.send(e.target.result);
                self.emit('progress', offset, file.size, e.target.result);
                if (file.size > offset + e.target.result.byteLength) {
                    window.setTimeout(sliceFile, self.config.pacing, offset + self.config.chunksize);
                } else {
                    self.emit('progress', file.size, file.size, null);
                    self.emit('sentFile');
                }
            };
        })(file);
        var slice = file.slice(offset, offset + self.config.chunksize);
        reader.readAsArrayBuffer(slice);
    };
    window.setTimeout(sliceFile, 0, 0);
};

function Receiver() {
    WildEmitter.call(this);

    this.receiveBuffer = [];
    this.received = 0;
    this.metadata = {};
    this.channel = null;
}
util.inherits(Receiver, WildEmitter);

Receiver.prototype.receive = function (metadata, channel) {
    var self = this;

    if (metadata) {
        this.metadata = metadata;
    }
    this.channel = channel;
    // chrome only supports arraybuffers and those make it easier to calc the hash
    channel.binaryType = 'arraybuffer';
    this.channel.onmessage = function (event) {
        var len = event.data.byteLength;
        self.received += len;
        self.receiveBuffer.push(event.data);

        self.emit('progress', self.received, self.metadata.size, event.data);
        if (self.received === self.metadata.size) {
            self.emit('receivedFile', new window.Blob(self.receiveBuffer), self.metadata);
            self.receiveBuffer = []; // discard receivebuffer
        } else if (self.received > self.metadata.size) {
            // FIXME
            console.error('received more than expected, discarding...');
            self.receiveBuffer = []; // just discard...

        }
    };
};

module.exports = {};
module.exports.support = window && window.File && window.FileReader && window.Blob;
module.exports.Sender = Sender;
module.exports.Receiver = Receiver;

},{"util":8,"wildemitter":4}],14:[function(require,module,exports){
var util = require('util');
var each = require('lodash.foreach');
var pluck = require('lodash.pluck');
var webrtc = require('webrtcsupport');
var SJJ = require('sdp-jingle-json');
var WildEmitter = require('wildemitter');
var peerconn = require('traceablepeerconnection');


function PeerConnection(config, constraints) {
    var self = this;
    var item;
    WildEmitter.call(this);

    config = config || {};
    config.iceServers = config.iceServers || [];

    // make sure this only gets enabled in Google Chrome
    // EXPERIMENTAL FLAG, might get removed without notice
    this.enableChromeNativeSimulcast = false;
    if (constraints && constraints.optional &&
            webrtc.prefix === 'webkit' &&
            navigator.appVersion.match(/Chromium\//) === null) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.enableChromeNativeSimulcast) {
                self.enableChromeNativeSimulcast = true;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    this.enableMultiStreamHacks = false;
    if (constraints && constraints.optional &&
            webrtc.prefix === 'webkit') {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.enableMultiStreamHacks) {
                self.enableMultiStreamHacks = true;
            }
        });
    }
    // EXPERIMENTAL FLAG, might get removed without notice
    this.restrictBandwidth = 0;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetRestrictBandwidth) {
                self.restrictBandwidth = constraint.andyetRestrictBandwidth;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    // bundle up ice candidates, only works for jingle mode
    // number > 0 is the delay to wait for additional candidates
    // ~20ms seems good
    this.batchIceCandidates = 0;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetBatchIce) {
                self.batchIceCandidates = constraint.andyetBatchIce;
            }
        });
    }
    this.batchedIceCandidates = [];

    // EXPERIMENTAL FLAG, might get removed without notice
    // this attemps to strip out candidates with an already known foundation
    // and type -- i.e. those which are gathered via the same TURN server
    // but different transports (TURN udp, tcp and tls respectively)
    if (constraints && constraints.optional && webrtc.prefix === 'webkit') {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetFasterICE) {
                self.eliminateDuplicateCandidates = constraint.andyetFasterICE;
            }
        });
    }
    // EXPERIMENTAL FLAG, might get removed without notice
    // when using a server such as the jitsi videobridge we don't need to signal
    // our candidates
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetDontSignalCandidates) {
                self.dontSignalCandidates = constraint.andyetDontSignalCandidates;
            }
        });
    }


    // EXPERIMENTAL FLAG, might get removed without notice
    this.assumeSetLocalSuccess = false;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetAssumeSetLocalSuccess) {
                self.assumeSetLocalSuccess = constraint.andyetAssumeSetLocalSuccess;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    // working around https://bugzilla.mozilla.org/show_bug.cgi?id=1087551
    // pass in a timeout for this
    if (webrtc.prefix === 'moz') {
        if (constraints && constraints.optional) {
            this.wtFirefox = 0;
            constraints.optional.forEach(function (constraint, idx) {
                if (constraint.andyetFirefoxMakesMeSad) {
                    self.wtFirefox = constraint.andyetFirefoxMakesMeSad;
                    if (self.wtFirefox > 0) {
                        self.firefoxcandidatebuffer = [];
                    }
                }
            });
        }
    }


    this.pc = new peerconn(config, constraints);

    this.getLocalStreams = this.pc.getLocalStreams.bind(this.pc);
    this.getRemoteStreams = this.pc.getRemoteStreams.bind(this.pc);
    this.addStream = this.pc.addStream.bind(this.pc);
    this.removeStream = this.pc.removeStream.bind(this.pc);

    // proxy events
    this.pc.on('*', function () {
        self.emit.apply(self, arguments);
    });

    // proxy some events directly
    this.pc.onremovestream = this.emit.bind(this, 'removeStream');
    this.pc.onaddstream = this.emit.bind(this, 'addStream');
    this.pc.onnegotiationneeded = this.emit.bind(this, 'negotiationNeeded');
    this.pc.oniceconnectionstatechange = this.emit.bind(this, 'iceConnectionStateChange');
    this.pc.onsignalingstatechange = this.emit.bind(this, 'signalingStateChange');

    // handle ice candidate and data channel events
    this.pc.onicecandidate = this._onIce.bind(this);
    this.pc.ondatachannel = this._onDataChannel.bind(this);

    this.localDescription = {
        contents: []
    };
    this.remoteDescription = {
        contents: []
    };

    this.config = {
        debug: false,
        ice: {},
        sid: '',
        isInitiator: true,
        sdpSessionID: Date.now(),
        useJingle: false
    };

    // apply our config
    for (item in config) {
        this.config[item] = config[item];
    }

    if (this.config.debug) {
        this.on('*', function (eventName, event) {
            var logger = config.logger || console;
            logger.log('PeerConnection event:', arguments);
        });
    }
    this.hadLocalStunCandidate = false;
    this.hadRemoteStunCandidate = false;
    this.hadLocalRelayCandidate = false;
    this.hadRemoteRelayCandidate = false;

    this.hadLocalIPv6Candidate = false;
    this.hadRemoteIPv6Candidate = false;

    // keeping references for all our data channels
    // so they dont get garbage collected
    // can be removed once the following bugs have been fixed
    // https://crbug.com/405545
    // https://bugzilla.mozilla.org/show_bug.cgi?id=964092
    // to be filed for opera
    this._remoteDataChannels = [];
    this._localDataChannels = [];

    this._candidateBuffer = [];
}

util.inherits(PeerConnection, WildEmitter);

Object.defineProperty(PeerConnection.prototype, 'signalingState', {
    get: function () {
        return this.pc.signalingState;
    }
});
Object.defineProperty(PeerConnection.prototype, 'iceConnectionState', {
    get: function () {
        return this.pc.iceConnectionState;
    }
});

PeerConnection.prototype._role = function () {
    return this.isInitiator ? 'initiator' : 'responder';
};

// Add a stream to the peer connection object
PeerConnection.prototype.addStream = function (stream) {
    this.localStream = stream;
    this.pc.addStream(stream);
};

// helper function to check if a remote candidate is a stun/relay
// candidate or an ipv6 candidate
PeerConnection.prototype._checkLocalCandidate = function (candidate) {
    var cand = SJJ.toCandidateJSON(candidate);
    if (cand.type == 'srflx') {
        this.hadLocalStunCandidate = true;
    } else if (cand.type == 'relay') {
        this.hadLocalRelayCandidate = true;
    }
    if (cand.ip.indexOf(':') != -1) {
        this.hadLocalIPv6Candidate = true;
    }
};

// helper function to check if a remote candidate is a stun/relay
// candidate or an ipv6 candidate
PeerConnection.prototype._checkRemoteCandidate = function (candidate) {
    var cand = SJJ.toCandidateJSON(candidate);
    if (cand.type == 'srflx') {
        this.hadRemoteStunCandidate = true;
    } else if (cand.type == 'relay') {
        this.hadRemoteRelayCandidate = true;
    }
    if (cand.ip.indexOf(':') != -1) {
        this.hadRemoteIPv6Candidate = true;
    }
};


// Init and add ice candidate object with correct constructor
PeerConnection.prototype.processIce = function (update, cb) {
    cb = cb || function () {};
    var self = this;

    // ignore any added ice candidates to avoid errors. why does the
    // spec not do this?
    if (this.pc.signalingState === 'closed') return cb();

    if (update.contents || (update.jingle && update.jingle.contents)) {
        var contentNames = pluck(this.remoteDescription.contents, 'name');
        var contents = update.contents || update.jingle.contents;

        contents.forEach(function (content) {
            var transport = content.transport || {};
            var candidates = transport.candidates || [];
            var mline = contentNames.indexOf(content.name);
            var mid = content.name;

            candidates.forEach(
                function (candidate) {
                var iceCandidate = SJJ.toCandidateSDP(candidate) + '\r\n';
                self.pc.addIceCandidate(
                    new webrtc.IceCandidate({
                        candidate: iceCandidate,
                        sdpMLineIndex: mline,
                        sdpMid: mid
                    }), function () {
                        // well, this success callback is pretty meaningless
                    },
                    function (err) {
                        self.emit('error', err);
                    }
                );
                self._checkRemoteCandidate(iceCandidate);
            });
        });
    } else {
        // working around https://code.google.com/p/webrtc/issues/detail?id=3669
        if (update.candidate && update.candidate.candidate.indexOf('a=') !== 0) {
            update.candidate.candidate = 'a=' + update.candidate.candidate;
        }

        if (this.wtFirefox && this.firefoxcandidatebuffer !== null) {
            // we cant add this yet due to https://bugzilla.mozilla.org/show_bug.cgi?id=1087551
            if (this.pc.localDescription && this.pc.localDescription.type === 'offer') {
                this.firefoxcandidatebuffer.push(update.candidate);
                return cb();
            }
        }

        self.pc.addIceCandidate(
            new webrtc.IceCandidate(update.candidate),
            function () { },
            function (err) {
                self.emit('error', err);
            }
        );
        self._checkRemoteCandidate(update.candidate.candidate);
    }
    cb();
};

// Generate and emit an offer with the given constraints
PeerConnection.prototype.offer = function (constraints, cb) {
    var self = this;
    var hasConstraints = arguments.length === 2;
    var mediaConstraints = hasConstraints && constraints ? constraints : {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: true
            }
        };
    cb = hasConstraints ? cb : constraints;
    cb = cb || function () {};

    if (this.pc.signalingState === 'closed') return cb('Already closed');

    // Actually generate the offer
    this.pc.createOffer(
        function (offer) {
            // does not work for jingle, but jingle.js doesn't need
            // this hack...
            var expandedOffer = {
                type: 'offer',
                sdp: offer.sdp
            };
            if (self.assumeSetLocalSuccess) {
                self.emit('offer', expandedOffer);
                cb(null, expandedOffer);
            }
            self._candidateBuffer = [];
            self.pc.setLocalDescription(offer,
                function () {
                    var jingle;
                    if (self.config.useJingle) {
                        jingle = SJJ.toSessionJSON(offer.sdp, {
                            role: self._role(),
                            direction: 'outgoing'
                        });
                        jingle.sid = self.config.sid;
                        self.localDescription = jingle;

                        // Save ICE credentials
                        each(jingle.contents, function (content) {
                            var transport = content.transport || {};
                            if (transport.ufrag) {
                                self.config.ice[content.name] = {
                                    ufrag: transport.ufrag,
                                    pwd: transport.pwd
                                };
                            }
                        });

                        expandedOffer.jingle = jingle;
                    }
                    expandedOffer.sdp.split('\r\n').forEach(function (line) {
                        if (line.indexOf('a=candidate:') === 0) {
                            self._checkLocalCandidate(line);
                        }
                    });

                    if (!self.assumeSetLocalSuccess) {
                        self.emit('offer', expandedOffer);
                        cb(null, expandedOffer);
                    }
                },
                function (err) {
                    self.emit('error', err);
                    cb(err);
                }
            );
        },
        function (err) {
            self.emit('error', err);
            cb(err);
        },
        mediaConstraints
    );
};


// Process an incoming offer so that ICE may proceed before deciding
// to answer the request.
PeerConnection.prototype.handleOffer = function (offer, cb) {
    cb = cb || function () {};
    var self = this;
    offer.type = 'offer';
    if (offer.jingle) {
        if (this.enableChromeNativeSimulcast) {
            offer.jingle.contents.forEach(function (content) {
                if (content.name === 'video') {
                    content.description.googConferenceFlag = true;
                }
            });
        }
        if (this.enableMultiStreamHacks) {
            // add a mixed video stream as first stream
            offer.jingle.contents.forEach(function (content) {
                if (content.name === 'video') {
                    var sources = content.description.sources || [];
                    if (sources.length === 0 || sources[0].ssrc !== "3735928559") {
                        sources.unshift({
                            ssrc: "3735928559", // 0xdeadbeef
                            parameters: [
                                {
                                    key: "cname",
                                    value: "deadbeef"
                                },
                                {
                                    key: "msid",
                                    value: "mixyourfecintothis please"
                                }
                            ]
                        });
                        content.description.sources = sources;
                    }
                }
            });
        }
        if (self.restrictBandwidth > 0) {
            if (offer.jingle.contents.length >= 2 && offer.jingle.contents[1].name === 'video') {
                var content = offer.jingle.contents[1];
                var hasBw = content.description && content.description.bandwidth;
                if (!hasBw) {
                    offer.jingle.contents[1].description.bandwidth = { type: 'AS', bandwidth: self.restrictBandwidth.toString() };
                    offer.sdp = SJJ.toSessionSDP(offer.jingle, {
                        sid: self.config.sdpSessionID,
                        role: self._role(),
                        direction: 'outgoing'
                    });
                }
            }
        }
        offer.sdp = SJJ.toSessionSDP(offer.jingle, {
            sid: self.config.sdpSessionID,
            role: self._role(),
            direction: 'incoming'
        });
        self.remoteDescription = offer.jingle;
    }
    offer.sdp.split('\r\n').forEach(function (line) {
        if (line.indexOf('a=candidate:') === 0) {
            self._checkRemoteCandidate(line);
        }
    });
    self.pc.setRemoteDescription(new webrtc.SessionDescription(offer),
        function () {
            cb();
        },
        cb
    );
};

// Answer an offer with audio only
PeerConnection.prototype.answerAudioOnly = function (cb) {
    var mediaConstraints = {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: false
            }
        };
    this._answer(mediaConstraints, cb);
};

// Answer an offer without offering to recieve
PeerConnection.prototype.answerBroadcastOnly = function (cb) {
    var mediaConstraints = {
            mandatory: {
                OfferToReceiveAudio: false,
                OfferToReceiveVideo: false
            }
        };
    this._answer(mediaConstraints, cb);
};

// Answer an offer with given constraints default is audio/video
PeerConnection.prototype.answer = function (constraints, cb) {
    var self = this;
    var hasConstraints = arguments.length === 2;
    var callback = hasConstraints ? cb : constraints;
    var mediaConstraints = hasConstraints && constraints ? constraints : {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: true
            }
        };

    this._answer(mediaConstraints, callback);
};

// Process an answer
PeerConnection.prototype.handleAnswer = function (answer, cb) {
    cb = cb || function () {};
    var self = this;
    if (answer.jingle) {
        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
            sid: self.config.sdpSessionID,
            role: self._role(),
            direction: 'incoming'
        });
        self.remoteDescription = answer.jingle;
    }
    answer.sdp.split('\r\n').forEach(function (line) {
        if (line.indexOf('a=candidate:') === 0) {
            self._checkRemoteCandidate(line);
        }
    });
    self.pc.setRemoteDescription(
        new webrtc.SessionDescription(answer),
        function () {
            if (self.wtFirefox) {
                window.setTimeout(function () {
                    self.firefoxcandidatebuffer.forEach(function (candidate) {
                        // add candidates later
                        self.pc.addIceCandidate(
                            new webrtc.IceCandidate(candidate),
                            function () { },
                            function (err) {
                                self.emit('error', err);
                            }
                        );
                        self._checkRemoteCandidate(candidate.candidate);
                    });
                    self.firefoxcandidatebuffer = null;
                }, self.wtFirefox);
            }
            cb(null);
        },
        cb
    );
};

// Close the peer connection
PeerConnection.prototype.close = function () {
    this.pc.close();

    this._localDataChannels = [];
    this._remoteDataChannels = [];

    this.emit('close');
};

// Internal code sharing for various types of answer methods
PeerConnection.prototype._answer = function (constraints, cb) {
    cb = cb || function () {};
    var self = this;
    if (!this.pc.remoteDescription) {
        // the old API is used, call handleOffer
        throw new Error('remoteDescription not set');
    }

    if (this.pc.signalingState === 'closed') return cb('Already closed');

    self.pc.createAnswer(
        function (answer) {
            var sim = [];
            var rtx = [];
            if (self.enableChromeNativeSimulcast) {
                // native simulcast part 1: add another SSRC
                answer.jingle = SJJ.toSessionJSON(answer.sdp, {
                    role: self._role(),
                    direction: 'outgoing'
                });
                if (answer.jingle.contents.length >= 2 && answer.jingle.contents[1].name === 'video') {
                    var hasSimgroup = false;
                    var groups = answer.jingle.contents[1].description.sourceGroups || [];
                    var hasSim = false;
                    groups.forEach(function (group) {
                        if (group.semantics == 'SIM') hasSim = true;
                    });
                    if (!hasSim &&
                        answer.jingle.contents[1].description.sources.length) {
                        var newssrc = JSON.parse(JSON.stringify(answer.jingle.contents[1].description.sources[0]));
                        newssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts
                        answer.jingle.contents[1].description.sources.push(newssrc);

                        sim.push(answer.jingle.contents[1].description.sources[0].ssrc);
                        sim.push(newssrc.ssrc);
                        groups.push({
                            semantics: 'SIM',
                            sources: sim
                        });

                        // also create an RTX one for the SIM one
                        var rtxssrc = JSON.parse(JSON.stringify(newssrc));
                        rtxssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts
                        answer.jingle.contents[1].description.sources.push(rtxssrc);
                        groups.push({
                            semantics: 'FID',
                            sources: [newssrc.ssrc, rtxssrc.ssrc]
                        });

                        answer.jingle.contents[1].description.sourceGroups = groups;
                        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
                            sid: self.config.sdpSessionID,
                            role: self._role(),
                            direction: 'outgoing'
                        });
                    }
                }
            }
            var expandedAnswer = {
                type: 'answer',
                sdp: answer.sdp
            };
            if (self.assumeSetLocalSuccess) {
                // not safe to do when doing simulcast mangling
                self.emit('answer', expandedAnswer);
                cb(null, expandedAnswer);
            }
            self._candidateBuffer = [];
            self.pc.setLocalDescription(answer,
                function () {
                    if (self.config.useJingle) {
                        var jingle = SJJ.toSessionJSON(answer.sdp, {
                            role: self._role(),
                            direction: 'outgoing'
                        });
                        jingle.sid = self.config.sid;
                        self.localDescription = jingle;
                        expandedAnswer.jingle = jingle;
                    }
                    if (self.enableChromeNativeSimulcast) {
                        // native simulcast part 2:
                        // signal multiple tracks to the receiver
                        // for anything in the SIM group
                        if (!expandedAnswer.jingle) {
                            expandedAnswer.jingle = SJJ.toSessionJSON(answer.sdp, {
                                role: self._role(),
                                direction: 'outgoing'
                            });
                        }
                        var groups = expandedAnswer.jingle.contents[1].description.sourceGroups || [];
                        expandedAnswer.jingle.contents[1].description.sources.forEach(function (source, idx) {
                            // the floor idx/2 is a hack that relies on a particular order
                            // of groups, alternating between sim and rtx
                            source.parameters = source.parameters.map(function (parameter) {
                                if (parameter.key === 'msid') {
                                    parameter.value += '-' + Math.floor(idx / 2);
                                }
                                return parameter;
                            });
                        });
                        expandedAnswer.sdp = SJJ.toSessionSDP(expandedAnswer.jingle, {
                            sid: self.sdpSessionID,
                            role: self._role(),
                            direction: 'outgoing'
                        });
                    }
                    expandedAnswer.sdp.split('\r\n').forEach(function (line) {
                        if (line.indexOf('a=candidate:') === 0) {
                            self._checkLocalCandidate(line);
                        }
                    });
                    if (!self.assumeSetLocalSuccess) {
                        self.emit('answer', expandedAnswer);
                        cb(null, expandedAnswer);
                    }
                },
                function (err) {
                    self.emit('error', err);
                    cb(err);
                }
            );
        },
        function (err) {
            self.emit('error', err);
            cb(err);
        },
        constraints
    );
};

// Internal method for emitting ice candidates on our peer object
PeerConnection.prototype._onIce = function (event) {
    var self = this;
    if (event.candidate) {
        if (this.dontSignalCandidates) return;
        var ice = event.candidate;

        var expandedCandidate = {
            candidate: {
                candidate: ice.candidate,
                sdpMid: ice.sdpMid,
                sdpMLineIndex: ice.sdpMLineIndex
            }
        };
        this._checkLocalCandidate(ice.candidate);

        var cand = SJJ.toCandidateJSON(ice.candidate);

        var already;
        var idx;
        if (this.eliminateDuplicateCandidates && cand.type === 'relay') {
            // drop candidates with same foundation, component
            // take local type pref into account so we don't ignore udp
            // ones when we know about a TCP one. unlikely but...
            already = this._candidateBuffer.filter(
                function (c) {
                    return c.type === 'relay';
                }).map(function (c) {
                    return c.foundation + ':' + c.component;
                }
            );
            idx = already.indexOf(cand.foundation + ':' + cand.component);
            // remember: local type pref of udp is 0, tcp 1, tls 2
            if (idx > -1 && ((cand.priority >> 24) >= (already[idx].priority >> 24))) {
                // drop it, same foundation with higher (worse) type pref
                return;
            }
        }
        if (this.config.bundlePolicy === 'max-bundle') {
            // drop candidates which are duplicate for audio/video/data
            // duplicate means same host/port but different sdpMid
            already = this._candidateBuffer.filter(
                function (c) {
                    return cand.type === c.type;
                }).map(function (cand) {
                    return cand.address + ':' + cand.port;
                }
            );
            idx = already.indexOf(cand.address + ':' + cand.port);
            if (idx > -1) return;
        }
        // also drop rtcp candidates since we know the peer supports RTCP-MUX
        // this is a workaround until browsers implement this natively
        if (this.config.rtcpMuxPolicy === 'require' && cand.component === '2') {
            return;
        }
        this._candidateBuffer.push(cand);

        if (self.config.useJingle) {
            if (!ice.sdpMid) { // firefox doesn't set this
                if (self.pc.remoteDescription && self.pc.remoteDescription.type === 'offer') {
                    // preserve name from remote
                    ice.sdpMid = self.remoteDescription.contents[ice.sdpMLineIndex].name;
                } else {
                    ice.sdpMid = self.localDescription.contents[ice.sdpMLineIndex].name;
                }
            }
            if (!self.config.ice[ice.sdpMid]) {
                var jingle = SJJ.toSessionJSON(self.pc.localDescription.sdp, {
                    role: self._role(),
                    direction: 'outgoing'
                });
                each(jingle.contents, function (content) {
                    var transport = content.transport || {};
                    if (transport.ufrag) {
                        self.config.ice[content.name] = {
                            ufrag: transport.ufrag,
                            pwd: transport.pwd
                        };
                    }
                });
            }
            expandedCandidate.jingle = {
                contents: [{
                    name: ice.sdpMid,
                    creator: self._role(),
                    transport: {
                        transType: 'iceUdp',
                        ufrag: self.config.ice[ice.sdpMid].ufrag,
                        pwd: self.config.ice[ice.sdpMid].pwd,
                        candidates: [
                            cand
                        ]
                    }
                }]
            };
            if (self.batchIceCandidates > 0) {
                if (self.batchedIceCandidates.length === 0) {
                    window.setTimeout(function () {
                        var contents = {};
                        self.batchedIceCandidates.forEach(function (content) {
                            content = content.contents[0];
                            if (!contents[content.name]) contents[content.name] = content;
                            contents[content.name].transport.candidates.push(content.transport.candidates[0]);
                        });
                        var newCand = {
                            jingle: {
                                contents: []
                            }
                        };
                        Object.keys(contents).forEach(function (name) {
                            newCand.jingle.contents.push(contents[name]);
                        });
                        self.batchedIceCandidates = [];
                        self.emit('ice', newCand);
                    }, self.batchIceCandidates);
                }
                self.batchedIceCandidates.push(expandedCandidate.jingle);
                return;
            }

        }
        this.emit('ice', expandedCandidate);
    } else {
        this.emit('endOfCandidates');
    }
};

// Internal method for processing a new data channel being added by the
// other peer.
PeerConnection.prototype._onDataChannel = function (event) {
    // make sure we keep a reference so this doesn't get garbage collected
    var channel = event.channel;
    this._remoteDataChannels.push(channel);

    this.emit('addChannel', channel);
};

// Create a data channel spec reference:
// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCDataChannelInit
PeerConnection.prototype.createDataChannel = function (name, opts) {
    var channel = this.pc.createDataChannel(name, opts);

    // make sure we keep a reference so this doesn't get garbage collected
    this._localDataChannels.push(channel);

    return channel;
};

// a wrapper around getStats which hides the differences (where possible)
PeerConnection.prototype.getStats = function (cb) {
    if (webrtc.prefix === 'moz') {
        this.pc.getStats(
            function (res) {
                var items = [];
                for (var result in res) {
                    if (typeof res[result] === 'object') {
                        items.push(res[result]);
                    }
                }
                cb(null, items);
            },
            cb
        );
    } else {
        this.pc.getStats(function (res) {
            var items = [];
            res.result().forEach(function (result) {
                var item = {};
                result.names().forEach(function (name) {
                    item[name] = result.stat(name);
                });
                item.id = result.id;
                item.type = result.type;
                item.timestamp = result.timestamp;
                items.push(item);
            });
            cb(null, items);
        });
    }
};

module.exports = PeerConnection;

},{"lodash.foreach":22,"lodash.pluck":23,"sdp-jingle-json":20,"traceablepeerconnection":21,"util":8,"webrtcsupport":5,"wildemitter":4}],17:[function(require,module,exports){
var WildEmitter = require('wildemitter');

function getMaxVolume (analyser, fftBins) {
  var maxVolume = -Infinity;
  analyser.getFloatFrequencyData(fftBins);

  for(var i=4, ii=fftBins.length; i < ii; i++) {
    if (fftBins[i] > maxVolume && fftBins[i] < 0) {
      maxVolume = fftBins[i];
    }
  };

  return maxVolume;
}


var audioContextType = window.AudioContext || window.webkitAudioContext;
// use a single audio context due to hardware limits
var audioContext = null;
module.exports = function(stream, options) {
  var harker = new WildEmitter();


  // make it not break in non-supported browsers
  if (!audioContextType) return harker;

  //Config
  var options = options || {},
      smoothing = (options.smoothing || 0.1),
      interval = (options.interval || 50),
      threshold = options.threshold,
      play = options.play,
      history = options.history || 10,
      running = true;

  //Setup Audio Context
  if (!audioContext) {
    audioContext = new audioContextType();
  }
  var sourceNode, fftBins, analyser;

  analyser = audioContext.createAnalyser();
  analyser.fftSize = 512;
  analyser.smoothingTimeConstant = smoothing;
  fftBins = new Float32Array(analyser.fftSize);

  if (stream.jquery) stream = stream[0];
  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {
    //Audio Tag
    sourceNode = audioContext.createMediaElementSource(stream);
    if (typeof play === 'undefined') play = true;
    threshold = threshold || -50;
  } else {
    //WebRTC Stream
    sourceNode = audioContext.createMediaStreamSource(stream);
    threshold = threshold || -50;
  }

  sourceNode.connect(analyser);
  if (play) analyser.connect(audioContext.destination);

  harker.speaking = false;

  harker.setThreshold = function(t) {
    threshold = t;
  };

  harker.setInterval = function(i) {
    interval = i;
  };
  
  harker.stop = function() {
    running = false;
    harker.emit('volume_change', -100, threshold);
    if (harker.speaking) {
      harker.speaking = false;
      harker.emit('stopped_speaking');
    }
  };
  harker.speakingHistory = [];
  for (var i = 0; i < history; i++) {
      harker.speakingHistory.push(0);
  }

  // Poll the analyser node to determine if speaking
  // and emit events if changed
  var looper = function() {
    setTimeout(function() {
    
      //check if stop has been called
      if(!running) {
        return;
      }
      
      var currentVolume = getMaxVolume(analyser, fftBins);

      harker.emit('volume_change', currentVolume, threshold);

      var history = 0;
      if (currentVolume > threshold && !harker.speaking) {
        // trigger quickly, short history
        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {
          history += harker.speakingHistory[i];
        }
        if (history >= 2) {
          harker.speaking = true;
          harker.emit('speaking');
        }
      } else if (currentVolume < threshold && harker.speaking) {
        for (var i = 0; i < harker.speakingHistory.length; i++) {
          history += harker.speakingHistory[i];
        }
        if (history == 0) {
          harker.speaking = false;
          harker.emit('stopped_speaking');
        }
      }
      harker.speakingHistory.shift();
      harker.speakingHistory.push(0 + (currentVolume > threshold));

      looper();
    }, interval);
  };
  looper();


  return harker;
}

},{"wildemitter":24}],24:[function(require,module,exports){
/*
WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based 
on @visionmedia's Emitter from UI Kit.

Why? I wanted it standalone.

I also wanted support for wildcard emitters like this:

emitter.on('*', function (eventName, other, event, payloads) {
    
});

emitter.on('somenamespace*', function (eventName, payloads) {
    
});

Please note that callbacks triggered by wildcard registered events also get 
the event name as the first argument.
*/
module.exports = WildEmitter;

function WildEmitter() {
    this.callbacks = {};
}

// Listen on the given `event` with `fn`. Store a group name if present.
WildEmitter.prototype.on = function (event, groupName, fn) {
    var hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    func._groupName = group;
    (this.callbacks[event] = this.callbacks[event] || []).push(func);
    return this;
};

// Adds an `event` listener that will be invoked a single
// time then automatically removed.
WildEmitter.prototype.once = function (event, groupName, fn) {
    var self = this,
        hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    function on() {
        self.off(event, on);
        func.apply(this, arguments);
    }
    this.on(event, group, on);
    return this;
};

// Unbinds an entire group
WildEmitter.prototype.releaseGroup = function (groupName) {
    var item, i, len, handlers;
    for (item in this.callbacks) {
        handlers = this.callbacks[item];
        for (i = 0, len = handlers.length; i < len; i++) {
            if (handlers[i]._groupName === groupName) {
                //console.log('removing');
                // remove it and shorten the array we're looping through
                handlers.splice(i, 1);
                i--;
                len--;
            }
        }
    }
    return this;
};

// Remove the given callback for `event` or all
// registered callbacks.
WildEmitter.prototype.off = function (event, fn) {
    var callbacks = this.callbacks[event],
        i;

    if (!callbacks) return this;

    // remove all handlers
    if (arguments.length === 1) {
        delete this.callbacks[event];
        return this;
    }

    // remove specific handler
    i = callbacks.indexOf(fn);
    callbacks.splice(i, 1);
    if (callbacks.length === 0) {
        delete this.callbacks[event];
    }
    return this;
};

/// Emit `event` with the given args.
// also calls any `*` handlers
WildEmitter.prototype.emit = function (event) {
    var args = [].slice.call(arguments, 1),
        callbacks = this.callbacks[event],
        specialCallbacks = this.getWildcardCallbacks(event),
        i,
        len,
        item,
        listeners;

    if (callbacks) {
        listeners = callbacks.slice();
        for (i = 0, len = listeners.length; i < len; ++i) {
            if (listeners[i]) {
                listeners[i].apply(this, args);
            } else {
                break;
            }
        }
    }

    if (specialCallbacks) {
        len = specialCallbacks.length;
        listeners = specialCallbacks.slice();
        for (i = 0, len = listeners.length; i < len; ++i) {
            if (listeners[i]) {
                listeners[i].apply(this, [event].concat(args));
            } else {
                break;
            }
        }
    }

    return this;
};

// Helper for for finding special wildcard event handlers that match the event
WildEmitter.prototype.getWildcardCallbacks = function (eventName) {
    var item,
        split,
        result = [];

    for (item in this.callbacks) {
        split = item.split('*');
        if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
            result = result.concat(this.callbacks[item]);
        }
    }
    return result;
};

},{}],20:[function(require,module,exports){
var toSDP = require('./lib/tosdp');
var toJSON = require('./lib/tojson');


// Converstion from JSON to SDP

exports.toIncomingSDPOffer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'responder',
        direction: 'incoming'
    });
};
exports.toOutgoingSDPOffer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'initiator',
        direction: 'outgoing'
    });
};
exports.toIncomingSDPAnswer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'initiator',
        direction: 'incoming'
    });
};
exports.toOutgoingSDPAnswer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'responder',
        direction: 'outgoing'
    });
};
exports.toIncomingMediaSDPOffer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'responder',
        direction: 'incoming'
    });
};
exports.toOutgoingMediaSDPOffer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'initiator',
        direction: 'outgoing'
    });
};
exports.toIncomingMediaSDPAnswer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'initiator',
        direction: 'incoming'
    });
};
exports.toOutgoingMediaSDPAnswer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'responder',
        direction: 'outgoing'
    });
};
exports.toCandidateSDP = toSDP.toCandidateSDP;
exports.toMediaSDP = toSDP.toMediaSDP;
exports.toSessionSDP = toSDP.toSessionSDP;


// Conversion from SDP to JSON

exports.toIncomingJSONOffer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'responder',
        direction: 'incoming',
        creators: creators
    });
};
exports.toOutgoingJSONOffer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'initiator',
        direction: 'outgoing',
        creators: creators
    });
};
exports.toIncomingJSONAnswer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'initiator',
        direction: 'incoming',
        creators: creators
    });
};
exports.toOutgoingJSONAnswer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'responder',
        direction: 'outgoing',
        creators: creators
    });
};
exports.toIncomingMediaJSONOffer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'responder',
        direction: 'incoming',
        creator: creator
    });
};
exports.toOutgoingMediaJSONOffer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'initiator',
        direction: 'outgoing',
        creator: creator
    });
};
exports.toIncomingMediaJSONAnswer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'initiator',
        direction: 'incoming',
        creator: creator
    });
};
exports.toOutgoingMediaJSONAnswer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'responder',
        direction: 'outgoing',
        creator: creator
    });
};
exports.toCandidateJSON = toJSON.toCandidateJSON;
exports.toMediaJSON = toJSON.toMediaJSON;
exports.toSessionJSON = toJSON.toSessionJSON;

},{"./lib/tojson":26,"./lib/tosdp":25}],18:[function(require,module,exports){
// getScreenMedia helper by @HenrikJoreteg
var getUserMedia = require('getusermedia');

// cache for constraints and callback
var cache = {};

module.exports = function (constraints, cb) {
    var hasConstraints = arguments.length === 2;
    var callback = hasConstraints ? cb : constraints;
    var error;

    if (typeof window === 'undefined' || window.location.protocol === 'http:') {
        error = new Error('NavigatorUserMediaError');
        error.name = 'HTTPS_REQUIRED';
        return callback(error);
    }

    if (window.navigator.userAgent.match('Chrome')) {
        var chromever = parseInt(window.navigator.userAgent.match(/Chrome\/(.*) /)[1], 10);
        var maxver = 33;
        var isCef = !window.chrome.webstore;
        // "known" crash in chrome 34 and 35 on linux
        if (window.navigator.userAgent.match('Linux')) maxver = 35;

        // check that the extension is installed by looking for a 
        // sessionStorage variable that contains the extension id
        // this has to be set after installation unless the contest
        // script does that
        if (sessionStorage.getScreenMediaJSExtensionId) {
            chrome.runtime.sendMessage(sessionStorage.getScreenMediaJSExtensionId,
                {type:'getScreen', id: 1}, null,
                function (data) {
                    if (data.sourceId === '') { // user canceled
                        var error = new Error('NavigatorUserMediaError');
                        error.name = 'PERMISSION_DENIED';
                        callback(error);
                    } else {
                        var constraints = constraints || {audio: false, video: {
                            mandatory: {
                                chromeMediaSource: 'desktop',
                                maxWidth: window.screen.width,
                                maxHeight: window.screen.height,
                                maxFrameRate: 3
                            },
                            optional: [
                                {googLeakyBucket: true},
                                {googTemporalLayeredScreencast: true}
                            ]
                        }};
                        constraints.video.mandatory.chromeMediaSourceId = data.sourceId;
                        getUserMedia(constraints, callback);
                    }
                }
            );
        } else if (isCef || (chromever >= 26 && chromever <= maxver)) {
            // chrome 26 - chrome 33 way to do it -- requires bad chrome://flags
            // note: this is basically in maintenance mode and will go away soon
            constraints = (hasConstraints && constraints) || {
                video: {
                    mandatory: {
                        googLeakyBucket: true,
                        maxWidth: window.screen.width,
                        maxHeight: window.screen.height,
                        maxFrameRate: 3,
                        chromeMediaSource: 'screen'
                    }
                }
            };
            getUserMedia(constraints, callback);
        } else {
            // chrome 34+ way requiring an extension
            var pending = window.setTimeout(function () {
                error = new Error('NavigatorUserMediaError');
                error.name = 'EXTENSION_UNAVAILABLE';
                return callback(error);
            }, 1000);
            cache[pending] = [callback, hasConstraints ? constraint : null];
            window.postMessage({ type: 'getScreen', id: pending }, '*');
        }
    } else if (window.navigator.userAgent.match('Firefox')) {
        var ffver = parseInt(window.navigator.userAgent.match(/Firefox\/(.*)/)[1], 10);
        if (ffver >= 33) {
            constraints = (hasConstraints && constraints) || {
                video: {
                    mozMediaSource: 'window',
                    mediaSource: 'window'
                }
            }
            getUserMedia(constraints, function (err, stream) {
                callback(err, stream);
                // workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=1045810
                if (!err) {
                    var lastTime = stream.currentTime;
                    var polly = window.setInterval(function () {
                        if (!stream) window.clearInterval(polly);
                        if (stream.currentTime == lastTime) {
                            window.clearInterval(polly);
                            if (stream.onended) {
                                stream.onended();
                            }
                        }
                        lastTime = stream.currentTime;
                    }, 500);
                }
            });
        } else {
            error = new Error('NavigatorUserMediaError');
            error.name = 'EXTENSION_UNAVAILABLE'; // does not make much sense but...
        }
    }
};

window.addEventListener('message', function (event) {
    if (event.origin != window.location.origin) {
        return;
    }
    if (event.data.type == 'gotScreen' && cache[event.data.id]) {
        var data = cache[event.data.id];
        var constraints = data[1];
        var callback = data[0];
        delete cache[event.data.id];

        if (event.data.sourceId === '') { // user canceled
            var error = new Error('NavigatorUserMediaError');
            error.name = 'PERMISSION_DENIED';
            callback(error);
        } else {
            constraints = constraints || {audio: false, video: {
                mandatory: {
                    chromeMediaSource: 'desktop',
                    maxWidth: window.screen.width,
                    maxHeight: window.screen.height,
                    maxFrameRate: 3
                },
                optional: [
                    {googLeakyBucket: true},
                    {googTemporalLayeredScreencast: true}
                ]
            }};
            constraints.video.mandatory.chromeMediaSourceId = event.data.sourceId;
            getUserMedia(constraints, callback);
        }
    } else if (event.data.type == 'getScreenPending') {
        window.clearTimeout(event.data.id);
    }
});

},{"getusermedia":16}],19:[function(require,module,exports){
var support = require('webrtcsupport');


function GainController(stream) {
    this.support = support.webAudio && support.mediaStream;

    // set our starting value
    this.gain = 1;

    if (this.support) {
        var context = this.context = new support.AudioContext();
        this.microphone = context.createMediaStreamSource(stream);
        this.gainFilter = context.createGain();
        this.destination = context.createMediaStreamDestination();
        this.outputStream = this.destination.stream;
        this.microphone.connect(this.gainFilter);
        this.gainFilter.connect(this.destination);
        stream.addTrack(this.outputStream.getAudioTracks()[0]);
        stream.removeTrack(stream.getAudioTracks()[0]);
    }
    this.stream = stream;
}

// setting
GainController.prototype.setGain = function (val) {
    // check for support
    if (!this.support) return;
    this.gainFilter.gain.value = val;
    this.gain = val;
};

GainController.prototype.getGain = function () {
    return this.gain;
};

GainController.prototype.off = function () {
    return this.setGain(0);
};

GainController.prototype.on = function () {
    this.setGain(1);
};


module.exports = GainController;

},{"webrtcsupport":5}],22:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var arrayEach = require('lodash._arrayeach'),
    baseEach = require('lodash._baseeach'),
    bindCallback = require('lodash._bindcallback'),
    isArray = require('lodash.isarray');

/**
 * Creates a function for `_.forEach` or `_.forEachRight`.
 *
 * @private
 * @param {Function} arrayFunc The function to iterate over an array.
 * @param {Function} eachFunc The function to iterate over a collection.
 * @returns {Function} Returns the new each function.
 */
function createForEach(arrayFunc, eachFunc) {
  return function(collection, iteratee, thisArg) {
    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
      ? arrayFunc(collection, iteratee)
      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
  };
}

/**
 * Iterates over elements of `collection` invoking `iteratee` for each element.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments:
 * (value, index|key, collection). Iteratee functions may exit iteration early
 * by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length" property
 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
 * may be used for object iteration.
 *
 * @static
 * @memberOf _
 * @alias each
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array|Object|string} Returns `collection`.
 * @example
 *
 * _([1, 2]).forEach(function(n) {
 *   console.log(n);
 * }).value();
 * // => logs each value from left to right and returns the array
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
 *   console.log(n, key);
 * });
 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
 */
var forEach = createForEach(arrayEach, baseEach);

module.exports = forEach;

},{"lodash._arrayeach":27,"lodash._baseeach":29,"lodash._bindcallback":28,"lodash.isarray":30}],23:[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseGet = require('lodash._baseget'),
    toPath = require('lodash._topath'),
    isArray = require('lodash.isarray'),
    map = require('lodash.map');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 */
function basePropertyDeep(path) {
  var pathKey = (path + '');
  path = toPath(path);
  return function(object) {
    return baseGet(object, path, pathKey);
  };
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  var type = typeof value;
  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
    return true;
  }
  if (isArray(value)) {
    return false;
  }
  var result = !reIsDeepProp.test(value);
  return result || (object != null && value in toObject(object));
}

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Gets the property value of `path` from all elements in `collection`.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Array|string} path The path of the property to pluck.
 * @returns {Array} Returns the property values.
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 }
 * ];
 *
 * _.pluck(users, 'user');
 * // => ['barney', 'fred']
 *
 * var userIndex = _.indexBy(users, 'user');
 * _.pluck(userIndex, 'age');
 * // => [36, 40] (iteration order is not guaranteed)
 */
function pluck(collection, path) {
  return map(collection, property(path));
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates a function which returns the property value at `path` on a
 * given object.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': { 'c': 2 } } },
 *   { 'a': { 'b': { 'c': 1 } } }
 * ];
 *
 * _.map(objects, _.property('a.b.c'));
 * // => [2, 1]
 *
 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
}

module.exports = pluck;

},{"lodash._baseget":31,"lodash._topath":34,"lodash.isarray":32,"lodash.map":33}],25:[function(require,module,exports){
var SENDERS = require('./senders');


exports.toSessionSDP = function (session, opts) {
    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';
    var sid = opts.sid || session.sid || Date.now();
    var time = opts.time || Date.now();

    var sdp = [
        'v=0',
        'o=- ' + sid + ' ' + time + ' IN IP4 0.0.0.0',
        's=-',
        't=0 0'
    ];

    var groups = session.groups || [];
    groups.forEach(function (group) {
        sdp.push('a=group:' + group.semantics + ' ' + group.contents.join(' '));
    });

    var contents = session.contents || [];
    contents.forEach(function (content) {
        sdp.push(exports.toMediaSDP(content, opts));
    });

    return sdp.join('\r\n') + '\r\n';
};

exports.toMediaSDP = function (content, opts) {
    var sdp = [];

    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';

    var desc = content.description;
    var transport = content.transport;
    var payloads = desc.payloads || [];
    var fingerprints = (transport && transport.fingerprints) || [];

    var mline = [];
    if (desc.descType == 'datachannel') {
        mline.push('application');
        mline.push('1');
        mline.push('DTLS/SCTP');
        if (transport.sctp) {
            transport.sctp.forEach(function (map) {
                mline.push(map.number);
            });
        }
    } else {
        mline.push(desc.media);
        mline.push('1');
        if ((desc.encryption && desc.encryption.length > 0) || (fingerprints.length > 0)) {
            mline.push('RTP/SAVPF');
        } else {
            mline.push('RTP/AVPF');
        }
        payloads.forEach(function (payload) {
            mline.push(payload.id);
        });
    }


    sdp.push('m=' + mline.join(' '));

    sdp.push('c=IN IP4 0.0.0.0');
    if (desc.bandwidth && desc.bandwidth.type && desc.bandwidth.bandwidth) {
        sdp.push('b=' + desc.bandwidth.type + ':' + desc.bandwidth.bandwidth);
    }
    if (desc.descType == 'rtp') {
        sdp.push('a=rtcp:1 IN IP4 0.0.0.0');
    }

    if (transport) {
        if (transport.ufrag) {
            sdp.push('a=ice-ufrag:' + transport.ufrag);
        }
        if (transport.pwd) {
            sdp.push('a=ice-pwd:' + transport.pwd);
        }

        var pushedSetup = false;
        fingerprints.forEach(function (fingerprint) {
            sdp.push('a=fingerprint:' + fingerprint.hash + ' ' + fingerprint.value);
            if (fingerprint.setup && !pushedSetup) {
                sdp.push('a=setup:' + fingerprint.setup);
            }
        });

        if (transport.sctp) {
            transport.sctp.forEach(function (map) {
                sdp.push('a=sctpmap:' + map.number + ' ' + map.protocol + ' ' + map.streams);
            });
        }
    }

    if (desc.descType == 'rtp') {
        sdp.push('a=' + (SENDERS[role][direction][content.senders] || 'sendrecv'));
    }
    sdp.push('a=mid:' + content.name);

    if (desc.mux) {
        sdp.push('a=rtcp-mux');
    }

    var encryption = desc.encryption || [];
    encryption.forEach(function (crypto) {
        sdp.push('a=crypto:' + crypto.tag + ' ' + crypto.cipherSuite + ' ' + crypto.keyParams + (crypto.sessionParams ? ' ' + crypto.sessionParams : ''));
    });
    if (desc.googConferenceFlag) {
        sdp.push('a=x-google-flag:conference');
    }

    payloads.forEach(function (payload) {
        var rtpmap = 'a=rtpmap:' + payload.id + ' ' + payload.name + '/' + payload.clockrate;
        if (payload.channels && payload.channels != '1') {
            rtpmap += '/' + payload.channels;
        }
        sdp.push(rtpmap);

        if (payload.parameters && payload.parameters.length) {
            var fmtp = ['a=fmtp:' + payload.id];
            var parameters = [];
            payload.parameters.forEach(function (param) {
                parameters.push((param.key ? param.key + '=' : '') + param.value);
            });
            fmtp.push(parameters.join(';'));
            sdp.push(fmtp.join(' '));
        }

        if (payload.feedback) {
            payload.feedback.forEach(function (fb) {
                if (fb.type === 'trr-int') {
                    sdp.push('a=rtcp-fb:' + payload.id + ' trr-int ' + (fb.value ? fb.value : '0'));
                } else {
                    sdp.push('a=rtcp-fb:' + payload.id + ' ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));
                }
            });
        }
    });

    if (desc.feedback) {
        desc.feedback.forEach(function (fb) {
            if (fb.type === 'trr-int') {
                sdp.push('a=rtcp-fb:* trr-int ' + (fb.value ? fb.value : '0'));
            } else {
                sdp.push('a=rtcp-fb:* ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));
            }
        });
    }

    var hdrExts = desc.headerExtensions || [];
    hdrExts.forEach(function (hdr) {
        sdp.push('a=extmap:' + hdr.id + (hdr.senders ? '/' + SENDERS[role][direction][hdr.senders] : '') + ' ' + hdr.uri);
    });

    var ssrcGroups = desc.sourceGroups || [];
    ssrcGroups.forEach(function (ssrcGroup) {
        sdp.push('a=ssrc-group:' + ssrcGroup.semantics + ' ' + ssrcGroup.sources.join(' '));
    });

    var ssrcs = desc.sources || [];
    ssrcs.forEach(function (ssrc) {
        for (var i = 0; i < ssrc.parameters.length; i++) {
            var param = ssrc.parameters[i];
            sdp.push('a=ssrc:' + (ssrc.ssrc || desc.ssrc) + ' ' + param.key + (param.value ? (':' + param.value) : ''));
        }
    });

    var candidates = transport.candidates || [];
    candidates.forEach(function (candidate) {
        sdp.push(exports.toCandidateSDP(candidate));
    });

    return sdp.join('\r\n');
};

exports.toCandidateSDP = function (candidate) {
    var sdp = [];

    sdp.push(candidate.foundation);
    sdp.push(candidate.component);
    sdp.push(candidate.protocol.toUpperCase());
    sdp.push(candidate.priority);
    sdp.push(candidate.ip);
    sdp.push(candidate.port);

    var type = candidate.type;
    sdp.push('typ');
    sdp.push(type);
    if (type === 'srflx' || type === 'prflx' || type === 'relay') {
        if (candidate.relAddr && candidate.relPort) {
            sdp.push('raddr');
            sdp.push(candidate.relAddr);
            sdp.push('rport');
            sdp.push(candidate.relPort);
        }
    }
    if (candidate.tcpType && candidate.protocol.toUpperCase() == 'TCP') {
        sdp.push('tcptype');
        sdp.push(candidate.tcpType);
    }

    sdp.push('generation');
    sdp.push(candidate.generation || '0');

    // FIXME: apparently this is wrong per spec
    // but then, we need this when actually putting this into
    // SDP so it's going to stay.
    // decision needs to be revisited when browsers dont
    // accept this any longer
    return 'a=candidate:' + sdp.join(' ');
};

},{"./senders":35}],28:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;

},{}],27:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `_.forEach` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],26:[function(require,module,exports){
var SENDERS = require('./senders');
var parsers = require('./parsers');
var idCounter = Math.random();


exports._setIdCounter = function (counter) {
    idCounter = counter;
};

exports.toSessionJSON = function (sdp, opts) {
    var i;
    var creators = opts.creators || [];
    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';


    // Divide the SDP into session and media sections.
    var media = sdp.split('\r\nm=');
    for (i = 1; i < media.length; i++) {
        media[i] = 'm=' + media[i];
        if (i !== media.length - 1) {
            media[i] += '\r\n';
        }
    }
    var session = media.shift() + '\r\n';
    var sessionLines = parsers.lines(session);
    var parsed = {};

    var contents = [];
    for (i = 0; i < media.length; i++) {
        contents.push(exports.toMediaJSON(media[i], session, {
            role: role,
            direction: direction,
            creator: creators[i] || 'initiator'
        }));
    }
    parsed.contents = contents;

    var groupLines = parsers.findLines('a=group:', sessionLines);
    if (groupLines.length) {
        parsed.groups = parsers.groups(groupLines);
    }

    return parsed;
};

exports.toMediaJSON = function (media, session, opts) {
    var creator = opts.creator || 'initiator';
    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';

    var lines = parsers.lines(media);
    var sessionLines = parsers.lines(session);
    var mline = parsers.mline(lines[0]);

    var content = {
        creator: creator,
        name: mline.media,
        description: {
            descType: 'rtp',
            media: mline.media,
            payloads: [],
            encryption: [],
            feedback: [],
            headerExtensions: []
        },
        transport: {
            transType: 'iceUdp',
            candidates: [],
            fingerprints: []
        }
    };
    if (mline.media == 'application') {
        // FIXME: the description is most likely to be independent
        // of the SDP and should be processed by other parts of the library
        content.description = {
            descType: 'datachannel'
        };
        content.transport.sctp = [];
    }
    var desc = content.description;
    var trans = content.transport;

    // If we have a mid, use that for the content name instead.
    var mid = parsers.findLine('a=mid:', lines);
    if (mid) {
        content.name = mid.substr(6);
    }

    if (parsers.findLine('a=sendrecv', lines, sessionLines)) {
        content.senders = 'both';
    } else if (parsers.findLine('a=sendonly', lines, sessionLines)) {
        content.senders = SENDERS[role][direction].sendonly;
    } else if (parsers.findLine('a=recvonly', lines, sessionLines)) {
        content.senders = SENDERS[role][direction].recvonly;
    } else if (parsers.findLine('a=inactive', lines, sessionLines)) {
        content.senders = 'none';
    }

    if (desc.descType == 'rtp') {
        var bandwidth = parsers.findLine('b=', lines);
        if (bandwidth) {
            desc.bandwidth = parsers.bandwidth(bandwidth);
        }

        var ssrc = parsers.findLine('a=ssrc:', lines);
        if (ssrc) {
            desc.ssrc = ssrc.substr(7).split(' ')[0];
        }

        var rtpmapLines = parsers.findLines('a=rtpmap:', lines);
        rtpmapLines.forEach(function (line) {
            var payload = parsers.rtpmap(line);
            payload.parameters = [];
            payload.feedback = [];

            var fmtpLines = parsers.findLines('a=fmtp:' + payload.id, lines);
            // There should only be one fmtp line per payload
            fmtpLines.forEach(function (line) {
                payload.parameters = parsers.fmtp(line);
            });

            var fbLines = parsers.findLines('a=rtcp-fb:' + payload.id, lines);
            fbLines.forEach(function (line) {
                payload.feedback.push(parsers.rtcpfb(line));
            });

            desc.payloads.push(payload);
        });

        var cryptoLines = parsers.findLines('a=crypto:', lines, sessionLines);
        cryptoLines.forEach(function (line) {
            desc.encryption.push(parsers.crypto(line));
        });

        if (parsers.findLine('a=rtcp-mux', lines)) {
            desc.mux = true;
        }

        var fbLines = parsers.findLines('a=rtcp-fb:*', lines);
        fbLines.forEach(function (line) {
            desc.feedback.push(parsers.rtcpfb(line));
        });

        var extLines = parsers.findLines('a=extmap:', lines);
        extLines.forEach(function (line) {
            var ext = parsers.extmap(line);

            ext.senders = SENDERS[role][direction][ext.senders];

            desc.headerExtensions.push(ext);
        });

        var ssrcGroupLines = parsers.findLines('a=ssrc-group:', lines);
        desc.sourceGroups = parsers.sourceGroups(ssrcGroupLines || []);

        var ssrcLines = parsers.findLines('a=ssrc:', lines);
        desc.sources = parsers.sources(ssrcLines || []);

        if (parsers.findLine('a=x-google-flag:conference', lines, sessionLines)) {
            desc.googConferenceFlag = true;
        }
    }

    // transport specific attributes
    var fingerprintLines = parsers.findLines('a=fingerprint:', lines, sessionLines);
    var setup = parsers.findLine('a=setup:', lines, sessionLines);
    fingerprintLines.forEach(function (line) {
        var fp = parsers.fingerprint(line);
        if (setup) {
            fp.setup = setup.substr(8);
        }
        trans.fingerprints.push(fp);
    });

    var ufragLine = parsers.findLine('a=ice-ufrag:', lines, sessionLines);
    var pwdLine = parsers.findLine('a=ice-pwd:', lines, sessionLines);
    if (ufragLine && pwdLine) {
        trans.ufrag = ufragLine.substr(12);
        trans.pwd = pwdLine.substr(10);
        trans.candidates = [];

        var candidateLines = parsers.findLines('a=candidate:', lines, sessionLines);
        candidateLines.forEach(function (line) {
            trans.candidates.push(exports.toCandidateJSON(line));
        });
    }

    if (desc.descType == 'datachannel') {
        var sctpmapLines = parsers.findLines('a=sctpmap:', lines);
        sctpmapLines.forEach(function (line) {
            var sctp = parsers.sctpmap(line);
            trans.sctp.push(sctp);
        });
    }

    return content;
};

exports.toCandidateJSON = function (line) {
    var candidate = parsers.candidate(line.split('\r\n')[0]);
    candidate.id = (idCounter++).toString(36).substr(0, 12);
    return candidate;
};

},{"./parsers":36,"./senders":35}],30:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/**
 * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
 * In addition to special characters the forward slash is escaped to allow for
 * easier `eval` use and `Function` compilation.
 */
var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  escapeRegExp(fnToString.call(hasOwnProperty))
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (objToString.call(value) == funcTag) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

/**
 * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
 * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
 */
function escapeRegExp(string) {
  string = baseToString(string);
  return (string && reHasRegExpChars.test(string))
    ? string.replace(reRegExpChars, '\\$&')
    : string;
}

module.exports = isArray;

},{}],31:[function(require,module,exports){
/**
 * lodash 3.7.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `get` without support for string paths
 * and default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path of the property to get.
 * @param {string} [pathKey] The key representation of path.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path, pathKey) {
  if (object == null) {
    return;
  }
  if (pathKey !== undefined && pathKey in toObject(object)) {
    path = [pathKey];
  }
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[path[index++]];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseGet;

},{}],32:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/**
 * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
 * In addition to special characters the forward slash is escaped to allow for
 * easier `eval` use and `Function` compilation.
 */
var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  escapeRegExp(fnToString.call(hasOwnProperty))
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (objToString.call(value) == funcTag) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

/**
 * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
 * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
 */
function escapeRegExp(string) {
  string = baseToString(string);
  return (string && reHasRegExpChars.test(string))
    ? string.replace(reRegExpChars, '\\$&')
    : string;
}

module.exports = isArray;

},{}],21:[function(require,module,exports){
// based on https://github.com/ESTOS/strophe.jingle/
// adds wildemitter support
var util = require('util');
var webrtc = require('webrtcsupport');
var WildEmitter = require('wildemitter');

function dumpSDP(description) {
    return {
        type: description.type,
        sdp: description.sdp
    };
}

function dumpStream(stream) {
    var info = {
        label: stream.id,
    };
    if (stream.getAudioTracks().length) {
        info.audio = stream.getAudioTracks().map(function (track) {
            return track.id;
        });
    }
    if (stream.getVideoTracks().length) {
        info.video = stream.getVideoTracks().map(function (track) {
            return track.id;
        });
    }
    return info;
}

function TraceablePeerConnection(config, constraints) {
    var self = this;
    WildEmitter.call(this);

    this.peerconnection = new webrtc.PeerConnection(config, constraints);

    this.trace = function (what, info) {
        self.emit('PeerConnectionTrace', {
            time: new Date(),
            type: what,
            value: info || ""
        });
    };

    this.onicecandidate = null;
    this.peerconnection.onicecandidate = function (event) {
        self.trace('onicecandidate', event.candidate);
        if (self.onicecandidate !== null) {
            self.onicecandidate(event);
        }
    };
    this.onaddstream = null;
    this.peerconnection.onaddstream = function (event) {
        self.trace('onaddstream', dumpStream(event.stream));
        if (self.onaddstream !== null) {
            self.onaddstream(event);
        }
    };
    this.onremovestream = null;
    this.peerconnection.onremovestream = function (event) {
        self.trace('onremovestream', dumpStream(event.stream));
        if (self.onremovestream !== null) {
            self.onremovestream(event);
        }
    };
    this.onsignalingstatechange = null;
    this.peerconnection.onsignalingstatechange = function (event) {
        self.trace('onsignalingstatechange', self.signalingState);
        if (self.onsignalingstatechange !== null) {
            self.onsignalingstatechange(event);
        }
    };
    this.oniceconnectionstatechange = null;
    this.peerconnection.oniceconnectionstatechange = function (event) {
        self.trace('oniceconnectionstatechange', self.iceConnectionState);
        if (self.oniceconnectionstatechange !== null) {
            self.oniceconnectionstatechange(event);
        }
    };
    this.onnegotiationneeded = null;
    this.peerconnection.onnegotiationneeded = function (event) {
        self.trace('onnegotiationneeded');
        if (self.onnegotiationneeded !== null) {
            self.onnegotiationneeded(event);
        }
    };
    self.ondatachannel = null;
    this.peerconnection.ondatachannel = function (event) {
        self.trace('ondatachannel', event);
        if (self.ondatachannel !== null) {
            self.ondatachannel(event);
        }
    };
    this.getLocalStreams = this.peerconnection.getLocalStreams.bind(this.peerconnection);
    this.getRemoteStreams = this.peerconnection.getRemoteStreams.bind(this.peerconnection);
}

util.inherits(TraceablePeerConnection, WildEmitter);

Object.defineProperty(TraceablePeerConnection.prototype, 'signalingState', {
    get: function () {
        return this.peerconnection.signalingState;
    }
});

Object.defineProperty(TraceablePeerConnection.prototype, 'iceConnectionState', {
    get: function () {
        return this.peerconnection.iceConnectionState;
    }
});

Object.defineProperty(TraceablePeerConnection.prototype, 'localDescription', {
    get: function () {
        return this.peerconnection.localDescription;
    }
});

Object.defineProperty(TraceablePeerConnection.prototype, 'remoteDescription', {
    get: function () {
        return this.peerconnection.remoteDescription;
    }
});

TraceablePeerConnection.prototype.addStream = function (stream) {
    this.trace('addStream', dumpStream(stream));
    this.peerconnection.addStream(stream);
};

TraceablePeerConnection.prototype.removeStream = function (stream) {
    this.trace('removeStream', dumpStream(stream));
    this.peerconnection.removeStream(stream);
};

TraceablePeerConnection.prototype.createDataChannel = function (label, opts) {
    this.trace('createDataChannel', label, opts);
    return this.peerconnection.createDataChannel(label, opts);
};

TraceablePeerConnection.prototype.setLocalDescription = function (description, successCallback, failureCallback) {
    var self = this;
    this.trace('setLocalDescription', dumpSDP(description));
    this.peerconnection.setLocalDescription(description,
        function () {
            self.trace('setLocalDescriptionOnSuccess');
            successCallback();
        },
        function (err) {
            self.trace('setLocalDescriptionOnFailure', err);
            failureCallback(err);
        }
    );
};

TraceablePeerConnection.prototype.setRemoteDescription = function (description, successCallback, failureCallback) {
    var self = this;
    this.trace('setRemoteDescription', dumpSDP(description));
    this.peerconnection.setRemoteDescription(description,
        function () {
            self.trace('setRemoteDescriptionOnSuccess');
            successCallback();
        },
        function (err) {
            self.trace('setRemoteDescriptionOnFailure', err);
            failureCallback(err);
        }
    );
};

TraceablePeerConnection.prototype.close = function () {
    this.trace('stop');
    if (this.statsinterval !== null) {
        window.clearInterval(this.statsinterval);
        this.statsinterval = null;
    }
    if (this.peerconnection.signalingState != 'closed') {
        this.peerconnection.close();
    }
};

TraceablePeerConnection.prototype.createOffer = function (successCallback, failureCallback, constraints) {
    var self = this;
    this.trace('createOffer', constraints);
    this.peerconnection.createOffer(
        function (offer) {
            self.trace('createOfferOnSuccess', dumpSDP(offer));
            successCallback(offer);
        },
        function (err) {
            self.trace('createOfferOnFailure', err);
            failureCallback(err);
        },
        constraints
    );
};

TraceablePeerConnection.prototype.createAnswer = function (successCallback, failureCallback, constraints) {
    var self = this;
    this.trace('createAnswer', constraints);
    this.peerconnection.createAnswer(
        function (answer) {
            self.trace('createAnswerOnSuccess', dumpSDP(answer));
            successCallback(answer);
        },
        function (err) {
            self.trace('createAnswerOnFailure', err);
            failureCallback(err);
        },
        constraints
    );
};

TraceablePeerConnection.prototype.addIceCandidate = function (candidate, successCallback, failureCallback) {
    var self = this;
    this.trace('addIceCandidate', candidate);
    this.peerconnection.addIceCandidate(candidate,
        function () {
            //self.trace('addIceCandidateOnSuccess');
            if (successCallback) successCallback();
        },
        function (err) {
            self.trace('addIceCandidateOnFailure', err);
            if (failureCallback) failureCallback(err);
        }
    );
};

TraceablePeerConnection.prototype.getStats = function (callback, errback) {
    if (navigator.mozGetUserMedia) {
        this.peerconnection.getStats(null, callback, errback);
    } else {
        this.peerconnection.getStats(callback);
    }
};

module.exports = TraceablePeerConnection;

},{"util":8,"webrtcsupport":5,"wildemitter":4}],35:[function(require,module,exports){
module.exports = {
    initiator: {
        incoming: {
            initiator: 'recvonly',
            responder: 'sendonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'initiator',
            sendonly: 'responder',
            sendrecv: 'both',
            inactive: 'none'
        },
        outgoing: {
            initiator: 'sendonly',
            responder: 'recvonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'responder',
            sendonly: 'initiator',
            sendrecv: 'both',
            inactive: 'none'
        }
    },
    responder: {
        incoming: {
            initiator: 'sendonly',
            responder: 'recvonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'responder',
            sendonly: 'initiator',
            sendrecv: 'both',
            inactive: 'none'
        },
        outgoing: {
            initiator: 'recvonly',
            responder: 'sendonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'initiator',
            sendonly: 'responder',
            sendrecv: 'both',
            inactive: 'none'
        }
    }
};

},{}],36:[function(require,module,exports){
exports.lines = function (sdp) {
    return sdp.split('\r\n').filter(function (line) {
        return line.length > 0;
    });
};

exports.findLine = function (prefix, mediaLines, sessionLines) {
    var prefixLength = prefix.length;
    for (var i = 0; i < mediaLines.length; i++) {
        if (mediaLines[i].substr(0, prefixLength) === prefix) {
            return mediaLines[i];
        }
    }
    // Continue searching in parent session section
    if (!sessionLines) {
        return false;
    }

    for (var j = 0; j < sessionLines.length; j++) {
        if (sessionLines[j].substr(0, prefixLength) === prefix) {
            return sessionLines[j];
        }
    }

    return false;
};

exports.findLines = function (prefix, mediaLines, sessionLines) {
    var results = [];
    var prefixLength = prefix.length;
    for (var i = 0; i < mediaLines.length; i++) {
        if (mediaLines[i].substr(0, prefixLength) === prefix) {
            results.push(mediaLines[i]);
        }
    }
    if (results.length || !sessionLines) {
        return results;
    }
    for (var j = 0; j < sessionLines.length; j++) {
        if (sessionLines[j].substr(0, prefixLength) === prefix) {
            results.push(sessionLines[j]);
        }
    }
    return results;
};

exports.mline = function (line) {
    var parts = line.substr(2).split(' ');
    var parsed = {
        media: parts[0],
        port: parts[1],
        proto: parts[2],
        formats: []
    };
    for (var i = 3; i < parts.length; i++) {
        if (parts[i]) {
            parsed.formats.push(parts[i]);
        }
    }
    return parsed;
};

exports.rtpmap = function (line) {
    var parts = line.substr(9).split(' ');
    var parsed = {
        id: parts.shift()
    };

    parts = parts[0].split('/');

    parsed.name = parts[0];
    parsed.clockrate = parts[1];
    parsed.channels = parts.length == 3 ? parts[2] : '1';
    return parsed;
};

exports.sctpmap = function (line) {
    // based on -05 draft
    var parts = line.substr(10).split(' ');
    var parsed = {
        number: parts.shift(),
        protocol: parts.shift(),
        streams: parts.shift()
    };
    return parsed;
};


exports.fmtp = function (line) {
    var kv, key, value;
    var parts = line.substr(line.indexOf(' ') + 1).split(';');
    var parsed = [];
    for (var i = 0; i < parts.length; i++) {
        kv = parts[i].split('=');
        key = kv[0].trim();
        value = kv[1];
        if (key && value) {
            parsed.push({key: key, value: value});
        } else if (key) {
            parsed.push({key: '', value: key});
        }
    }
    return parsed;
};

exports.crypto = function (line) {
    var parts = line.substr(9).split(' ');
    var parsed = {
        tag: parts[0],
        cipherSuite: parts[1],
        keyParams: parts[2],
        sessionParams: parts.slice(3).join(' ')
    };
    return parsed;
};

exports.fingerprint = function (line) {
    var parts = line.substr(14).split(' ');
    return {
        hash: parts[0],
        value: parts[1]
    };
};

exports.extmap = function (line) {
    var parts = line.substr(9).split(' ');
    var parsed = {};

    var idpart = parts.shift();
    var sp = idpart.indexOf('/');
    if (sp >= 0) {
        parsed.id = idpart.substr(0, sp);
        parsed.senders = idpart.substr(sp + 1);
    } else {
        parsed.id = idpart;
        parsed.senders = 'sendrecv';
    }

    parsed.uri = parts.shift() || '';

    return parsed;
};

exports.rtcpfb = function (line) {
    var parts = line.substr(10).split(' ');
    var parsed = {};
    parsed.id = parts.shift();
    parsed.type = parts.shift();
    if (parsed.type === 'trr-int') {
        parsed.value = parts.shift();
    } else {
        parsed.subtype = parts.shift() || '';
    }
    parsed.parameters = parts;
    return parsed;
};

exports.candidate = function (line) {
    var parts;
    if (line.indexOf('a=candidate:') === 0) {
        parts = line.substring(12).split(' ');
    } else { // no a=candidate
        parts = line.substring(10).split(' ');
    }

    var candidate = {
        foundation: parts[0],
        component: parts[1],
        protocol: parts[2].toLowerCase(),
        priority: parts[3],
        ip: parts[4],
        port: parts[5],
        // skip parts[6] == 'typ'
        type: parts[7],
        generation: '0'
    };

    for (var i = 8; i < parts.length; i += 2) {
        if (parts[i] === 'raddr') {
            candidate.relAddr = parts[i + 1];
        } else if (parts[i] === 'rport') {
            candidate.relPort = parts[i + 1];
        } else if (parts[i] === 'generation') {
            candidate.generation = parts[i + 1];
        } else if (parts[i] === 'tcptype') {
            candidate.tcpType = parts[i + 1];
        }
    }

    candidate.network = '1';

    return candidate;
};

exports.sourceGroups = function (lines) {
    var parsed = [];
    for (var i = 0; i < lines.length; i++) {
        var parts = lines[i].substr(13).split(' ');
        parsed.push({
            semantics: parts.shift(),
            sources: parts
        });
    }
    return parsed;
};

exports.sources = function (lines) {
    // http://tools.ietf.org/html/rfc5576
    var parsed = [];
    var sources = {};
    for (var i = 0; i < lines.length; i++) {
        var parts = lines[i].substr(7).split(' ');
        var ssrc = parts.shift();

        if (!sources[ssrc]) {
            var source = {
                ssrc: ssrc,
                parameters: []
            };
            parsed.push(source);

            // Keep an index
            sources[ssrc] = source;
        }

        parts = parts.join(' ').split(':');
        var attribute = parts.shift();
        var value = parts.join(':') || null;

        sources[ssrc].parameters.push({
            key: attribute,
            value: value
        });
    }

    return parsed;
};

exports.groups = function (lines) {
    // http://tools.ietf.org/html/rfc5888
    var parsed = [];
    var parts;
    for (var i = 0; i < lines.length; i++) {
        parts = lines[i].substr(8).split(' ');
        parsed.push({
            semantics: parts.shift(),
            contents: parts
        });
    }
    return parsed;
};

exports.bandwidth = function (line) {
    var parts = line.substr(2).split(':');
    var parsed = {};
    parsed.type = parts.shift();
    parsed.bandwidth = parts.shift();
    return parsed;
};

},{}],29:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var keys = require('lodash.keys');

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.forEach` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object|string} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iteratee functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    var length = collection ? getLength(collection) : 0;
    if (!isLength(length)) {
      return eachFunc(collection, iteratee);
    }
    var index = fromRight ? length : -1,
        iterable = toObject(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * Creates a base function for `_.forIn` or `_.forInRight`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var iterable = toObject(object),
        props = keysFunc(object),
        length = props.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      var key = props[index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseEach;

},{"lodash.keys":37}],33:[function(require,module,exports){
/**
 * lodash 3.1.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var arrayMap = require('lodash._arraymap'),
    baseCallback = require('lodash._basecallback'),
    baseEach = require('lodash._baseeach'),
    isArray = require('lodash.isarray');

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.map` without support for callback shorthands
 * and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Creates an array of values by running each element in `collection` through
 * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
 * arguments: (value, index|key, collection).
 *
 * If a property name is provided for `iteratee` the created `_.property`
 * style callback returns the property value of the given element.
 *
 * If a value is also provided for `thisArg` the created `_.matchesProperty`
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `iteratee` the created `_.matches` style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
 * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
 * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
 * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
 * `sum`, `uniq`, and `words`
 *
 * @static
 * @memberOf _
 * @alias collect
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
 *  per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function timesThree(n) {
 *   return n * 3;
 * }
 *
 * _.map([1, 2], timesThree);
 * // => [3, 6]
 *
 * _.map({ 'a': 1, 'b': 2 }, timesThree);
 * // => [3, 6] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // using the `_.property` callback shorthand
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee, thisArg) {
  var func = isArray(collection) ? arrayMap : baseMap;
  iteratee = baseCallback(iteratee, thisArg, 3);
  return func(collection, iteratee);
}

module.exports = map;

},{"lodash._arraymap":40,"lodash._basecallback":38,"lodash._baseeach":39,"lodash.isarray":32}],34:[function(require,module,exports){
/**
 * lodash 3.8.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArray = require('lodash.isarray');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `value` to a string if it is not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

/**
 * Converts `value` to property path array if it is not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Array} Returns the property path array.
 */
function toPath(value) {
  if (isArray(value)) {
    return value;
  }
  var result = [];
  baseToString(value).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
}

module.exports = toPath;

},{"lodash.isarray":32}],40:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `_.map` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],41:[function(require,module,exports){
/**
 * lodash 3.9.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/**
 * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
 * In addition to special characters the forward slash is escaped to allow for
 * easier `eval` use and `Function` compilation.
 */
var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  escapeRegExp(fnToString.call(hasOwnProperty))
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (objToString.call(value) == funcTag) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

/**
 * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
 * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
 */
function escapeRegExp(string) {
  string = baseToString(string);
  return (string && reHasRegExpChars.test(string))
    ? string.replace(reRegExpChars, '\\$&')
    : string;
}

module.exports = getNative;

},{}],42:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) && objToString.call(value) == argsTag;
}

module.exports = isArguments;

},{}],39:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var keys = require('lodash.keys');

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.forEach` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object|string} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iteratee functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    var length = collection ? getLength(collection) : 0;
    if (!isLength(length)) {
      return eachFunc(collection, iteratee);
    }
    var index = fromRight ? length : -1,
        iterable = toObject(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * Creates a base function for `_.forIn` or `_.forInRight`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var iterable = toObject(object),
        props = keysFunc(object),
        length = props.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      var key = props[index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseEach;

},{"lodash.keys":43}],44:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;

},{}],37:[function(require,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = require('lodash._getnative'),
    isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? null : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"lodash._getnative":41,"lodash.isarguments":42,"lodash.isarray":30}],38:[function(require,module,exports){
/**
 * lodash 3.3.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseIsEqual = require('lodash._baseisequal'),
    bindCallback = require('lodash._bindcallback'),
    isArray = require('lodash.isarray'),
    pairs = require('lodash.pairs');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

/**
 * The base implementation of `_.callback` which supports specifying the
 * number of arguments to provide to `func`.
 *
 * @private
 * @param {*} [func=_.identity] The value to convert to a callback.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function baseCallback(func, thisArg, argCount) {
  var type = typeof func;
  if (type == 'function') {
    return thisArg === undefined
      ? func
      : bindCallback(func, thisArg, argCount);
  }
  if (func == null) {
    return identity;
  }
  if (type == 'object') {
    return baseMatches(func);
  }
  return thisArg === undefined
    ? property(func)
    : baseMatchesProperty(func, thisArg);
}

/**
 * The base implementation of `get` without support for string paths
 * and default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path of the property to get.
 * @param {string} [pathKey] The key representation of path.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path, pathKey) {
  if (object == null) {
    return;
  }
  if (pathKey !== undefined && pathKey in toObject(object)) {
    path = [pathKey];
  }
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[path[index++]];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isMatch` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Array} matchData The propery names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = toObject(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var result = customizer ? customizer(objValue, srcValue, key) : undefined;
      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
        return false;
      }
    }
  }
  return true;
}

/**
 * The base implementation of `_.matches` which does not clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    var key = matchData[0][0],
        value = matchData[0][1];

    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === value && (value !== undefined || (key in toObject(object)));
    };
  }
  return function(object) {
    return baseIsMatch(object, matchData);
  };
}

/**
 * The base implementation of `_.matchesProperty` which does not which does
 * not clone `value`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to compare.
 * @returns {Function} Returns the new function.
 */
function baseMatchesProperty(path, srcValue) {
  var isArr = isArray(path),
      isCommon = isKey(path) && isStrictComparable(srcValue),
      pathKey = (path + '');

  path = toPath(path);
  return function(object) {
    if (object == null) {
      return false;
    }
    var key = pathKey;
    object = toObject(object);
    if ((isArr || !isCommon) && !(key in object)) {
      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
      if (object == null) {
        return false;
      }
      key = last(path);
      object = toObject(object);
    }
    return object[key] === srcValue
      ? (srcValue !== undefined || (key in object))
      : baseIsEqual(srcValue, object[key], undefined, true);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 */
function basePropertyDeep(path) {
  var pathKey = (path + '');
  path = toPath(path);
  return function(object) {
    return baseGet(object, path, pathKey);
  };
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  start = start == null ? 0 : (+start || 0);
  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = (end === undefined || end > length) ? length : (+end || 0);
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Gets the propery names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = pairs(object),
      length = result.length;

  while (length--) {
    result[length][2] = isStrictComparable(result[length][1]);
  }
  return result;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  var type = typeof value;
  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
    return true;
  }
  if (isArray(value)) {
    return false;
  }
  var result = !reIsDeepProp.test(value);
  return result || (object != null && value in toObject(object));
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Converts `value` to property path array if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Array} Returns the property path array.
 */
function toPath(value) {
  if (isArray(value)) {
    return value;
  }
  var result = [];
  baseToString(value).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
}

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * Creates a function which returns the property value at `path` on a
 * given object.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': { 'c': 2 } } },
 *   { 'a': { 'b': { 'c': 1 } } }
 * ];
 *
 * _.map(objects, _.property('a.b.c'));
 * // => [2, 1]
 *
 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
}

module.exports = baseCallback;

},{"lodash._baseisequal":46,"lodash._bindcallback":44,"lodash.isarray":32,"lodash.pairs":45}],47:[function(require,module,exports){
/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dateTag] = typedArrayTags[errorTag] =
typedArrayTags[funcTag] = typedArrayTags[mapTag] =
typedArrayTags[numberTag] = typedArrayTags[objectTag] =
typedArrayTags[regexpTag] = typedArrayTags[setTag] =
typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
}

module.exports = isTypedArray;

},{}],48:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) && objToString.call(value) == argsTag;
}

module.exports = isArguments;

},{}],45:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var keys = require('lodash.keys');

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates a two dimensional array of the key-value pairs for `object`,
 * e.g. `[[key1, value1], [key2, value2]]`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the new array of key-value pairs.
 * @example
 *
 * _.pairs({ 'barney': 36, 'fred': 40 });
 * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
 */
function pairs(object) {
  object = toObject(object);

  var index = -1,
      props = keys(object),
      length = props.length,
      result = Array(length);

  while (++index < length) {
    var key = props[index];
    result[index] = [key, object[key]];
  }
  return result;
}

module.exports = pairs;

},{"lodash.keys":43}],49:[function(require,module,exports){
/**
 * lodash 3.9.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/**
 * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
 * In addition to special characters the forward slash is escaped to allow for
 * easier `eval` use and `Function` compilation.
 */
var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  escapeRegExp(fnToString.call(hasOwnProperty))
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (objToString.call(value) == funcTag) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

/**
 * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
 * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
 */
function escapeRegExp(string) {
  string = baseToString(string);
  return (string && reHasRegExpChars.test(string))
    ? string.replace(reRegExpChars, '\\$&')
    : string;
}

module.exports = getNative;

},{}],43:[function(require,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = require('lodash._getnative'),
    isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? null : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"lodash._getnative":49,"lodash.isarguments":48,"lodash.isarray":32}],46:[function(require,module,exports){
/**
 * lodash 3.0.7 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArray = require('lodash.isarray'),
    isTypedArray = require('lodash.istypedarray'),
    keys = require('lodash.keys');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * A specialized version of `_.some` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.isEqual` without support for `this` binding
 * `customizer` functions.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = objToString.call(object);
    if (objTag == argsTag) {
      objTag = objectTag;
    } else if (objTag != objectTag) {
      objIsArr = isTypedArray(object);
    }
  }
  if (!othIsArr) {
    othTag = objToString.call(other);
    if (othTag == argsTag) {
      othTag = objectTag;
    } else if (othTag != objectTag) {
      othIsArr = isTypedArray(other);
    }
  }
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && !(objIsArr || objIsObj)) {
    return equalByTag(object, other, objTag);
  }
  if (!isLoose) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
    }
  }
  if (!isSameTag) {
    return false;
  }
  // Assume cyclic values are equal.
  // For more information on detecting circular references see https://es5.github.io/#JO.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == object) {
      return stackB[length] == other;
    }
  }
  // Add `object` and `other` to the stack of traversed objects.
  stackA.push(object);
  stackB.push(other);

  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

  stackA.pop();
  stackB.pop();

  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing arrays.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var index = -1,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
    return false;
  }
  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index],
        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

    if (result !== undefined) {
      if (result) {
        continue;
      }
      return false;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (isLoose) {
      if (!arraySome(other, function(othValue) {
            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
          })) {
        return false;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
      return false;
    }
  }
  return true;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} value The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag) {
  switch (tag) {
    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object)
        ? other != +other
        : object == +other;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings primitives and string
      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
      return object == (other + '');
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isLoose) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  var skipCtor = isLoose;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key],
        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

    // Recursively compare objects (susceptible to call stack limits).
    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
      return false;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (!skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      return false;
    }
  }
  return true;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseIsEqual;

},{"lodash.isarray":32,"lodash.istypedarray":47,"lodash.keys":43}]},{},[1])(1)
});
;
(function () { 

/*
  File: Core.js

 */

/*
 Object: $jit
 
 Defines the namespace for all library Classes and Objects. 
 This variable is the *only* global variable defined in the Toolkit. 
 There are also other interesting properties attached to this variable described below.
 */
window.$jit = function(w) {
  w = w || window;
  for(var k in $jit) {
    if($jit[k].$extend) {
      w[k] = $jit[k];
    }
  }
};

$jit.version = '2.0.1';
/*
  Object: $jit.id
  
  Works just like *document.getElementById*
  
  Example:
  (start code js)
  var element = $jit.id('elementId');
  (end code)

*/

/*
 Object: $jit.util
 
 Contains utility functions.
 
 Some of the utility functions and the Class system were based in the MooTools Framework 
 <http://mootools.net>. Copyright (c) 2006-2010 Valerio Proietti, <http://mad4milk.net/>. 
 MIT license <http://mootools.net/license.txt>.
 
 These methods are generally also implemented in DOM manipulation frameworks like JQuery, MooTools and Prototype.
 I'd suggest you to use the functions from those libraries instead of using these, since their functions 
 are widely used and tested in many different platforms/browsers. Use these functions only if you have to.
 
 */
var $ = function(d) {
  return document.getElementById(d);
};

$.empty = function() {
};

/*
  Method: extend
  
  Augment an object by appending another object's properties.
  
  Parameters:
  
  original - (object) The object to be extended.
  extended - (object) An object which properties are going to be appended to the original object.
  
  Example:
  (start code js)
  $jit.util.extend({ 'a': 1, 'b': 2 }, { 'b': 3, 'c': 4 }); //{ 'a':1, 'b': 3, 'c': 4 }
  (end code)
*/
$.extend = function(original, extended) {
  for ( var key in (extended || {}))
    original[key] = extended[key];
  return original;
};

$.lambda = function(value) {
  return (typeof value == 'function') ? value : function() {
    return value;
  };
};

$.time = Date.now || function() {
  return +new Date;
};

/*
  Method: splat
  
  Returns an array wrapping *obj* if *obj* is not an array. Returns *obj* otherwise.
  
  Parameters:
  
  obj - (mixed) The object to be wrapped in an array.
  
  Example:
  (start code js)
  $jit.util.splat(3);   //[3]
  $jit.util.splat([3]); //[3]
  (end code)
*/
$.splat = function(obj) {
  var type = $.type(obj);
  return type ? ((type != 'array') ? [ obj ] : obj) : [];
};

$.type = function(elem) {
  var type = $.type.s.call(elem).match(/^\[object\s(.*)\]$/)[1].toLowerCase();
  if(type != 'object') return type;
  if(elem && elem.$$family) return elem.$$family;
  return (elem && elem.nodeName && elem.nodeType == 1)? 'element' : type;
};
$.type.s = Object.prototype.toString;

/*
  Method: each
  
  Iterates through an iterable applying *f*.
  
  Parameters:
  
  iterable - (array) The original array.
  fn - (function) The function to apply to the array elements.
  
  Example:
  (start code js)
  $jit.util.each([3, 4, 5], function(n) { alert('number ' + n); });
  (end code)
*/
$.each = function(iterable, fn) {
  var type = $.type(iterable);
  if (type == 'object') {
    for ( var key in iterable)
      fn(iterable[key], key);
  } else {
    for ( var i = 0, l = iterable.length; i < l; i++)
      fn(iterable[i], i);
  }
};

$.indexOf = function(array, item) {
  if(Array.indexOf) return array.indexOf(item);
  for(var i=0,l=array.length; i<l; i++) {
    if(array[i] === item) return i;
  }
  return -1;
};

/*
  Method: map
  
  Maps or collects an array by applying *f*.
  
  Parameters:
  
  array - (array) The original array.
  f - (function) The function to apply to the array elements.
  
  Example:
  (start code js)
  $jit.util.map([3, 4, 5], function(n) { return n*n; }); //[9, 16, 25]
  (end code)
*/
$.map = function(array, f) {
  var ans = [];
  $.each(array, function(elem, i) {
    ans.push(f(elem, i));
  });
  return ans;
};

/*
  Method: reduce
  
  Iteratively applies the binary function *f* storing the result in an accumulator.
  
  Parameters:
  
  array - (array) The original array.
  f - (function) The function to apply to the array elements.
  opt - (optional|mixed) The starting value for the acumulator.
  
  Example:
  (start code js)
  $jit.util.reduce([3, 4, 5], function(x, y) { return x + y; }, 0); //12
  (end code)
*/
$.reduce = function(array, f, opt) {
  var l = array.length;
  if(l==0) return opt;
  var acum = arguments.length == 3? opt : array[--l];
  while(l--) {
    acum = f(acum, array[l]);
  }
  return acum;
};

/*
  Method: merge
  
  Merges n-objects and their sub-objects creating a new, fresh object.
  
  Parameters:
  
  An arbitrary number of objects.
  
  Example:
  (start code js)
  $jit.util.merge({ 'a': 1, 'b': 2 }, { 'b': 3, 'c': 4 }); //{ 'a':1, 'b': 3, 'c': 4 }
  (end code)
*/
$.merge = function() {
  var mix = {};
  for ( var i = 0, l = arguments.length; i < l; i++) {
    var object = arguments[i];
    if ($.type(object) != 'object')
      continue;
    for ( var key in object) {
      var op = object[key], mp = mix[key];
      mix[key] = (mp && $.type(op) == 'object' && $.type(mp) == 'object') ? $
          .merge(mp, op) : $.unlink(op);
    }
  }
  return mix;
};

$.unlink = function(object) {
  var unlinked;
  switch ($.type(object)) {
  case 'object':
    unlinked = {};
    for ( var p in object)
      unlinked[p] = $.unlink(object[p]);
    break;
  case 'array':
    unlinked = [];
    for ( var i = 0, l = object.length; i < l; i++)
      unlinked[i] = $.unlink(object[i]);
    break;
  default:
    return object;
  }
  return unlinked;
};

$.zip = function() {
  if(arguments.length === 0) return [];
  for(var j=0, ans=[], l=arguments.length, ml=arguments[0].length; j<ml; j++) {
    for(var i=0, row=[]; i<l; i++) {
      row.push(arguments[i][j]);
    }
    ans.push(row);
  }
  return ans;
};

/*
  Method: rgbToHex
  
  Converts an RGB array into a Hex string.
  
  Parameters:
  
  srcArray - (array) An array with R, G and B values
  
  Example:
  (start code js)
  $jit.util.rgbToHex([255, 255, 255]); //'#ffffff'
  (end code)
*/
$.rgbToHex = function(srcArray, array) {
  if (srcArray.length < 3)
    return null;
  if (srcArray.length == 4 && srcArray[3] == 0 && !array)
    return 'transparent';
  var hex = [];
  for ( var i = 0; i < 3; i++) {
    var bit = (srcArray[i] - 0).toString(16);
    hex.push(bit.length == 1 ? '0' + bit : bit);
  }
  return array ? hex : '#' + hex.join('');
};

/*
  Method: hexToRgb
  
  Converts an Hex color string into an RGB array.
  
  Parameters:
  
  hex - (string) A color hex string.
  
  Example:
  (start code js)
  $jit.util.hexToRgb('#fff'); //[255, 255, 255]
  (end code)
*/
$.hexToRgb = function(hex) {
  if (hex.length != 7) {
    hex = hex.match(/^#?(\w{1,2})(\w{1,2})(\w{1,2})$/);
    hex.shift();
    if (hex.length != 3)
      return null;
    var rgb = [];
    for ( var i = 0; i < 3; i++) {
      var value = hex[i];
      if (value.length == 1)
        value += value;
      rgb.push(parseInt(value, 16));
    }
    return rgb;
  } else {
    hex = parseInt(hex.slice(1), 16);
    return [ hex >> 16, hex >> 8 & 0xff, hex & 0xff ];
  }
};

$.destroy = function(elem) {
  $.clean(elem);
  if (elem.parentNode)
    elem.parentNode.removeChild(elem);
  if (elem.clearAttributes)
    elem.clearAttributes();
};

$.clean = function(elem) {
  for (var ch = elem.childNodes, i = 0, l = ch.length; i < l; i++) {
    $.destroy(ch[i]);
  }
};

/*
  Method: addEvent
  
  Cross-browser add event listener.
  
  Parameters:
  
  obj - (obj) The Element to attach the listener to.
  type - (string) The listener type. For example 'click', or 'mousemove'.
  fn - (function) The callback function to be used when the event is fired.
  
  Example:
  (start code js)
  $jit.util.addEvent(elem, 'click', function(){ alert('hello'); });
  (end code)
*/
$.addEvent = function(obj, type, fn) {
  if (obj.addEventListener)
    obj.addEventListener(type, fn, false);
  else
    obj.attachEvent('on' + type, fn);
};

$.addEvents = function(obj, typeObj) {
  for(var type in typeObj) {
    $.addEvent(obj, type, typeObj[type]);
  }
};

$.hasClass = function(obj, klass) {
  return (' ' + obj.className + ' ').indexOf(' ' + klass + ' ') > -1;
};

$.addClass = function(obj, klass) {
  if (!$.hasClass(obj, klass))
    obj.className = (obj.className + " " + klass);
};

$.removeClass = function(obj, klass) {
  obj.className = obj.className.replace(new RegExp(
      '(^|\\s)' + klass + '(?:\\s|$)'), '$1');
};

$.getPos = function(elem) {
  var offset = getOffsets(elem);
  var scroll = getScrolls(elem);
  return {
    x: offset.x - scroll.x,
    y: offset.y - scroll.y
  };

  function getOffsets(elem) {
    var position = {
      x: 0,
      y: 0
    };
    while (elem && !isBody(elem)) {
      position.x += elem.offsetLeft;
      position.y += elem.offsetTop;
      elem = elem.offsetParent;
    }
    return position;
  }

  function getScrolls(elem) {
    var position = {
      x: 0,
      y: 0
    };
    while (elem && !isBody(elem)) {
      position.x += elem.scrollLeft;
      position.y += elem.scrollTop;
      elem = elem.parentNode;
    }
    return position;
  }

  function isBody(element) {
    return (/^(?:body|html)$/i).test(element.tagName);
  }
};

$.event = {
  get: function(e, win) {
    win = win || window;
    return e || win.event;
  },
  getWheel: function(e) {
    return e.wheelDelta? e.wheelDelta / 120 : -(e.detail || 0) / 3;
  },
  isRightClick: function(e) {
    return (e.which == 3 || e.button == 2);
  },
  getPos: function(e, win) {
    // get mouse position
    win = win || window;
    e = e || win.event;
    var doc = win.document;
    doc = doc.documentElement || doc.body;
    //TODO(nico): make touch event handling better
    if(e.touches && e.touches.length) {
      e = e.touches[0];
    }
    var page = {
      x: e.pageX || (e.clientX + doc.scrollLeft),
      y: e.pageY || (e.clientY + doc.scrollTop)
    };
    return page;
  },
  stop: function(e) {
    if (e.stopPropagation) e.stopPropagation();
    e.cancelBubble = true;
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  }
};

$jit.util = $jit.id = $;

var Class = function(properties) {
  properties = properties || {};
  var klass = function() {
    for ( var key in this) {
      if (typeof this[key] != 'function')
        this[key] = $.unlink(this[key]);
    }
    this.constructor = klass;
    if (Class.prototyping)
      return this;
    var instance = this.initialize ? this.initialize.apply(this, arguments)
        : this;
    //typize
    this.$$family = 'class';
    return instance;
  };

  for ( var mutator in Class.Mutators) {
    if (!properties[mutator])
      continue;
    properties = Class.Mutators[mutator](properties, properties[mutator]);
    delete properties[mutator];
  }

  $.extend(klass, this);
  klass.constructor = Class;
  klass.prototype = properties;
  return klass;
};

Class.Mutators = {

  Implements: function(self, klasses) {
    $.each($.splat(klasses), function(klass) {
      Class.prototyping = klass;
      var instance = (typeof klass == 'function') ? new klass : klass;
      for ( var prop in instance) {
        if (!(prop in self)) {
          self[prop] = instance[prop];
        }
      }
      delete Class.prototyping;
    });
    return self;
  }

};

$.extend(Class, {

  inherit: function(object, properties) {
    for ( var key in properties) {
      var override = properties[key];
      var previous = object[key];
      var type = $.type(override);
      if (previous && type == 'function') {
        if (override != previous) {
          Class.override(object, key, override);
        }
      } else if (type == 'object') {
        object[key] = $.merge(previous, override);
      } else {
        object[key] = override;
      }
    }
    return object;
  },

  override: function(object, name, method) {
    var parent = Class.prototyping;
    if (parent && object[name] != parent[name])
      parent = null;
    var override = function() {
      var previous = this.parent;
      this.parent = parent ? parent[name] : object[name];
      var value = method.apply(this, arguments);
      this.parent = previous;
      return value;
    };
    object[name] = override;
  }

});

Class.prototype.implement = function() {
  var proto = this.prototype;
  $.each(Array.prototype.slice.call(arguments || []), function(properties) {
    Class.inherit(proto, properties);
  });
  return this;
};

$jit.Class = Class;

/*
  Object: $jit.json
  
  Provides JSON utility functions.
  
  Most of these functions are JSON-tree traversal and manipulation functions.
*/
$jit.json = {
  /*
     Method: prune
  
     Clears all tree nodes having depth greater than maxLevel.
  
     Parameters:
  
        tree - (object) A JSON tree object. For more information please see <Loader.loadJSON>.
        maxLevel - (number) An integer specifying the maximum level allowed for this tree. All nodes having depth greater than max level will be deleted.

  */
  prune: function(tree, maxLevel) {
    this.each(tree, function(elem, i) {
      if (i == maxLevel && elem.children) {
        delete elem.children;
        elem.children = [];
      }
    });
  },
  /*
     Method: getParent
  
     Returns the parent node of the node having _id_ as id.
  
     Parameters:
  
        tree - (object) A JSON tree object. See also <Loader.loadJSON>.
        id - (string) The _id_ of the child node whose parent will be returned.

    Returns:

        A tree JSON node if any, or false otherwise.
  
  */
  getParent: function(tree, id) {
    if (tree.id == id)
      return false;
    var ch = tree.children;
    if (ch && ch.length > 0) {
      for ( var i = 0; i < ch.length; i++) {
        if (ch[i].id == id)
          return tree;
        else {
          var ans = this.getParent(ch[i], id);
          if (ans)
            return ans;
        }
      }
    }
    return false;
  },
  /*
     Method: getSubtree
  
     Returns the subtree that matches the given id.
  
     Parameters:
  
        tree - (object) A JSON tree object. See also <Loader.loadJSON>.
        id - (string) A node *unique* identifier.
  
     Returns:
  
        A subtree having a root node matching the given id. Returns null if no subtree matching the id is found.

  */
  getSubtree: function(tree, id) {
    if (tree.id == id)
      return tree;
    for ( var i = 0, ch = tree.children; ch && i < ch.length; i++) {
      var t = this.getSubtree(ch[i], id);
      if (t != null)
        return t;
    }
    return null;
  },
  /*
     Method: eachLevel
  
      Iterates on tree nodes with relative depth less or equal than a specified level.
  
     Parameters:
  
        tree - (object) A JSON tree or subtree. See also <Loader.loadJSON>.
        initLevel - (number) An integer specifying the initial relative level. Usually zero.
        toLevel - (number) An integer specifying a top level. This method will iterate only through nodes with depth less than or equal this number.
        action - (function) A function that receives a node and an integer specifying the actual level of the node.
          
    Example:
   (start code js)
     $jit.json.eachLevel(tree, 0, 3, function(node, depth) {
        alert(node.name + ' ' + depth);
     });
   (end code)
  */
  eachLevel: function(tree, initLevel, toLevel, action) {
    if (initLevel <= toLevel) {
      action(tree, initLevel);
      if(!tree.children) return;
      for ( var i = 0, ch = tree.children; i < ch.length; i++) {
        this.eachLevel(ch[i], initLevel + 1, toLevel, action);
      }
    }
  },
  /*
     Method: each
  
      A JSON tree iterator.
  
     Parameters:
  
        tree - (object) A JSON tree or subtree. See also <Loader.loadJSON>.
        action - (function) A function that receives a node.

    Example:
    (start code js)
      $jit.json.each(tree, function(node) {
        alert(node.name);
      });
    (end code)
          
  */
  each: function(tree, action) {
    this.eachLevel(tree, 0, Number.MAX_VALUE, action);
  }
};


/*
     An object containing multiple type of transformations. 
*/

$jit.Trans = {
  $extend: true,
  
  linear: function(p){
    return p;
  }
};

var Trans = $jit.Trans;

(function(){

  var makeTrans = function(transition, params){
    params = $.splat(params);
    return $.extend(transition, {
      easeIn: function(pos){
        return transition(pos, params);
      },
      easeOut: function(pos){
        return 1 - transition(1 - pos, params);
      },
      easeInOut: function(pos){
        return (pos <= 0.5)? transition(2 * pos, params) / 2 : (2 - transition(
            2 * (1 - pos), params)) / 2;
      }
    });
  };

  var transitions = {

    Pow: function(p, x){
      return Math.pow(p, x[0] || 6);
    },

    Expo: function(p){
      return Math.pow(2, 8 * (p - 1));
    },

    Circ: function(p){
      return 1 - Math.sin(Math.acos(p));
    },

    Sine: function(p){
      return 1 - Math.sin((1 - p) * Math.PI / 2);
    },

    Back: function(p, x){
      x = x[0] || 1.618;
      return Math.pow(p, 2) * ((x + 1) * p - x);
    },

    Bounce: function(p){
      var value;
      for ( var a = 0, b = 1; 1; a += b, b /= 2) {
        if (p >= (7 - 4 * a) / 11) {
          value = b * b - Math.pow((11 - 6 * a - 11 * p) / 4, 2);
          break;
        }
      }
      return value;
    },

    Elastic: function(p, x){
      return Math.pow(2, 10 * --p)
          * Math.cos(20 * p * Math.PI * (x[0] || 1) / 3);
    }

  };

  $.each(transitions, function(val, key){
    Trans[key] = makeTrans(val);
  });

  $.each( [
      'Quad', 'Cubic', 'Quart', 'Quint'
  ], function(elem, i){
    Trans[elem] = makeTrans(function(p){
      return Math.pow(p, [
        i + 2
      ]);
    });
  });

})();

/*
   A Class that can perform animations for generic objects.

   If you are looking for animation transitions please take a look at the <Trans> object.

   Used by:

   <Graph.Plot>
   
   Based on:
   
   The Animation class is based in the MooTools Framework <http://mootools.net>. Copyright (c) 2006-2009 Valerio Proietti, <http://mad4milk.net/>. MIT license <http://mootools.net/license.txt>.

*/

var Animation = new Class( {

  initialize: function(options){
    this.setOptions(options);
  },

  setOptions: function(options){
    var opt = {
      duration: 2500,
      fps: 40,
      transition: Trans.Quart.easeInOut,
      compute: $.empty,
      complete: $.empty,
      link: 'ignore'
    };
    this.opt = $.merge(opt, options || {});
    return this;
  },

  step: function(){
    var time = $.time(), opt = this.opt;
    if (time < this.time + opt.duration) {
      var delta = opt.transition((time - this.time) / opt.duration);
      opt.compute(delta);
    } else {
      this.timer = clearInterval(this.timer);
      opt.compute(1);
      opt.complete();
    }
  },

  start: function(){
    if (!this.check())
      return this;
    this.time = 0;
    this.startTimer();
    return this;
  },

  startTimer: function(){
    var that = this, fps = this.opt.fps;
    if (this.timer)
      return false;
    this.time = $.time() - this.time;
    this.timer = setInterval((function(){
      that.step();
    }), Math.round(1000 / fps));
    return true;
  },

  pause: function(){
    this.stopTimer();
    return this;
  },

  resume: function(){
    this.startTimer();
    return this;
  },

  stopTimer: function(){
    if (!this.timer)
      return false;
    this.time = $.time() - this.time;
    this.timer = clearInterval(this.timer);
    return true;
  },

  check: function(){
    if (!this.timer)
      return true;
    if (this.opt.link == 'cancel') {
      this.stopTimer();
      return true;
    }
    return false;
  }
});


var Options = function() {
  var args = arguments;
  for(var i=0, l=args.length, ans={}; i<l; i++) {
    var opt = Options[args[i]];
    if(opt.$extend) {
      $.extend(ans, opt);
    } else {
      ans[args[i]] = opt;  
    }
  }
  return ans;
};

/*
 * File: Options.Canvas.js
 *
*/

/*
  Object: Options.Canvas
  
  These are Canvas general options, like where to append it in the DOM, its dimensions, background, 
  and other more advanced options.
  
  Syntax:
  
  (start code js)

  Options.Canvas = {
    injectInto: 'id',
    type: '2D', //'3D'
    width: false,
    height: false,
    useCanvas: false,
    withLabels: true,
    background: false
  };  
  (end code)
  
  Example:
  
  (start code js)
  var viz = new $jit.Viz({
    injectInto: 'someContainerId',
    width: 500,
    height: 700
  });
  (end code)
  
  Parameters:
  
  injectInto - *required* (string|element) The id of the DOM container for the visualization. It can also be an Element provided that it has an id.
  type - (string) Context type. Default's 2D but can be 3D for webGL enabled browsers.
  width - (number) Default's to the *container's offsetWidth*. The width of the canvas.
  height - (number) Default's to the *container's offsetHeight*. The height of the canvas.
  useCanvas - (boolean|object) Default's *false*. You can pass another <Canvas> instance to be used by the visualization.
  withLabels - (boolean) Default's *true*. Whether to use a label container for the visualization.
  background - (boolean|object) Default's *false*. An object containing information about the rendering of a background canvas.
*/

Options.Canvas = {
    $extend: true,
    
    injectInto: 'id',
    type: '2D',
    width: false,
    height: false,
    useCanvas: false,
    withLabels: true,
    background: false,
    
    Scene: {
      Lighting: {
        enable: false,
        ambient: [1, 1, 1],
        directional: {
          direction: { x: -100, y: -100, z: -100 },
          color: [0.5, 0.3, 0.1]
        }
      }
    }
};

/*
 * File: Options.Node.js
 *
*/

/*
  Object: Options.Node

  Provides Node rendering options for Tree and Graph based visualizations.

  Syntax:
    
  (start code js)
  Options.Node = {
    overridable: false,
    type: 'circle',
    color: '#ccb',
    alpha: 1,
    dim: 3,
    height: 20,
    width: 90,
    autoHeight: false,
    autoWidth: false,
    lineWidth: 1,
    transform: true,
    align: "center",
    angularWidth:1,
    span:1,
    CanvasStyles: {}
  };
  (end code)
  
  Example:
  
  (start code js)
  var viz = new $jit.Viz({
    Node: {
      overridable: true,
      width: 30,
      autoHeight: true,
      type: 'rectangle'
    }
  });
  (end code)
  
  Parameters:

  overridable - (boolean) Default's *false*. Determine whether or not general node properties can be overridden by a particular <Graph.Node>.
  type - (string) Default's *circle*. Node's shape. Node built-in types include 'circle', 'rectangle', 'square', 'ellipse', 'triangle', 'star'. The default Node type might vary in each visualization. You can also implement (non built-in) custom Node types into your visualizations.
  color - (string) Default's *#ccb*. Node color.
  alpha - (number) Default's *1*. The Node's alpha value. *1* is for full opacity.
  dim - (number) Default's *3*. An extra parameter used by 'circle', 'square', 'triangle' and 'star' node types. Depending on each shape, this parameter can set the radius of a circle, half the length of the side of a square, half the base and half the height of a triangle or the length of a side of a star (concave decagon).
  height - (number) Default's *20*. Used by 'rectangle' and 'ellipse' node types. The height of the node shape.
  width - (number) Default's *90*. Used by 'rectangle' and 'ellipse' node types. The width of the node shape.
  autoHeight - (boolean) Default's *false*. Whether to set an auto height for the node depending on the content of the Node's label.
  autoWidth - (boolean) Default's *false*. Whether to set an auto width for the node depending on the content of the Node's label.
  lineWidth - (number) Default's *1*. Used only by some Node shapes. The line width of the strokes of a node.
  transform - (boolean) Default's *true*. Only used by the <Hypertree> visualization. Whether to scale the nodes according to the moebius transformation.
  align - (string) Default's *center*. Possible values are 'center', 'left' or 'right'. Used only by the <ST> visualization, these parameters are used for aligning nodes when some of they dimensions vary.
  angularWidth - (number) Default's *1*. Used in radial layouts (like <RGraph> or <Sunburst> visualizations). The amount of relative 'space' set for a node.
  span - (number) Default's *1*. Used in radial layouts (like <RGraph> or <Sunburst> visualizations). The angle span amount set for a node.
  CanvasStyles - (object) Default's an empty object (i.e. {}). Attach any other canvas specific property that you'd set to the canvas context before plotting a Node.

*/
Options.Node = {
  $extend: false,
  
  overridable: false,
  type: 'circle',
  color: '#ccb',
  alpha: 1,
  dim: 3,
  height: 20,
  width: 90,
  autoHeight: false,
  autoWidth: false,
  lineWidth: 1,
  transform: true,
  align: "center",
  angularWidth:1,
  span:1,
  //Raw canvas styles to be
  //applied to the context instance
  //before plotting a node
  CanvasStyles: {}
};


/*
 * File: Options.Edge.js
 *
*/

/*
  Object: Options.Edge

  Provides Edge rendering options for Tree and Graph based visualizations.

  Syntax:
    
  (start code js)
  Options.Edge = {
    overridable: false,
    type: 'line',
    color: '#ccb',
    lineWidth: 1,
    dim:15,
    alpha: 1,
    CanvasStyles: {}
  };
  (end code)
  
  Example:
  
  (start code js)
  var viz = new $jit.Viz({
    Edge: {
      overridable: true,
      type: 'line',
      color: '#fff',
      CanvasStyles: {
        shadowColor: '#ccc',
        shadowBlur: 10
      }
    }
  });
  (end code)
  
  Parameters:
    
   overridable - (boolean) Default's *false*. Determine whether or not general edges properties can be overridden by a particular <Graph.Adjacence>.
   type - (string) Default's 'line'. Edge styles include 'line', 'hyperline', 'arrow'. The default Edge type might vary in each visualization. You can also implement custom Edge types.
   color - (string) Default's '#ccb'. Edge color.
   lineWidth - (number) Default's *1*. Line/Edge width.
   alpha - (number) Default's *1*. The Edge's alpha value. *1* is for full opacity.
   dim - (number) Default's *15*. An extra parameter used by other complex shapes such as quadratic, bezier or arrow, to determine the shape's diameter.
   epsilon - (number) Default's *7*. Only used when using *enableForEdges* in <Options.Events>. This dimension is used to create an area for the line where the contains method for the edge returns *true*.
   CanvasStyles - (object) Default's an empty object (i.e. {}). Attach any other canvas specific property that you'd set to the canvas context before plotting an Edge.

  See also:
   
   If you want to know more about how to customize Node/Edge data per element, in the JSON or programmatically, take a look at this article.
*/
Options.Edge = {
  $extend: false,
  
  overridable: false,
  type: 'line',
  color: '#ccb',
  lineWidth: 1,
  dim:15,
  alpha: 1,
  epsilon: 7,

  //Raw canvas styles to be
  //applied to the context instance
  //before plotting an edge
  CanvasStyles: {}
};


/*
 * File: Options.Fx.js
 *
*/

/*
  Object: Options.Fx

  Provides animation options like duration of the animations, frames per second and animation transitions.  

  Syntax:
  
  (start code js)
    Options.Fx = {
      fps:40,
      duration: 2500,
      transition: $jit.Trans.Quart.easeInOut,
      clearCanvas: true
    };
  (end code)
  
  Example:
  
  (start code js)
  var viz = new $jit.Viz({
    duration: 1000,
    fps: 35,
    transition: $jit.Trans.linear
  });
  (end code)
  
  Parameters:
  
  clearCanvas - (boolean) Default's *true*. Whether to clear the frame/canvas when the viz is plotted or animated.
  duration - (number) Default's *2500*. Duration of the animation in milliseconds.
  fps - (number) Default's *40*. Frames per second.
  transition - (object) Default's *$jit.Trans.Quart.easeInOut*. The transition used for the animations. See below for a more detailed explanation.
  
  Object: $jit.Trans
  
  This object is used for specifying different animation transitions in all visualizations.

  There are many different type of animation transitions.

  linear:

  Displays a linear transition

  >Trans.linear
  
  (see Linear.png)

  Quad:

  Displays a Quadratic transition.

  >Trans.Quad.easeIn
  >Trans.Quad.easeOut
  >Trans.Quad.easeInOut
  
 (see Quad.png)

 Cubic:

 Displays a Cubic transition.

 >Trans.Cubic.easeIn
 >Trans.Cubic.easeOut
 >Trans.Cubic.easeInOut

 (see Cubic.png)

 Quart:

 Displays a Quartetic transition.

 >Trans.Quart.easeIn
 >Trans.Quart.easeOut
 >Trans.Quart.easeInOut

 (see Quart.png)

 Quint:

 Displays a Quintic transition.

 >Trans.Quint.easeIn
 >Trans.Quint.easeOut
 >Trans.Quint.easeInOut

 (see Quint.png)

 Expo:

 Displays an Exponential transition.

 >Trans.Expo.easeIn
 >Trans.Expo.easeOut
 >Trans.Expo.easeInOut

 (see Expo.png)

 Circ:

 Displays a Circular transition.

 >Trans.Circ.easeIn
 >Trans.Circ.easeOut
 >Trans.Circ.easeInOut

 (see Circ.png)

 Sine:

 Displays a Sineousidal transition.

 >Trans.Sine.easeIn
 >Trans.Sine.easeOut
 >Trans.Sine.easeInOut

 (see Sine.png)

 Back:

 >Trans.Back.easeIn
 >Trans.Back.easeOut
 >Trans.Back.easeInOut

 (see Back.png)

 Bounce:

 Bouncy transition.

 >Trans.Bounce.easeIn
 >Trans.Bounce.easeOut
 >Trans.Bounce.easeInOut

 (see Bounce.png)

 Elastic:

 Elastic curve.

 >Trans.Elastic.easeIn
 >Trans.Elastic.easeOut
 >Trans.Elastic.easeInOut

 (see Elastic.png)
 
 Based on:
     
 Easing and Transition animation methods are based in the MooTools Framework <http://mootools.net>. Copyright (c) 2006-2010 Valerio Proietti, <http://mad4milk.net/>. MIT license <http://mootools.net/license.txt>.


*/
Options.Fx = {
  $extend: true,
  
  fps:40,
  duration: 2500,
  transition: $jit.Trans.Quart.easeInOut,
  clearCanvas: true
};

/*
 * File: Options.Label.js
 *
*/
/*
  Object: Options.Label

  Provides styling for Labels such as font size, family, etc. Also sets Node labels as HTML, SVG or Native canvas elements.  

  Syntax:
  
  (start code js)
    Options.Label = {
      overridable: false,
      type: 'HTML', //'SVG', 'Native'
      style: ' ',
      size: 10,
      family: 'sans-serif',
      textAlign: 'center',
      textBaseline: 'alphabetic',
      color: '#fff'
    };
  (end code)
  
  Example:
  
  (start code js)
  var viz = new $jit.Viz({
    Label: {
      type: 'Native',
      size: 11,
      color: '#ccc'
    }
  });
  (end code)
  
  Parameters:
    
  overridable - (boolean) Default's *false*. Determine whether or not general label properties can be overridden by a particular <Graph.Node>.
  type - (string) Default's *HTML*. The type for the labels. Can be 'HTML', 'SVG' or 'Native' canvas labels.
  style - (string) Default's *empty string*. Can be 'italic' or 'bold'. This parameter is only taken into account when using 'Native' canvas labels. For DOM based labels the className *node* is added to the DOM element for styling via CSS. You can also use <Options.Controller> methods to style individual labels.
  size - (number) Default's *10*. The font's size. This parameter is only taken into account when using 'Native' canvas labels. For DOM based labels the className *node* is added to the DOM element for styling via CSS. You can also use <Options.Controller> methods to style individual labels.
  family - (string) Default's *sans-serif*. The font's family. This parameter is only taken into account when using 'Native' canvas labels. For DOM based labels the className *node* is added to the DOM element for styling via CSS. You can also use <Options.Controller> methods to style individual labels.
  color - (string) Default's *#fff*. The font's color. This parameter is only taken into account when using 'Native' canvas labels. For DOM based labels the className *node* is added to the DOM element for styling via CSS. You can also use <Options.Controller> methods to style individual labels.
*/
Options.Label = {
  $extend: false,
  
  overridable: false,
  type: 'HTML', //'SVG', 'Native'
  style: ' ',
  size: 10,
  family: 'sans-serif',
  textAlign: 'center',
  textBaseline: 'alphabetic',
  color: '#fff'
};


/*
 * File: Options.Tips.js
 *
 */

/*
  Object: Options.Tips
  
  Tips options
  
  Syntax:
    
  (start code js)
  Options.Tips = {
    enable: false,
    type: 'auto',
    offsetX: 20,
    offsetY: 20,
    onShow: $.empty,
    onHide: $.empty
  };
  (end code)
  
  Example:
  
  (start code js)
  var viz = new $jit.Viz({
    Tips: {
      enable: true,
      type: 'Native',
      offsetX: 10,
      offsetY: 10,
      onShow: function(tip, node) {
        tip.innerHTML = node.name;
      }
    }
  });
  (end code)

  Parameters:

  enable - (boolean) Default's *false*. If *true*, a tooltip will be shown when a node is hovered. The tooltip is a div DOM element having "tip" as CSS class. 
  type - (string) Default's *auto*. Defines where to attach the MouseEnter/Leave tooltip events. Possible values are 'Native' to attach them to the canvas or 'HTML' to attach them to DOM label elements (if defined). 'auto' sets this property to the value of <Options.Label>'s *type* property.
  offsetX - (number) Default's *20*. An offset added to the current tooltip x-position (which is the same as the current mouse position). Default's 20.
  offsetY - (number) Default's *20*. An offset added to the current tooltip y-position (which is the same as the current mouse position). Default's 20.
  onShow(tip, node) - This callack is used right before displaying a tooltip. The first formal parameter is the tip itself (which is a DivElement). The second parameter may be a <Graph.Node> for graph based visualizations or an object with label, value properties for charts.
  onHide() - This callack is used when hiding a tooltip.

*/
Options.Tips = {
  $extend: false,
  
  enable: false,
  type: 'auto',
  offsetX: 20,
  offsetY: 20,
  force: false,
  onShow: $.empty,
  onHide: $.empty
};


/*
 * File: Options.NodeStyles.js
 *
 */

/*
  Object: Options.NodeStyles
  
  Apply different styles when a node is hovered or selected.
  
  Syntax:
    
  (start code js)
  Options.NodeStyles = {
    enable: false,
    type: 'auto',
    stylesHover: false,
    stylesClick: false
  };
  (end code)
  
  Example:
  
  (start code js)
  var viz = new $jit.Viz({
    NodeStyles: {
      enable: true,
      type: 'Native',
      stylesHover: {
        dim: 30,
        color: '#fcc'
      },
      duration: 600
    }
  });
  (end code)

  Parameters:
  
  enable - (boolean) Default's *false*. Whether to enable this option.
  type - (string) Default's *auto*. Use this to attach the hover/click events in the nodes or the nodes labels (if they have been defined as DOM elements: 'HTML' or 'SVG', see <Options.Label> for more details). The default 'auto' value will set NodeStyles to the same type defined for <Options.Label>.
  stylesHover - (boolean|object) Default's *false*. An object with node styles just like the ones defined for <Options.Node> or *false* otherwise.
  stylesClick - (boolean|object) Default's *false*. An object with node styles just like the ones defined for <Options.Node> or *false* otherwise.
*/

Options.NodeStyles = {
  $extend: false,
  
  enable: false,
  type: 'auto',
  stylesHover: false,
  stylesClick: false
};


/*
 * File: Options.Events.js
 *
*/

/*
  Object: Options.Events
  
  Configuration for adding mouse/touch event handlers to Nodes.
  
  Syntax:
  
  (start code js)
  Options.Events = {
    enable: false,
    enableForEdges: false,
    type: 'auto',
    onClick: $.empty,
    onRightClick: $.empty,
    onMouseMove: $.empty,
    onMouseEnter: $.empty,
    onMouseLeave: $.empty,
    onDragStart: $.empty,
    onDragMove: $.empty,
    onDragCancel: $.empty,
    onDragEnd: $.empty,
    onTouchStart: $.empty,
    onTouchMove: $.empty,
    onTouchEnd: $.empty,
    onTouchCancel: $.empty,
    onMouseWheel: $.empty
  };
  (end code)
  
  Example:
  
  (start code js)
  var viz = new $jit.Viz({
    Events: {
      enable: true,
      onClick: function(node, eventInfo, e) {
        viz.doSomething();
      },
      onMouseEnter: function(node, eventInfo, e) {
        viz.canvas.getElement().style.cursor = 'pointer';
      },
      onMouseLeave: function(node, eventInfo, e) {
        viz.canvas.getElement().style.cursor = '';
      }
    }
  });
  (end code)
  
  Parameters:
  
  enable - (boolean) Default's *false*. Whether to enable the Event system.
  enableForEdges - (boolean) Default's *false*. Whether to track events also in arcs. If *true* the same callbacks -described below- are used for nodes *and* edges. A simple duck type check for edges is to check for *node.nodeFrom*.
  type - (string) Default's 'auto'. Whether to attach the events onto the HTML labels (via event delegation) or to use the custom 'Native' canvas Event System of the library. 'auto' is set when you let the <Options.Label> *type* parameter decide this.
  onClick(node, eventInfo, e) - Triggered when a user performs a click in the canvas. *node* is the <Graph.Node> clicked or false if no node has been clicked. *e* is the grabbed event (should return the native event in a cross-browser manner). *eventInfo* is an object containing useful methods like *getPos* to get the mouse position relative to the canvas. 
  onRightClick(node, eventInfo, e) - Triggered when a user performs a right click in the canvas. *node* is the <Graph.Node> right clicked or false if no node has been clicked. *e* is the grabbed event (should return the native event in a cross-browser manner). *eventInfo* is an object containing useful methods like *getPos* to get the mouse position relative to the canvas. 
  onMouseMove(node, eventInfo, e) - Triggered when the user moves the mouse. *node* is the <Graph.Node> under the cursor as it's moving over the canvas or false if no node has been clicked. *e* is the grabbed event (should return the native event in a cross-browser manner).  *eventInfo* is an object containing useful methods like *getPos* to get the mouse position relative to the canvas.
  onMouseEnter(node, eventInfo, e) - Triggered when a user moves the mouse over a node. *node* is the <Graph.Node> that the mouse just entered. *e* is the grabbed event (should return the native event in a cross-browser manner). *eventInfo* is an object containing useful methods like *getPos* to get the mouse position relative to the canvas. 
  onMouseLeave(node, eventInfo, e) - Triggered when the user mouse-outs a node. *node* is the <Graph.Node> 'mouse-outed'. *e* is the grabbed event (should return the native event in a cross-browser manner). *eventInfo* is an object containing useful methods like *getPos* to get the mouse position relative to the canvas. 
  onDragStart(node, eventInfo, e) - Triggered when the user mouse-downs over a node. *node* is the <Graph.Node> being pressed. *e* is the grabbed event (should return the native event in a cross-browser manner). *eventInfo* is an object containing useful methods like *getPos* to get the mouse position relative to the canvas. 
  onDragMove(node, eventInfo, e) - Triggered when a user, after pressing the mouse button over a node, moves the mouse around. *node* is the <Graph.Node> being dragged. *e* is the grabbed event (should return the native event in a cross-browser manner). *eventInfo* is an object containing useful methods like *getPos* to get the mouse position relative to the canvas. 
  onDragEnd(node, eventInfo, e) - Triggered when a user finished dragging a node. *node* is the <Graph.Node> being dragged. *e* is the grabbed event (should return the native event in a cross-browser manner). *eventInfo* is an object containing useful methods like *getPos* to get the mouse position relative to the canvas. 
  onDragCancel(node, eventInfo, e) - Triggered when the user releases the mouse button over a <Graph.Node> that wasn't dragged (i.e. the user didn't perform any mouse movement after pressing the mouse button). *node* is the <Graph.Node> being dragged. *e* is the grabbed event (should return the native event in a cross-browser manner). *eventInfo* is an object containing useful methods like *getPos* to get the mouse position relative to the canvas. 
  onTouchStart(node, eventInfo, e) - Behaves just like onDragStart. 
  onTouchMove(node, eventInfo, e) - Behaves just like onDragMove. 
  onTouchEnd(node, eventInfo, e) - Behaves just like onDragEnd. 
  onTouchCancel(node, eventInfo, e) - Behaves just like onDragCancel.
  onMouseWheel(delta, e) - Triggered when the user uses the mouse scroll over the canvas. *delta* is 1 or -1 depending on the sense of the mouse scroll.
*/

Options.Events = {
  $extend: false,
  
  enable: false,
  enableForEdges: false,
  type: 'auto',
  onClick: $.empty,
  onRightClick: $.empty,
  onMouseMove: $.empty,
  onMouseEnter: $.empty,
  onMouseLeave: $.empty,
  onDragStart: $.empty,
  onDragMove: $.empty,
  onDragCancel: $.empty,
  onDragEnd: $.empty,
  onTouchStart: $.empty,
  onTouchMove: $.empty,
  onTouchEnd: $.empty,
  onMouseWheel: $.empty
};

/*
 * File: Options.Navigation.js
 *
*/

/*
  Object: Options.Navigation
  
  Panning and zooming options for Graph/Tree based visualizations. These options are implemented 
  by all visualizations except charts (<AreaChart>, <BarChart> and <PieChart>).
  
  Syntax:
  
  (start code js)

  Options.Navigation = {
    enable: false,
    type: 'auto',
    panning: false, //true, 'avoid nodes'
    zooming: false
  };
  
  (end code)
  
  Example:
    
  (start code js)
  var viz = new $jit.Viz({
    Navigation: {
      enable: true,
      panning: 'avoid nodes',
      zooming: 20
    }
  });
  (end code)
  
  Parameters:
  
  enable - (boolean) Default's *false*. Whether to enable Navigation capabilities.
  type - (string) Default's 'auto'. Whether to attach the navigation events onto the HTML labels (via event delegation) or to use the custom 'Native' canvas Event System of the library. When 'auto' set when you let the <Options.Label> *type* parameter decide this.
  panning - (boolean|string) Default's *false*. Set this property to *true* if you want to add Drag and Drop panning support to the visualization. You can also set this parameter to 'avoid nodes' to enable DnD panning but disable it if the DnD is taking place over a node. This is useful when some other events like Drag & Drop for nodes are added to <Graph.Nodes>.
  zooming - (boolean|number) Default's *false*. Set this property to a numeric value to turn mouse-scroll zooming on. The number will be proportional to the mouse-scroll sensitivity.
  
*/

Options.Navigation = {
  $extend: false,
  
  enable: false,
  type: 'auto',
  panning: false, //true | 'avoid nodes'
  zooming: false
};

/*
 * File: Options.Controller.js
 *
*/

/*
  Object: Options.Controller
  
  Provides controller methods. Controller methods are callback functions that get called at different stages 
  of the animation, computing or plotting of the visualization.
  
  Implemented by:
    
  All visualizations except charts (<AreaChart>, <BarChart> and <PieChart>).
  
  Syntax:
  
  (start code js)

  Options.Controller = {
    onBeforeCompute: $.empty,
    onAfterCompute:  $.empty,
    onCreateLabel:   $.empty,
    onPlaceLabel:    $.empty,
    onComplete:      $.empty,
    onBeforePlotLine:$.empty,
    onAfterPlotLine: $.empty,
    onBeforePlotNode:$.empty,
    onAfterPlotNode: $.empty,
    request:         false
  };
  
  (end code)
  
  Example:
    
  (start code js)
  var viz = new $jit.Viz({
    onBeforePlotNode: function(node) {
      if(node.selected) {
        node.setData('color', '#ffc');
      } else {
        node.removeData('color');
      }
    },
    onBeforePlotLine: function(adj) {
      if(adj.nodeFrom.selected && adj.nodeTo.selected) {
        adj.setData('color', '#ffc');
      } else {
        adj.removeData('color');
      }
    },
    onAfterCompute: function() {
      alert("computed!");
    }
  });
  (end code)
  
  Parameters:

   onBeforeCompute(node) - This method is called right before performing all computations and animations. The selected <Graph.Node> is passed as parameter.
   onAfterCompute() - This method is triggered after all animations or computations ended.
   onCreateLabel(domElement, node) - This method receives a new label DIV element as first parameter, and the corresponding <Graph.Node> as second parameter. This method will only be called once for each label. This method is useful when adding events or styles to the labels used by the JIT.
   onPlaceLabel(domElement, node) - This method receives a label DIV element as first parameter and the corresponding <Graph.Node> as second parameter. This method is called each time a label has been placed in the visualization, for example at each step of an animation, and thus it allows you to update the labels properties, such as size or position. Note that onPlaceLabel will be triggered after updating the labels positions. That means that, for example, the left and top css properties are already updated to match the nodes positions. Width and height properties are not set however.
   onBeforePlotNode(node) - This method is triggered right before plotting each <Graph.Node>. This method is useful for changing a node style right before plotting it.
   onAfterPlotNode(node) - This method is triggered right after plotting each <Graph.Node>.
   onBeforePlotLine(adj) - This method is triggered right before plotting a <Graph.Adjacence>. This method is useful for adding some styles to a particular edge before being plotted.
   onAfterPlotLine(adj) - This method is triggered right after plotting a <Graph.Adjacence>.

    *Used in <ST>, <TM.Base> and <Icicle> visualizations*
    
    request(nodeId, level, onComplete) - This method is used for buffering information into the visualization. When clicking on an empty node, the visualization will make a request for this node's subtrees, specifying a given level for this subtree (defined by _levelsToShow_). Once the request is completed, the onComplete callback should be called with the given result. This is useful to provide on-demand information into the visualizations withought having to load the entire information from start. The parameters used by this method are _nodeId_, which is the id of the root of the subtree to request, _level_ which is the depth of the subtree to be requested (0 would mean just the root node). _onComplete_ is an object having the callback method _onComplete.onComplete(json)_ that should be called once the json has been retrieved.  
 
 */
Options.Controller = {
  $extend: true,
  
  onBeforeCompute: $.empty,
  onAfterCompute:  $.empty,
  onCreateLabel:   $.empty,
  onPlaceLabel:    $.empty,
  onComplete:      $.empty,
  onBeforePlotLine:$.empty,
  onAfterPlotLine: $.empty,
  onBeforePlotNode:$.empty,
  onAfterPlotNode: $.empty,
  request:         false
};


/*
 * File: Extras.js
 * 
 * Provides Extras such as Tips and Style Effects.
 * 
 * Description:
 * 
 * Provides the <Tips> and <NodeStyles> classes and functions.
 *
 */

/*
 * Manager for mouse events (clicking and mouse moving).
 * 
 * This class is used for registering objects implementing onClick
 * and onMousemove methods. These methods are called when clicking or
 * moving the mouse around  the Canvas.
 * For now, <Tips> and <NodeStyles> are classes implementing these methods.
 * 
 */
var ExtrasInitializer = {
  initialize: function(className, viz) {
    this.viz = viz;
    this.canvas = viz.canvas;
    this.config = viz.config[className];
    this.nodeTypes = viz.fx.nodeTypes;
    var type = this.config.type;
    this.dom = type == 'auto'? (viz.config.Label.type != 'Native') : (type != 'Native');
    this.labelContainer = this.dom && viz.labels.getLabelContainer();
    this.isEnabled() && this.initializePost();
  },
  initializePost: $.empty,
  setAsProperty: $.lambda(false),
  isEnabled: function() {
    return this.config.enable;
  },
  isLabel: function(e, win, group) {
    e = $.event.get(e, win);
    var labelContainer = this.labelContainer,
        target = e.target || e.srcElement,
        related = e.relatedTarget;
    if(group) {
      return related && related == this.viz.canvas.getCtx().canvas 
          && !!target && this.isDescendantOf(target, labelContainer);
    } else {
      return this.isDescendantOf(target, labelContainer);
    }
  },
  isDescendantOf: function(elem, par) {
    while(elem && elem.parentNode) {
      if(elem.parentNode == par)
        return elem;
      elem = elem.parentNode;
    }
    return false;
  }
};

var EventsInterface = {
  onMouseUp: $.empty,
  onMouseDown: $.empty,
  onMouseMove: $.empty,
  onMouseOver: $.empty,
  onMouseOut: $.empty,
  onMouseWheel: $.empty,
  onTouchStart: $.empty,
  onTouchMove: $.empty,
  onTouchEnd: $.empty,
  onTouchCancel: $.empty
};

var MouseEventsManager = new Class({
  initialize: function(viz) {
    this.viz = viz;
    this.canvas = viz.canvas;
    this.node = false;
    this.edge = false;
    this.registeredObjects = [];
    this.attachEvents();
  },
  
  attachEvents: function() {
    var htmlCanvas = this.canvas.getElement(), 
        that = this;
    htmlCanvas.oncontextmenu = $.lambda(false);
    $.addEvents(htmlCanvas, {
      'mouseup': function(e, win) {
        var event = $.event.get(e, win);
        that.handleEvent('MouseUp', e, win, 
            that.makeEventObject(e, win), 
            $.event.isRightClick(event));
      },
      'mousedown': function(e, win) {
        var event = $.event.get(e, win);
        that.handleEvent('MouseDown', e, win, that.makeEventObject(e, win), 
            $.event.isRightClick(event));
      },
      'mousemove': function(e, win) {
        that.handleEvent('MouseMove', e, win, that.makeEventObject(e, win));
      },
      'mouseover': function(e, win) {
        that.handleEvent('MouseOver', e, win, that.makeEventObject(e, win));
      },
      'mouseout': function(e, win) {
        that.handleEvent('MouseOut', e, win, that.makeEventObject(e, win));
      },
      'touchstart': function(e, win) {
        that.handleEvent('TouchStart', e, win, that.makeEventObject(e, win));
      },
      'touchmove': function(e, win) {
        that.handleEvent('TouchMove', e, win, that.makeEventObject(e, win));
      },
      'touchend': function(e, win) {
        that.handleEvent('TouchEnd', e, win, that.makeEventObject(e, win));
      }
    });
    //attach mousewheel event
    var handleMouseWheel = function(e, win) {
      var event = $.event.get(e, win);
      var wheel = $.event.getWheel(event);
      that.handleEvent('MouseWheel', e, win, wheel);
    };
    //TODO(nico): this is a horrible check for non-gecko browsers!
    if(!document.getBoxObjectFor && window.mozInnerScreenX == null) {
      $.addEvent(htmlCanvas, 'mousewheel', handleMouseWheel);
    } else {
      htmlCanvas.addEventListener('DOMMouseScroll', handleMouseWheel, false);
    }
  },
  
  register: function(obj) {
    this.registeredObjects.push(obj);
  },
  
  handleEvent: function() {
    var args = Array.prototype.slice.call(arguments),
        type = args.shift();
    for(var i=0, regs=this.registeredObjects, l=regs.length; i<l; i++) {
      regs[i]['on' + type].apply(regs[i], args);
    }
  },
  
  makeEventObject: function(e, win) {
    var that = this,
        graph = this.viz.graph,
        fx = this.viz.fx,
        ntypes = fx.nodeTypes,
        etypes = fx.edgeTypes;
    return {
      pos: false,
      node: false,
      edge: false,
      contains: false,
      getNodeCalled: false,
      getEdgeCalled: false,
      getPos: function() {
        //TODO(nico): check why this can't be cache anymore when using edge detection
        //if(this.pos) return this.pos;
        var canvas = that.viz.canvas,
            s = canvas.getSize(),
            p = canvas.getPos(),
            ox = canvas.translateOffsetX,
            oy = canvas.translateOffsetY,
            sx = canvas.scaleOffsetX,
            sy = canvas.scaleOffsetY,
            pos = $.event.getPos(e, win);
        this.pos = {
          x: (pos.x - p.x - s.width/2 - ox) * 1/sx,
          y: (pos.y - p.y - s.height/2 - oy) * 1/sy
        };
        return this.pos;
      },
      getNode: function() {
        if(this.getNodeCalled) return this.node;
        this.getNodeCalled = true;
        for(var id in graph.nodes) {
          var n = graph.nodes[id],
              geom = n && ntypes[n.getData('type')],
              
              // START METAMAPS CODE
              contains = n.getData('alpha') !== 0 && geom && geom.contains && geom.contains.call(fx, n, this.getPos());
              // END METAMAPS CODE
              // ORIGINAL CODE contains = geom && geom.contains && geom.contains.call(fx, n, this.getPos());

          if(contains) {
            this.contains = contains;
            return that.node = this.node = n;
          }
        }
        return that.node = this.node = false;
      },
      getEdge: function() {
        if(this.getEdgeCalled) return this.edge;
        this.getEdgeCalled = true;
        var hashset = {};
        for(var id in graph.edges) {
          var edgeFrom = graph.edges[id];
          hashset[id] = true;
          for(var edgeId in edgeFrom) {
            if(edgeId in hashset) continue;
            var e = edgeFrom[edgeId],
                geom = e && etypes[e.getData('type')],

                // START METAMAPS CODE
                contains = e.getData('alpha') !== 0 && geom && geom.contains && geom.contains.call(fx, e, this.getPos());
                // END METAMAPS CODE
                // ORIGINAL CODE contains = geom && geom.contains && geom.contains.call(fx, n, this.getPos());
            if(contains) {
              this.contains = contains;
              return that.edge = this.edge = e;
            }
          }
        }
        return that.edge = this.edge = false;
      },
      getContains: function() {
        if(this.getNodeCalled) return this.contains;
        this.getNode();
        return this.contains;
      }
    };
  }
});

/* 
 * Provides the initialization function for <NodeStyles> and <Tips> implemented 
 * by all main visualizations.
 *
 */
var Extras = {
  initializeExtras: function() {
    var mem = new MouseEventsManager(this), that = this;
    $.each(['NodeStyles', 'Tips', 'Navigation', 'Events'], function(k) {
      var obj = new Extras.Classes[k](k, that);
      if(obj.isEnabled()) {
        mem.register(obj);
      }
      if(obj.setAsProperty()) {
        that[k.toLowerCase()] = obj;
      }
    });
  }   
};

Extras.Classes = {};
/*
  Class: Events
   
  This class defines an Event API to be accessed by the user.
  The methods implemented are the ones defined in the <Options.Events> object.
*/

Extras.Classes.Events = new Class({
  Implements: [ExtrasInitializer, EventsInterface],
  
  initializePost: function() {
    this.fx = this.viz.fx;
    this.ntypes = this.viz.fx.nodeTypes;
    this.etypes = this.viz.fx.edgeTypes;
    
    this.hovered = false;
    this.pressed = false;
    this.touched = false;

    this.touchMoved = false;
    this.moved = false;
    
  },
  
  setAsProperty: $.lambda(true),
  
  onMouseUp: function(e, win, event, isRightClick) {
    var evt = $.event.get(e, win);
    if(!this.moved) {
      if(isRightClick) {
        this.config.onRightClick(this.hovered, event, evt);
      } else {
        this.config.onClick(this.pressed, event, evt);
      }
    }
    if(this.pressed) {
      if(this.moved) {
        this.config.onDragEnd(this.pressed, event, evt);
      } else {
        this.config.onDragCancel(this.pressed, event, evt);
      }
      this.pressed = this.moved = false;
    }
  },

  onMouseOut: function(e, win, event) {
   //mouseout a label
   var evt = $.event.get(e, win), label;
   if(this.dom && (label = this.isLabel(e, win, true))) {
     this.config.onMouseLeave(this.viz.graph.getNode(label.id),
                              event, evt);
     this.hovered = false;
     return;
   }
   //mouseout canvas
   var rt = evt.relatedTarget,
       canvasWidget = this.canvas.getElement();
   while(rt && rt.parentNode) {
     if(canvasWidget == rt.parentNode) return;
     rt = rt.parentNode;
   }
   if(this.hovered) {
     this.config.onMouseLeave(this.hovered,
         event, evt);
     this.hovered = false;
   }
  },
  
  onMouseOver: function(e, win, event) {
    //mouseover a label
    var evt = $.event.get(e, win), label;
    if(this.dom && (label = this.isLabel(e, win, true))) {
      this.hovered = this.viz.graph.getNode(label.id);
      this.config.onMouseEnter(this.hovered,
                               event, evt);
    }
  },
  
  onMouseMove: function(e, win, event) {
   var label, evt = $.event.get(e, win);
   if(this.pressed) {
     this.moved = true;
     this.config.onDragMove(this.pressed, event, evt);
     return;
   }
   if(this.dom) {
     this.config.onMouseMove(this.hovered,
         event, evt);
   } else {
     if(this.hovered) {
       var hn = this.hovered;
       var geom = hn.nodeFrom? this.etypes[hn.getData('type')] : this.ntypes[hn.getData('type')];
       var contains = geom && geom.contains 
         && geom.contains.call(this.fx, hn, event.getPos());
       if(contains) {
         this.config.onMouseMove(hn, event, evt);
         return;
       } else {
         this.config.onMouseLeave(hn, event, evt);
         this.hovered = false;
       }
     }
     if(this.hovered = (event.getNode() || (this.config.enableForEdges && event.getEdge()))) {
       this.config.onMouseEnter(this.hovered, event, evt);
     } else {
       this.config.onMouseMove(false, event, evt);
     }
   }
  },
  
  onMouseWheel: function(e, win, delta) {
    this.config.onMouseWheel(delta, $.event.get(e, win));
  },
  
  onMouseDown: function(e, win, event) {
    
    // START METAMAPS CODE
    var evt = $.event.get(e, win);
    this.pressed = event.getNode() || (this.config.enableForEdges && event.getEdge());
    // END METAMAPS CODE    
    // ORIGINAL CODE
    /*var evt = $.event.get(e, win), label;
    if(this.dom) {
      if(label = this.isLabel(e, win)) {
        this.pressed = this.viz.graph.getNode(label.id);
      }
    } else {
      this.pressed = event.getNode() || (this.config.enableForEdges && event.getEdge());
    } */
    this.pressed && this.config.onDragStart(this.pressed, event, evt);
  },
  
  onTouchStart: function(e, win, event) {
    var evt = $.event.get(e, win), label;
    if(this.dom && (label = this.isLabel(e, win))) {
      this.touched = this.viz.graph.getNode(label.id);
    } else {
      this.touched = event.getNode() || (this.config.enableForEdges && event.getEdge());
    }
    this.touched && this.config.onTouchStart(this.touched, event, evt);
  },
  
  onTouchMove: function(e, win, event) {
    var evt = $.event.get(e, win);
    if(this.touched) {
      this.touchMoved = true;
      this.config.onTouchMove(this.touched, event, evt);
    }
  },
  
  onTouchEnd: function(e, win, event) {
    var evt = $.event.get(e, win);
    if(this.touched) {
      if(this.touchMoved) {
        this.config.onTouchEnd(this.touched, event, evt);
      } else {
        this.config.onTouchCancel(this.touched, event, evt);
      }
      this.touched = this.touchMoved = false;
    }
  }
});

/*
   Class: Tips
    
   A class containing tip related functions. This class is used internally.
   
   Used by:
   
   <ST>, <Sunburst>, <Hypertree>, <RGraph>, <TM>, <ForceDirected>, <Icicle>
   
   See also:
   
   <Options.Tips>
*/

Extras.Classes.Tips = new Class({
  Implements: [ExtrasInitializer, EventsInterface],
  
  initializePost: function() {
    //add DOM tooltip
    if(document.body) {
      var tip = $('_tooltip') || document.createElement('div');
      tip.id = '_tooltip';
      tip.className = 'tip';
      $.extend(tip.style, {
        position: 'absolute',
        display: 'none',
        zIndex: 13000
      });
      document.body.appendChild(tip);
      this.tip = tip;
      this.node = false;
    }
  },
  
  setAsProperty: $.lambda(true),
  
  onMouseOut: function(e, win) {
    //mouseout a label
    var evt = $.event.get(e, win);
    if(this.dom && this.isLabel(e, win, true)) {
      this.hide(true);
      return;
    }
    //mouseout canvas
    var rt = e.relatedTarget,
        canvasWidget = this.canvas.getElement();
    while(rt && rt.parentNode) {
      if(canvasWidget == rt.parentNode) return;
      rt = rt.parentNode;
    }
    this.hide(false);
  },
  
  onMouseOver: function(e, win) {
    //mouseover a label
    var label;
    if(this.dom && (label = this.isLabel(e, win, false))) {
      this.node = this.viz.graph.getNode(label.id);
      this.config.onShow(this.tip, this.node, label);
    }
  },
  
  onMouseMove: function(e, win, opt) {
    if(this.dom && this.isLabel(e, win)) {
      this.setTooltipPosition($.event.getPos(e, win));
    }
    if(!this.dom) {
      var node = opt.getNode();
      if(!node) {
        this.hide(true);
        return;
      }
      if(this.config.force || !this.node || this.node.id != node.id) {
        this.node = node;
        this.config.onShow(this.tip, node, opt.getContains());
      }
      this.setTooltipPosition($.event.getPos(e, win));
    }
  },
  
  setTooltipPosition: function(pos) {
    var tip = this.tip, 
        style = tip.style, 
        cont = this.config;
    style.display = '';
    //get window dimensions
    var win = {
      'height': document.body.clientHeight,
      'width': document.body.clientWidth
    };
    //get tooltip dimensions
    var obj = {
      'width': tip.offsetWidth,
      'height': tip.offsetHeight  
    };
    //set tooltip position
    var x = cont.offsetX, y = cont.offsetY;
    style.top = ((pos.y + y + obj.height > win.height)?  
        (pos.y - obj.height - y) : pos.y + y) + 'px';
    style.left = ((pos.x + obj.width + x > win.width)? 
        (pos.x - obj.width - x) : pos.x + x) + 'px';
  },
  
  hide: function(triggerCallback) {
    this.tip.style.display = 'none';
    triggerCallback && this.config.onHide();
  }
});

/*
  Class: NodeStyles
   
  Change node styles when clicking or hovering a node. This class is used internally.
  
  Used by:
  
  <ST>, <Sunburst>, <Hypertree>, <RGraph>, <TM>, <ForceDirected>, <Icicle>
  
  See also:
  
  <Options.NodeStyles>
*/
Extras.Classes.NodeStyles = new Class({
  Implements: [ExtrasInitializer, EventsInterface],
  
  initializePost: function() {
    this.fx = this.viz.fx;
    this.types = this.viz.fx.nodeTypes;
    this.nStyles = this.config;
    this.nodeStylesOnHover = this.nStyles.stylesHover;
    this.nodeStylesOnClick = this.nStyles.stylesClick;
    this.hoveredNode = false;
    this.fx.nodeFxAnimation = new Animation();
    
    this.down = false;
    this.move = false;
  },
  
  onMouseOut: function(e, win) {
    this.down = this.move = false;
    if(!this.hoveredNode) return;
    //mouseout a label
    if(this.dom && this.isLabel(e, win, true)) {
      this.toggleStylesOnHover(this.hoveredNode, false);
    }
    //mouseout canvas
    var rt = e.relatedTarget,
        canvasWidget = this.canvas.getElement();
    while(rt && rt.parentNode) {
      if(canvasWidget == rt.parentNode) return;
      rt = rt.parentNode;
    }
    this.toggleStylesOnHover(this.hoveredNode, false);
    this.hoveredNode = false;
  },
  
  onMouseOver: function(e, win) {
    //mouseover a label
    var label;
    if(this.dom && (label = this.isLabel(e, win, true))) {
      var node = this.viz.graph.getNode(label.id);
      if(node.selected) return;
      this.hoveredNode = node;
      this.toggleStylesOnHover(this.hoveredNode, true);
    }
  },
  
  onMouseDown: function(e, win, event, isRightClick) {
    if(isRightClick) return;
    var label;
    if(this.dom && (label = this.isLabel(e, win))) {
      this.down = this.viz.graph.getNode(label.id);
    } else if(!this.dom) {
      this.down = event.getNode();
    }
    this.move = false;
  },
  
  onMouseUp: function(e, win, event, isRightClick) {
    if(isRightClick) return;
    if(!this.move) {
      this.onClick(event.getNode());
    }
    this.down = this.move = false;
  },
  
  getRestoredStyles: function(node, type) {
    var restoredStyles = {}, 
        nStyles = this['nodeStylesOn' + type];
    for(var prop in nStyles) {
      restoredStyles[prop] = node.styles['$' + prop];
    }
    return restoredStyles;
  },
  
  toggleStylesOnHover: function(node, set) {
    if(this.nodeStylesOnHover) {
      this.toggleStylesOn('Hover', node, set);
    }
  },

  toggleStylesOnClick: function(node, set) {
    if(this.nodeStylesOnClick) {
      this.toggleStylesOn('Click', node, set);
    }
  },
  
  toggleStylesOn: function(type, node, set) {
    var viz = this.viz;
    var nStyles = this.nStyles;
    if(set) {
      var that = this;
      if(!node.styles) {
        node.styles = $.merge(node.data, {});
      }
      for(var s in this['nodeStylesOn' + type]) {
        var $s = '$' + s;
        if(!($s in node.styles)) {
            node.styles[$s] = node.getData(s); 
        }
      }
      viz.fx.nodeFx($.extend({
        'elements': {
          'id': node.id,
          'properties': that['nodeStylesOn' + type]
         },
         transition: Trans.Quart.easeOut,
         duration:300,
         fps:40
      }, this.config));
    } else {
      var restoredStyles = this.getRestoredStyles(node, type);
      viz.fx.nodeFx($.extend({
        'elements': {
          'id': node.id,
          'properties': restoredStyles
         },
         transition: Trans.Quart.easeOut,
         duration:300,
         fps:40
      }, this.config));
    }
  },

  onClick: function(node) {
    if(!node) return;
    var nStyles = this.nodeStylesOnClick;
    if(!nStyles) return;
    //if the node is selected then unselect it
    if(node.selected) {
      this.toggleStylesOnClick(node, false);
      delete node.selected;
    } else {
      //unselect all selected nodes...
      this.viz.graph.eachNode(function(n) {
        if(n.selected) {
          for(var s in nStyles) {
            n.setData(s, n.styles['$' + s], 'end');
          }
          delete n.selected;
        }
      });
      //select clicked node
      this.toggleStylesOnClick(node, true);
      node.selected = true;
      delete node.hovered;
      this.hoveredNode = false;
    }
  },
  
  onMouseMove: function(e, win, event) {
    //if mouse button is down and moving set move=true
    if(this.down) this.move = true;
    //already handled by mouseover/out
    if(this.dom && this.isLabel(e, win)) return;
    var nStyles = this.nodeStylesOnHover;
    if(!nStyles) return;
    
    if(!this.dom) {
      if(this.hoveredNode) {
        var geom = this.types[this.hoveredNode.getData('type')];
        var contains = geom && geom.contains && geom.contains.call(this.fx, 
            this.hoveredNode, event.getPos());
        if(contains) return;
      }
      var node = event.getNode();
      //if no node is being hovered then just exit
      if(!this.hoveredNode && !node) return;
      //if the node is hovered then exit
      if(node.hovered) return;
      //select hovered node
      if(node && !node.selected) {
        //check if an animation is running and exit it
        this.fx.nodeFxAnimation.stopTimer();
        //unselect all hovered nodes...
        this.viz.graph.eachNode(function(n) {
          if(n.hovered && !n.selected) {
            for(var s in nStyles) {
              n.setData(s, n.styles['$' + s], 'end');
            }
            delete n.hovered;
          }
        });
        //select hovered node
        node.hovered = true;
        this.hoveredNode = node;
        this.toggleStylesOnHover(node, true);
      } else if(this.hoveredNode && !this.hoveredNode.selected) {
        //check if an animation is running and exit it
        this.fx.nodeFxAnimation.stopTimer();
        //unselect hovered node
        this.toggleStylesOnHover(this.hoveredNode, false);
        delete this.hoveredNode.hovered;
        this.hoveredNode = false;
      }
    }
  }
});

Extras.Classes.Navigation = new Class({
  Implements: [ExtrasInitializer, EventsInterface],
  
  initializePost: function() {
    this.pos = false;
    this.pressed = false;
  },
  
  onMouseWheel: function(e, win, scroll) {      
    if(!this.config.zooming) return;
    
    // START METAMAPS CODE
	  if (e.target.id != 'infovis-canvas') return;
    if (Mapmaker.Create.newTopic.beingCreated) return;
	  // END METAMAPS CODE
  
    //$.event.stop($.event.get(e, win));
    // END METAMAPS CODE
    // ORIGINAL CODE $.event.stop($.event.get(e, win));

    var val = this.config.zooming / 1000,
        ans = 1 + scroll * val;
        
    // START METAMAPS CODE
	  if (ans > 1) {
      if (5 >= this.canvas.scaleOffsetX) {
		    this.canvas.scale(ans, ans);
	    }
	  }
	  else if (ans < 1) {
      if (this.canvas.scaleOffsetX >= 0.2) {
		    this.canvas.scale(ans, ans);
	    }
	  }
    // END METAMAPS CODE
    // ORIGINAL CODE this.canvas.scale(ans, ans);

    // START METAMAPS CODE
      jQuery(document).trigger(Mapmaker.JIT.events.zoom, [e]);
    // END METAMAPS CODE
  },
  
  onMouseDown: function(e, win, eventInfo) {
    ///console.log('mouse down!!!!');
    if(!this.config.panning) return;
    
    //START METAMAPS CODE
    Mapmaker.Mouse.changeInX = 0;
    Mapmaker.Mouse.changeInY = 0;
    if((this.config.panning == 'avoid nodes' && eventInfo.getNode()) || eventInfo.getEdge()) return;
    // END METAMAPS CODE
    // ORIGINAl CODE if(this.config.panning == 'avoid nodes' && (this.dom? this.isLabel(e, win) : eventInfo.getNode())) return;
    
    this.pressed = true;
    
    //START METAMAPS CODE
    var rightClick = e.button == 2 || (navigator.platform.indexOf("Mac") != -1 && e.ctrlKey); 
    // TODO make sure this works across browsers  
    if (!Mapmaker.Mouse.boxStartCoordinates && ((e.button == 0 && e.shiftKey) || (e.button == 0 && e.ctrlKey)  || rightClick)) {
      Mapmaker.Mouse.boxStartCoordinates = eventInfo.getPos();
      //console.log('mouse down');
    }

    Mapmaker.Mouse.didPan = false;
    

    
    // END METAMAPS CODE
    
    this.pos = eventInfo.getPos();
    var canvas = this.canvas,
        ox = canvas.translateOffsetX,
        oy = canvas.translateOffsetY,
        sx = canvas.scaleOffsetX,
        sy = canvas.scaleOffsetY;
    this.pos.x *= sx;
    this.pos.x += ox;
    this.pos.y *= sy;
    this.pos.y += oy;
  },
  
  onMouseMove: function(e, win, eventInfo) {
    if(!this.config.panning) return;
    if(!this.pressed) return;
    if(this.config.panning == 'avoid nodes' && (this.dom? this.isLabel(e, win) : eventInfo.getNode())) return;
    
    // START METAMAPS CODE
    var rightClick = e.button == 2 || (navigator.platform.indexOf("Mac") != -1 && e.ctrlKey);
    if (!Mapmaker.Mouse.boxStartCoordinates && ((e.button == 0 && e.shiftKey) || (e.button == 0 && e.ctrlKey)  || rightClick)) {
      Mapmaker.Visualize.mGraph.busy = true;
      Mapmaker.boxStartCoordinates = eventInfo.getPos();
      //console.log('mouse move');
      return;
    }
    if (Mapmaker.Mouse.boxStartCoordinates && ((e.button == 0 && e.shiftKey) || (e.button == 0 && e.ctrlKey)  || rightClick)) {
      Mapmaker.Visualize.mGraph.busy = true;
      Mapmaker.JIT.drawSelectBox(eventInfo,e);
      //console.log('mouse move');
      return;
    }
    if (rightClick){
      return;
    }
    if (e.target.id != 'infovis-canvas') { 
      this.pressed = false;
      return;
    }
    Mapmaker.Mouse.didPan = true;
    // END METAMAPS CODE
    
    var thispos = this.pos, 
        currentPos = eventInfo.getPos(),
        canvas = this.canvas,
        ox = canvas.translateOffsetX,
        oy = canvas.translateOffsetY,
        sx = canvas.scaleOffsetX,
        sy = canvas.scaleOffsetY;
    currentPos.x *= sx;
    currentPos.y *= sy;
    currentPos.x += ox;
    currentPos.y += oy;
    var x = currentPos.x - thispos.x,
        y = currentPos.y - thispos.y;
    
    // START METAMAPS CODE
    Mapmaker.Mouse.changeInX = x;
    Mapmaker.Mouse.changeInY = y;
    // END METAMAPS CODE
    
    this.pos = currentPos;
    this.canvas.translate(x * 1/sx, y * 1/sy);

    // START METAMAPS CODE
      jQuery(document).trigger(Mapmaker.JIT.events.pan);
    // END METAMAPS CODE
  },
  
  onMouseUp: function(e, win, eventInfo, isRightClick) {
    if(!this.config.panning) return;
    this.pressed = false;
    
    // START METAMAPS CODE
    if (Mapmaker.Mouse.didPan) Mapmaker.JIT.SmoothPanning();
    
    
    // END METAMAPS CODE
    
  }
});


/*
 * File: Canvas.js
 *
 */

/*
 Class: Canvas
 
 	A canvas widget used by all visualizations. The canvas object can be accessed by doing *viz.canvas*. If you want to 
 	know more about <Canvas> options take a look at <Options.Canvas>.
 
 A canvas widget is a set of DOM elements that wrap the native canvas DOM Element providing a consistent API and behavior 
 across all browsers. It can also include Elements to add DOM (SVG or HTML) label support to all visualizations.
 
 Example:
 
 Suppose we have this HTML
 
 (start code xml)
 	<div id="infovis"></div>
 (end code)
 
 Now we create a new Visualization
 
 (start code js)
 	var viz = new $jit.Viz({
 		//Where to inject the canvas. Any div container will do.
 		'injectInto':'infovis',
		 //width and height for canvas. 
		 //Default's to the container offsetWidth and Height.
		 'width': 900,
		 'height':500
	 });
 (end code)

 The generated HTML will look like this
 
 (start code xml)
 <div id="infovis">
 	<div id="infovis-canvaswidget" style="position:relative;">
 	<canvas id="infovis-canvas" width=900 height=500
 	style="position:absolute; top:0; left:0; width:900px; height:500px;" />
 	<div id="infovis-label"
 	style="overflow:visible; position:absolute; top:0; left:0; width:900px; height:0px">
 	</div>
 	</div>
 </div>
 (end code)
 
 As you can see, the generated HTML consists of a canvas DOM Element of id *infovis-canvas* and a div label container
 of id *infovis-label*, wrapped in a main div container of id *infovis-canvaswidget*.
 */

var Canvas;
(function() {
  //check for native canvas support
  var canvasType = typeof HTMLCanvasElement,
      supportsCanvas = (canvasType == 'object' || canvasType == 'function');
  //create element function
  function $E(tag, props) {
    var elem = document.createElement(tag);
    for(var p in props) {
      if(typeof props[p] == "object") {
        $.extend(elem[p], props[p]);
      } else {
        elem[p] = props[p];
      }
    }
    if (tag == "canvas" && !supportsCanvas && G_vmlCanvasManager) {
      elem = G_vmlCanvasManager.initElement(document.body.appendChild(elem));
    }
    return elem;
  }
  //canvas widget which we will call just Canvas
  $jit.Canvas = Canvas = new Class({
    canvases: [],
    pos: false,
    element: false,
    labelContainer: false,
    translateOffsetX: 0,
    translateOffsetY: 0,
    scaleOffsetX: 1,
    scaleOffsetY: 1,
    
    initialize: function(viz, opt) {
      this.viz = viz;
      this.opt = this.config = opt;
      var id = $.type(opt.injectInto) == 'string'? 
          opt.injectInto:opt.injectInto.id,
          type = opt.type,
          idLabel = id + "-label", 
          // ORIGINAL CODE wrapper = $(id),
          // START METAMAPS CODE
          //wrapper = Mapmaker.Famous.viz.surf,
          // END METAMAPS CODE
          width = opt.width, // || wrapper.offsetWidth,
          height = opt.height; // || wrapper.offsetHeight;
      this.id = id;
      //canvas options
      var canvasOptions = {
        injectInto: id,
        width: width,
        height: height
      };
      //create main wrapper
      this.element = $E('div', {
        'id': id + '-canvaswidget',
        'style': {
          'position': 'relative',
          'width': width + 'px',
          'height': height + 'px'
        }
      });
      //create label container
      this.labelContainer = this.createLabelContainer(opt.Label.type, 
          idLabel, canvasOptions);
      //create primary canvas
      this.canvases.push(new Canvas.Base[type]({
        config: $.extend({idSuffix: '-canvas'}, canvasOptions),
        plot: function(base) {
          viz.fx.plot();
        },
        resize: function() {
          viz.refresh();
        }
      }));
      //create secondary canvas
      var back = opt.background;
      if(back) {
        var backCanvas = new Canvas.Background[back.type](viz, $.extend(back, canvasOptions));
        this.canvases.push(new Canvas.Base[type](backCanvas));
      }
      //insert canvases
      var len = this.canvases.length;
      while(len--) {
        this.element.appendChild(this.canvases[len].canvas);
        if(len > 0) {
          this.canvases[len].plot();
        }
      }
      this.element.appendChild(this.labelContainer);

      // START METAMAPS CODE
      var m = Mapmaker.Famous.viz.surf;
      m.setContent(this.element);
      m.deploy(m._currTarget);

      // END METAMAPS CODE
      // ORIGINAL CODE wrapper.appendChild(this.element);


      //Update canvas position when the page is scrolled.
      var timer = null, that = this;
      $.addEvent(window, 'scroll', function() {
        clearTimeout(timer);
        timer = setTimeout(function() {
          that.getPos(true); //update canvas position
        }, 500);
      });
    },
    /*
      Method: getCtx
      
      Returns the main canvas context object
      
      Example:
      
      (start code js)
       var ctx = canvas.getCtx();
       //Now I can use the native canvas context
       //and for example change some canvas styles
       ctx.globalAlpha = 1;
      (end code)
    */
    getCtx: function(i) {
      return this.canvases[i || 0].getCtx();
    },
    /*
      Method: getConfig
      
      Returns the current Configuration for this Canvas Widget.
      
      Example:
      
      (start code js)
       var config = canvas.getConfig();
      (end code)
    */
    getConfig: function() {
      return this.opt;
    },
    /*
      Method: getElement

      Returns the main Canvas DOM wrapper
      
      Example:
      
      (start code js)
       var wrapper = canvas.getElement();
       //Returns <div id="infovis-canvaswidget" ... >...</div> as element
      (end code)
    */
    getElement: function() {
      return this.element;
    },
    /*
      Method: getSize
      
      Returns canvas dimensions.
      
      Returns:
      
      An object with *width* and *height* properties.
      
      Example:
      (start code js)
      canvas.getSize(); //returns { width: 900, height: 500 }
      (end code)
    */
    getSize: function(i) {
      return this.canvases[i || 0].getSize();
    },
    /*
      Method: resize
      
      Resizes the canvas.
      
      Parameters:
      
      width - New canvas width.
      height - New canvas height.
      
      Example:
      
      (start code js)
       canvas.resize(width, height);
      (end code)
    
    */
    resize: function(width, height) {
      this.getPos(true);
      this.translateOffsetX = this.translateOffsetY = 0;
      this.scaleOffsetX = this.scaleOffsetY = 1;

      for(var i=0, l=this.canvases.length; i<l; i++) {
        this.canvases[i].resize(width, height);
      }
      var style = this.element.style;
      style.width = width + 'px';
      style.height = height + 'px';
      if(this.labelContainer)
        this.labelContainer.style.width = width + 'px';
    },
    /*
      Method: translate
      
      Applies a translation to the canvas.
      
      Parameters:
      
      x - (number) x offset.
      y - (number) y offset.
      disablePlot - (boolean) Default's *false*. Set this to *true* if you don't want to refresh the visualization.
      
      Example:
      
      (start code js)
       canvas.translate(30, 30);
      (end code)
    
    */
    translate: function(x, y, disablePlot) {
      this.translateOffsetX += x*this.scaleOffsetX;
      this.translateOffsetY += y*this.scaleOffsetY;
      for(var i=0, l=this.canvases.length; i<l; i++) {
        this.canvases[i].translate(x, y, disablePlot);
      }
    },
    /*
      Method: scale
      
      Scales the canvas.
      
      Parameters:
      
      x - (number) scale value.
      y - (number) scale value.
      disablePlot - (boolean) Default's *false*. Set this to *true* if you don't want to refresh the visualization.
      
      Example:
      
      (start code js)
       canvas.scale(0.5, 0.5);
      (end code)
    
    */
    scale: function(x, y, disablePlot) {
      var px = this.scaleOffsetX * x,
          py = this.scaleOffsetY * y;
      var dx = this.translateOffsetX * (x -1) / px,
          dy = this.translateOffsetY * (y -1) / py;
      this.scaleOffsetX = px;
      this.scaleOffsetY = py;
      for(var i=0, l=this.canvases.length; i<l; i++) {
        this.canvases[i].scale(x, y, true);
      }
      this.translate(dx, dy, false);
    },
    /*
      Method: getPos
      
      Returns the canvas position as an *x, y* object.
      
      Parameters:
      
      force - (boolean) Default's *false*. Set this to *true* if you want to recalculate the position without using any cache information.
      
      Returns:
      
      An object with *x* and *y* properties.
      
      Example:
      (start code js)
      canvas.getPos(true); //returns { x: 900, y: 500 }
      (end code)
    */
    getPos: function(force){
      if(force || !this.pos) {
        return this.pos = $.getPos(this.getElement());
      }
      return this.pos;
    },
    /*
       Method: clear
       
       Clears the canvas.
    */
    clear: function(i){
      this.canvases[i||0].clear();
    },
    
    path: function(type, action){
      var ctx = this.canvases[0].getCtx();
      ctx.beginPath();
      action(ctx);
      ctx[type]();
      ctx.closePath();
    },
    
    createLabelContainer: function(type, idLabel, dim) {
      var NS = 'http://www.w3.org/2000/svg';
      if(type == 'HTML' || type == 'Native') {
        return $E('div', {
          'id': idLabel,
          'style': {
            'overflow': 'visible',
            'position': 'absolute',
            'top': 0,
            'left': 0,
            'width': dim.width + 'px',
            'height': 0
          }
        });
      } else if(type == 'SVG') {
        var svgContainer = document.createElementNS(NS, 'svg:svg');
        svgContainer.setAttribute("width", dim.width);
        svgContainer.setAttribute('height', dim.height);
        var style = svgContainer.style;
        style.position = 'absolute';
        style.left = style.top = '0px';
        var labelContainer = document.createElementNS(NS, 'svg:g');
        labelContainer.setAttribute('width', dim.width);
        labelContainer.setAttribute('height', dim.height);
        labelContainer.setAttribute('x', 0);
        labelContainer.setAttribute('y', 0);
        labelContainer.setAttribute('id', idLabel);
        svgContainer.appendChild(labelContainer);
        return svgContainer;
      }
    }
  });
  //base canvas wrapper
  Canvas.Base = {};
  Canvas.Base['2D'] = new Class({
    translateOffsetX: 0,
    translateOffsetY: 0,
    scaleOffsetX: 1,
    scaleOffsetY: 1,

    initialize: function(viz) {
      this.viz = viz;
      this.opt = viz.config;
      this.size = false;
      this.createCanvas();
      this.translateToCenter();
    },
    createCanvas: function() {
      var opt = this.opt,
          width = opt.width,
          height = opt.height;
      this.canvas = $E('canvas', {
        'id': opt.injectInto + opt.idSuffix,
        'width': width,
        'height': height,
        'style': {
          'position': 'absolute',
          'top': 0,
          'left': 0,
          'width': width + 'px',
          'height': height + 'px'
        }
      });
    },
    getCtx: function() {
      if(!this.ctx) 
        return this.ctx = this.canvas.getContext('2d');
      return this.ctx;
    },
    getSize: function() {
      if(this.size) return this.size;
      var canvas = this.canvas;
      return this.size = {
        width: canvas.width,
        height: canvas.height
      };
    },
    translateToCenter: function(ps) {
      var size = this.getSize(),
          width = ps? (size.width - ps.width - this.translateOffsetX*2) : size.width;
          height = ps? (size.height - ps.height - this.translateOffsetY*2) : size.height;
      var ctx = this.getCtx();
      ps && ctx.scale(1/this.scaleOffsetX, 1/this.scaleOffsetY);
      ctx.translate(width/2, height/2);
    },
    resize: function(width, height) {
      var size = this.getSize(),
          canvas = this.canvas,
          styles = canvas.style;
      this.size = false;
      canvas.width = width;
      canvas.height = height;
      styles.width = width + "px";
      styles.height = height + "px";

      //small ExCanvas fix
      if(!supportsCanvas) {
        this.translateToCenter(size);
      } else {
        this.translateToCenter();
      }
      this.translateOffsetX =
        this.translateOffsetY = 0;
      this.scaleOffsetX = 
        this.scaleOffsetY = 1;

      this.clear();
      this.viz.resize(width, height, this);
    },
    translate: function(x, y, disablePlot) {
      var sx = this.scaleOffsetX,
          sy = this.scaleOffsetY;
      this.translateOffsetX += x*sx;
      this.translateOffsetY += y*sy;
      this.getCtx().translate(x, y);
      !disablePlot && this.plot();
    },
    scale: function(x, y, disablePlot) {
      this.scaleOffsetX *= x;
      this.scaleOffsetY *= y;
      this.getCtx().scale(x, y);
      !disablePlot && this.plot();
    },
    clear: function(){
      var size = this.getSize(),
          ox = this.translateOffsetX,
          oy = this.translateOffsetY,
          sx = this.scaleOffsetX,
          sy = this.scaleOffsetY;
      this.getCtx().clearRect((-size.width / 2 - ox) * 1/sx, 
                              (-size.height / 2 - oy) * 1/sy, 
                              size.width * 1/sx, size.height * 1/sy);
    },
    plot: function() {
      this.clear();
      this.viz.plot(this);
    }
  });
  //background canvases
  //TODO(nico): document this!
  Canvas.Background = {};
  Canvas.Background.Circles = new Class({
    initialize: function(viz, options) {
      this.viz = viz;
      this.config = $.merge({
        idSuffix: '-bkcanvas',
        levelDistance: 100,
        numberOfCircles: 6,
        CanvasStyles: {},
        offset: 0
      }, options);
    },
    resize: function(width, height, base) {
      this.plot(base);
    },
    plot: function(base) {
      var canvas = base.canvas,
          ctx = base.getCtx(),
          conf = this.config,
          styles = conf.CanvasStyles;
      //set canvas styles
      for(var s in styles) ctx[s] = styles[s];
      var n = conf.numberOfCircles,
          rho = conf.levelDistance;
      for(var i=1; i<=n; i++) {
        ctx.beginPath();
        ctx.arc(0, 0, rho * i, 0, 2 * Math.PI, false);
        ctx.stroke();
        ctx.closePath();
      }
      //TODO(nico): print labels too!
    }
  });
  
  // START METAMAPS CODE
  Canvas.Background.Mapmaker = new Class({
    initialize: function(viz, options) {
      this.viz = viz;
      this.config = options;
    },
    resize: function(width, height, base) {
      this.plot(base);
    },
    plot: function(base) {
      var canvas = base.canvas,
          ctx = base.getCtx(),
          scale = base.scaleOffsetX;
      //var pattern = new Image();
      //pattern.src = "/assets/cubes.png";
      //var ptrn = ctx.createPattern(pattern, 'repeat');
      //ctx.fillStyle = ptrn;
      ctx.fillStyle = Mapmaker.Settings.colors.background;
      var xPoint = (-(canvas.width/scale)/2) - (base.translateOffsetX/scale),
        yPoint = (-(canvas.height/scale)/2) - (base.translateOffsetY/scale);
      //ctx.fillRect(xPoint,yPoint,canvas.width/scale,canvas.height/scale);
    }
  });
  // END METAMAPS CODE
})();


/*
 * File: Polar.js
 * 
 * Defines the <Polar> class.
 *
 * Description:
 *
 * The <Polar> class, just like the <Complex> class, is used by the <Hypertree>, <ST> and <RGraph> as a 2D point representation.
 *
 * See also:
 *
 * <http://en.wikipedia.org/wiki/Polar_coordinates>
 *
*/

/*
   Class: Polar

   A multi purpose polar representation.

   Description:
 
   The <Polar> class, just like the <Complex> class, is used by the <Hypertree>, <ST> and <RGraph> as a 2D point representation.
 
   See also:
 
   <http://en.wikipedia.org/wiki/Polar_coordinates>
 
   Parameters:

      theta - An angle.
      rho - The norm.
*/

var Polar = function(theta, rho) {
  this.theta = theta || 0;
  this.rho = rho || 0;
};

$jit.Polar = Polar;

Polar.prototype = {
    /*
       Method: getc
    
       Returns a complex number.
    
       Parameters:

       simple - _optional_ If *true*, this method will return only an object holding x and y properties and not a <Complex> instance. Default's *false*.

      Returns:
    
          A complex number.
    */
    getc: function(simple) {
        return this.toComplex(simple);
    },

    /*
       Method: getp
    
       Returns a <Polar> representation.
    
       Returns:
    
          A variable in polar coordinates.
    */
    getp: function() {
        return this;
    },


    /*
       Method: set
    
       Sets a number.

       Parameters:

       v - A <Complex> or <Polar> instance.
    
    */
    set: function(v) {
        v = v.getp();
        this.theta = v.theta; this.rho = v.rho;
    },

    /*
       Method: setc
    
       Sets a <Complex> number.

       Parameters:

       x - A <Complex> number real part.
       y - A <Complex> number imaginary part.
    
    */
    setc: function(x, y) {
        this.rho = Math.sqrt(x * x + y * y);
        this.theta = Math.atan2(y, x);
        if(this.theta < 0) this.theta += Math.PI * 2;
    },

    /*
       Method: setp
    
       Sets a polar number.

       Parameters:

       theta - A <Polar> number angle property.
       rho - A <Polar> number rho property.
    
    */
    setp: function(theta, rho) {
        this.theta = theta; 
        this.rho = rho;
    },

    /*
       Method: clone
    
       Returns a copy of the current object.
    
       Returns:
    
          A copy of the real object.
    */
    clone: function() {
        return new Polar(this.theta, this.rho);
    },

    /*
       Method: toComplex
    
        Translates from polar to cartesian coordinates and returns a new <Complex> instance.
    
        Parameters:

        simple - _optional_ If *true* this method will only return an object with x and y properties (and not the whole <Complex> instance). Default's *false*.
 
        Returns:
    
          A new <Complex> instance.
    */
    toComplex: function(simple) {
        var x = Math.cos(this.theta) * this.rho;
        var y = Math.sin(this.theta) * this.rho;
        if(simple) return { 'x': x, 'y': y};
        return new Complex(x, y);
    },

    /*
       Method: add
    
        Adds two <Polar> instances.
    
       Parameters:

       polar - A <Polar> number.

       Returns:
    
          A new Polar instance.
    */
    add: function(polar) {
        return new Polar(this.theta + polar.theta, this.rho + polar.rho);
    },
    
    /*
       Method: scale
    
        Scales a polar norm.
    
        Parameters:

        number - A scale factor.
        
        Returns:
    
          A new Polar instance.
    */
    scale: function(number) {
        return new Polar(this.theta, this.rho * number);
    },
    
    /*
       Method: equals
    
       Comparison method.

       Returns *true* if the theta and rho properties are equal.

       Parameters:

       c - A <Polar> number.

       Returns:

       *true* if the theta and rho parameters for these objects are equal. *false* otherwise.
    */
    equals: function(c) {
        return this.theta == c.theta && this.rho == c.rho;
    },
    
    /*
       Method: $add
    
        Adds two <Polar> instances affecting the current object.
    
       Paramters:

       polar - A <Polar> instance.

       Returns:
    
          The changed object.
    */
    $add: function(polar) {
        this.theta = this.theta + polar.theta; this.rho += polar.rho;
        return this;
    },

    /*
       Method: $madd
    
        Adds two <Polar> instances affecting the current object. The resulting theta angle is modulo 2pi.
    
       Parameters:

       polar - A <Polar> instance.

       Returns:
    
          The changed object.
    */
    $madd: function(polar) {
        this.theta = (this.theta + polar.theta) % (Math.PI * 2); this.rho += polar.rho;
        return this;
    },

    
    /*
       Method: $scale
    
        Scales a polar instance affecting the object.
    
      Parameters:

      number - A scaling factor.

      Returns:
    
          The changed object.
    */
    $scale: function(number) {
        this.rho *= number;
        return this;
    },
    
    /*
      Method: isZero
   
      Returns *true* if the number is zero.
   
   */
    isZero: function () {
      var almostZero = 0.0001, abs = Math.abs;
      return abs(this.theta) < almostZero && abs(this.rho) < almostZero;
    },

    /*
       Method: interpolate
    
        Calculates a polar interpolation between two points at a given delta moment.

        Parameters:
      
        elem - A <Polar> instance.
        delta - A delta factor ranging [0, 1].
    
       Returns:
    
          A new <Polar> instance representing an interpolation between _this_ and _elem_
    */
    interpolate: function(elem, delta) {
        var pi = Math.PI, pi2 = pi * 2;
        var ch = function(t) {
            var a =  (t < 0)? (t % pi2) + pi2 : t % pi2;
            return a;
        };
        var tt = this.theta, et = elem.theta;
        var sum, diff = Math.abs(tt - et);
        if(diff == pi) {
          if(tt > et) {
            sum = ch((et + ((tt - pi2) - et) * delta)) ;
          } else {
            sum = ch((et - pi2 + (tt - (et)) * delta));
          }
        } else if(diff >= pi) {
          if(tt > et) {
            sum = ch((et + ((tt - pi2) - et) * delta)) ;
          } else {
            sum = ch((et - pi2 + (tt - (et - pi2)) * delta));
          }
        } else {  
          sum = ch((et + (tt - et) * delta)) ;
        }
        var r = (this.rho - elem.rho) * delta + elem.rho;
        return {
          'theta': sum,
          'rho': r
        };
    }
};


var $P = function(a, b) { return new Polar(a, b); };

Polar.KER = $P(0, 0);



/*
 * File: Complex.js
 * 
 * Defines the <Complex> class.
 *
 * Description:
 *
 * The <Complex> class, just like the <Polar> class, is used by the <Hypertree>, <ST> and <RGraph> as a 2D point representation.
 *
 * See also:
 *
 * <http://en.wikipedia.org/wiki/Complex_number>
 *
*/

/*
   Class: Complex
    
   A multi-purpose Complex Class with common methods.
 
   Description:
 
   The <Complex> class, just like the <Polar> class, is used by the <Hypertree>, <ST> and <RGraph> as a 2D point representation.
 
   See also:
 
   <http://en.wikipedia.org/wiki/Complex_number>

   Parameters:

   x - _optional_ A Complex number real part.
   y - _optional_ A Complex number imaginary part.
 
*/

var Complex = function(x, y) {
  this.x = x || 0;
  this.y = y || 0;
};

$jit.Complex = Complex;

Complex.prototype = {
    /*
       Method: getc
    
       Returns a complex number.
    
       Returns:
    
          A complex number.
    */
    getc: function() {
        return this;
    },

    /*
       Method: getp
    
       Returns a <Polar> representation of this number.
    
       Parameters:

       simple - _optional_ If *true*, this method will return only an object holding theta and rho properties and not a <Polar> instance. Default's *false*.

       Returns:
    
          A variable in <Polar> coordinates.
    */
    getp: function(simple) {
        return this.toPolar(simple);
    },


    /*
       Method: set
    
       Sets a number.

       Parameters:

       c - A <Complex> or <Polar> instance.
    
    */
    set: function(c) {
      c = c.getc(true);
      this.x = c.x; 
      this.y = c.y;
    },

    /*
       Method: setc
    
       Sets a complex number.

       Parameters:

       x - A <Complex> number Real part.
       y - A <Complex> number Imaginary part.
    
    */
    setc: function(x, y) {
        this.x = x; 
        this.y = y;
    },

    /*
       Method: setp
    
       Sets a polar number.

       Parameters:

       theta - A <Polar> number theta property.
       rho - A <Polar> number rho property.
    
    */
    setp: function(theta, rho) {
        this.x = Math.cos(theta) * rho;
        this.y = Math.sin(theta) * rho;
    },

    /*
       Method: clone
    
       Returns a copy of the current object.
    
       Returns:
    
          A copy of the real object.
    */
    clone: function() {
        return new Complex(this.x, this.y);
    },

    /*
       Method: toPolar
    
       Transforms cartesian to polar coordinates.
    
       Parameters:

       simple - _optional_ If *true* this method will only return an object with theta and rho properties (and not the whole <Polar> instance). Default's *false*.
       
       Returns:
    
          A new <Polar> instance.
    */
    
    toPolar: function(simple) {
        var rho = this.norm();
        var atan = Math.atan2(this.y, this.x);
        if(atan < 0) atan += Math.PI * 2;
        if(simple) return { 'theta': atan, 'rho': rho };
        return new Polar(atan, rho);
    },
    /*
       Method: norm
    
       Calculates a <Complex> number norm.
    
       Returns:
    
          A real number representing the complex norm.
    */
    norm: function () {
        return Math.sqrt(this.squaredNorm());
    },
    
    /*
       Method: squaredNorm
    
       Calculates a <Complex> number squared norm.
    
       Returns:
    
          A real number representing the complex squared norm.
    */
    squaredNorm: function () {
        return this.x*this.x + this.y*this.y;
    },

    /*
       Method: add
    
       Returns the result of adding two complex numbers.
       
       Does not alter the original object.

       Parameters:
    
          pos - A <Complex> instance.
    
       Returns:
    
         The result of adding two complex numbers.
    */
    add: function(pos) {
        return new Complex(this.x + pos.x, this.y + pos.y);
    },

    /*
       Method: prod
    
       Returns the result of multiplying two <Complex> numbers.
       
       Does not alter the original object.

       Parameters:
    
          pos - A <Complex> instance.
    
       Returns:
    
         The result of multiplying two complex numbers.
    */
    prod: function(pos) {
        return new Complex(this.x*pos.x - this.y*pos.y, this.y*pos.x + this.x*pos.y);
    },

    /*
       Method: conjugate
    
       Returns the conjugate of this <Complex> number.

       Does not alter the original object.

       Returns:
    
         The conjugate of this <Complex> number.
    */
    conjugate: function() {
        return new Complex(this.x, -this.y);
    },


    /*
       Method: scale
    
       Returns the result of scaling a <Complex> instance.
       
       Does not alter the original object.

       Parameters:
    
          factor - A scale factor.
    
       Returns:
    
         The result of scaling this complex to a factor.
    */
    scale: function(factor) {
        return new Complex(this.x * factor, this.y * factor);
    },

    /*
       Method: equals
    
       Comparison method.

       Returns *true* if both real and imaginary parts are equal.

       Parameters:

       c - A <Complex> instance.

       Returns:

       A boolean instance indicating if both <Complex> numbers are equal.
    */
    equals: function(c) {
        return this.x == c.x && this.y == c.y;
    },

    /*
       Method: $add
    
       Returns the result of adding two <Complex> numbers.
       
       Alters the original object.

       Parameters:
    
          pos - A <Complex> instance.
    
       Returns:
    
         The result of adding two complex numbers.
    */
    $add: function(pos) {
        this.x += pos.x; this.y += pos.y;
        return this;    
    },
    
    /*
       Method: $prod
    
       Returns the result of multiplying two <Complex> numbers.
       
       Alters the original object.

       Parameters:
    
          pos - A <Complex> instance.
    
       Returns:
    
         The result of multiplying two complex numbers.
    */
    $prod:function(pos) {
        var x = this.x, y = this.y;
        this.x = x*pos.x - y*pos.y;
        this.y = y*pos.x + x*pos.y;
        return this;
    },
    
    /*
       Method: $conjugate
    
       Returns the conjugate for this <Complex>.
       
       Alters the original object.

       Returns:
    
         The conjugate for this complex.
    */
    $conjugate: function() {
        this.y = -this.y;
        return this;
    },
    
    /*
       Method: $scale
    
       Returns the result of scaling a <Complex> instance.
       
       Alters the original object.

       Parameters:
    
          factor - A scale factor.
    
       Returns:
    
         The result of scaling this complex to a factor.
    */
    $scale: function(factor) {
        this.x *= factor; this.y *= factor;
        return this;
    },
    
    /*
       Method: $div
    
       Returns the division of two <Complex> numbers.
       
       Alters the original object.

       Parameters:
    
          pos - A <Complex> number.
    
       Returns:
    
         The result of scaling this complex to a factor.
    */
    $div: function(pos) {
        var x = this.x, y = this.y;
        var sq = pos.squaredNorm();
        this.x = x * pos.x + y * pos.y; this.y = y * pos.x - x * pos.y;
        return this.$scale(1 / sq);
    },

    /*
      Method: isZero
   
      Returns *true* if the number is zero.
   
   */
    isZero: function () {
      var almostZero = 0.0001, abs = Math.abs;
      return abs(this.x) < almostZero && abs(this.y) < almostZero;
    }
};

var $C = function(a, b) { return new Complex(a, b); };

Complex.KER = $C(0, 0);



/*
 * File: Graph.js
 *
*/

/*
 Class: Graph

 A Graph Class that provides useful manipulation functions. You can find more manipulation methods in the <Graph.Util> object.

 An instance of this class can be accessed by using the *graph* parameter of any tree or graph visualization.
 
 Example:

 (start code js)
   //create new visualization
   var viz = new $jit.Viz(options);
   //load JSON data
   viz.loadJSON(json);
   //access model
   viz.graph; //<Graph> instance
 (end code)
 
 Implements:
 
 The following <Graph.Util> methods are implemented in <Graph>
 
  - <Graph.Util.getNode>
  - <Graph.Util.eachNode>
  - <Graph.Util.computeLevels>
  - <Graph.Util.eachBFS>
  - <Graph.Util.clean>
  - <Graph.Util.getClosestNodeToPos>
  - <Graph.Util.getClosestNodeToOrigin>
 
*/  

$jit.Graph = new Class({

  initialize: function(opt, Node, Edge, Label) {
    var innerOptions = {
    'klass': Complex,
    'Node': {}
    };
    this.Node = Node;
    this.Edge = Edge;
    this.Label = Label;
    this.opt = $.merge(innerOptions, opt || {});
    this.nodes = {};
    this.edges = {};
    
    //add nodeList methods
    var that = this;
    this.nodeList = {};
    for(var p in Accessors) {
      that.nodeList[p] = (function(p) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          that.eachNode(function(n) {
            n[p].apply(n, args);
          });
        };
      })(p);
    }

 },

/*
     Method: getNode
    
     Returns a <Graph.Node> by *id*.

     Parameters:

     id - (string) A <Graph.Node> id.

     Example:

     (start code js)
       var node = graph.getNode('nodeId');
     (end code)
*/  
 getNode: function(id) {
    if(this.hasNode(id)) return this.nodes[id];
    return false;
 },

 /*
     Method: get
    
     An alias for <Graph.Util.getNode>. Returns a node by *id*.
    
     Parameters:
    
     id - (string) A <Graph.Node> id.
    
     Example:
    
     (start code js)
       var node = graph.get('nodeId');
     (end code)
*/  
  get: function(id) {
    return this.getNode(id);
  },

 /*
   Method: getByName
  
   Returns a <Graph.Node> by *name*.
  
   Parameters:
  
   name - (string) A <Graph.Node> name.
  
   Example:
  
   (start code js)
     var node = graph.getByName('someName');
   (end code)
  */  
  getByName: function(name) {
    for(var id in this.nodes) {
      var n = this.nodes[id];
      if(n.name == name) return n;
    }
    return false;
  },

/*
   Method: getAdjacence
  
   Returns a <Graph.Adjacence> object connecting nodes with ids *id* and *id2*.

   Parameters:

   id - (string) A <Graph.Node> id.
   id2 - (string) A <Graph.Node> id.
*/  
  getAdjacence: function (id, id2) {
    if(id in this.edges) {
      return this.edges[id][id2];
    }
    return false;
 },

    /*
     Method: addNode
    
     Adds a node.
     
     Parameters:
    
      obj - An object with the properties described below

      id - (string) A node id
      name - (string) A node's name
      data - (object) A node's data hash

    See also:
    <Graph.Node>

  */  
  addNode: function(obj) { 
   if(!this.nodes[obj.id]) {  
     var edges = this.edges[obj.id] = {};
     this.nodes[obj.id] = new Graph.Node($.extend({
        'id': obj.id,
        'name': obj.name,
        'data': $.merge(obj.data || {}, {}),
        'adjacencies': edges 
      }, this.opt.Node), 
      this.opt.klass, 
      this.Node, 
      this.Edge,
      this.Label);
    }
    return this.nodes[obj.id];
  },
  
    /*
     Method: addAdjacence
    
     Connects nodes specified by *obj* and *obj2*. If not found, nodes are created.
     
     Parameters:
    
      obj - (object) A <Graph.Node> object.
      obj2 - (object) Another <Graph.Node> object.
      data - (object) A data object. Used to store some extra information in the <Graph.Adjacence> object created.

    See also:

    <Graph.Node>, <Graph.Adjacence>
    */  
  addAdjacence: function (obj, obj2, data) {
    if(!this.hasNode(obj.id)) { this.addNode(obj); }
    if(!this.hasNode(obj2.id)) { this.addNode(obj2); }
    obj = this.nodes[obj.id]; obj2 = this.nodes[obj2.id];
    if(!obj.adjacentTo(obj2)) {
      var adjsObj = this.edges[obj.id] = this.edges[obj.id] || {};
      var adjsObj2 = this.edges[obj2.id] = this.edges[obj2.id] || {};
      adjsObj[obj2.id] = adjsObj2[obj.id] = new Graph.Adjacence(obj, obj2, data, this.Edge, this.Label);
      return adjsObj[obj2.id];
    }
    return this.edges[obj.id][obj2.id];
 },

    /*
     Method: removeNode
    
     Removes a <Graph.Node> matching the specified *id*.

     Parameters:

     id - (string) A node's id.

    */  
  removeNode: function(id) {
    if(this.hasNode(id)) {
      delete this.nodes[id];
      var adjs = this.edges[id];
      for(var to in adjs) {
        delete this.edges[to][id];
      }
      delete this.edges[id];
    }
  },
  
/*
     Method: removeAdjacence
    
     Removes a <Graph.Adjacence> matching *id1* and *id2*.

     Parameters:

     id1 - (string) A <Graph.Node> id.
     id2 - (string) A <Graph.Node> id.
*/  
  removeAdjacence: function(id1, id2) {
    delete this.edges[id1][id2];
    delete this.edges[id2][id1];
  },

   /*
     Method: hasNode
    
     Returns a boolean indicating if the node belongs to the <Graph> or not.
     
     Parameters:
    
        id - (string) Node id.
   */  
  hasNode: function(id) {
    return id in this.nodes;
  },
  
  /*
    Method: empty

    Empties the Graph

  */
  empty: function() { this.nodes = {}; this.edges = {};}

});

var Graph = $jit.Graph;

/*
 Object: Accessors
 
 Defines a set of methods for data, canvas and label styles manipulation implemented by <Graph.Node> and <Graph.Adjacence> instances.
 
 */
var Accessors;

(function () {
  var getDataInternal = function(prefix, prop, type, force, prefixConfig) {
    var data;
    type = type || 'current';
    prefix = "$" + (prefix ? prefix + "-" : "");

    if(type == 'current') {
      data = this.data;
    } else if(type == 'start') {
      data = this.startData;
    } else if(type == 'end') {
      data = this.endData;
    }

    var dollar = prefix + prop;

    if(force) {
      return data[dollar];
    }

    if(!this.Config.overridable)
      return prefixConfig[prop] || 0;

    return (dollar in data) ?
      data[dollar] : ((dollar in this.data) ? this.data[dollar] : (prefixConfig[prop] || 0));
  }

  var setDataInternal = function(prefix, prop, value, type) {
    type = type || 'current';
    prefix = '$' + (prefix ? prefix + '-' : '');

    var data;

    if(type == 'current') {
      data = this.data;
    } else if(type == 'start') {
      data = this.startData;
    } else if(type == 'end') {
      data = this.endData;
    }

    data[prefix + prop] = value;
  }

  var removeDataInternal = function(prefix, properties) {
    prefix = '$' + (prefix ? prefix + '-' : '');
    var that = this;
    $.each(properties, function(prop) {
      var pref = prefix + prop;
      delete that.data[pref];
      delete that.endData[pref];
      delete that.startData[pref];
    });
  }

  Accessors = {
    /*
    Method: getData

    Returns the specified data value property.
    This is useful for querying special/reserved <Graph.Node> data properties
    (i.e dollar prefixed properties).

    Parameters:

      prop  - (string) The name of the property. The dollar sign is not needed. For
              example *getData(width)* will return *data.$width*.
      type  - (string) The type of the data property queried. Default's "current". You can access *start* and *end* 
              data properties also. These properties are used when making animations.
      force - (boolean) Whether to obtain the true value of the property (equivalent to
              *data.$prop*) or to check for *node.overridable = true* first.

    Returns:

      The value of the dollar prefixed property or the global Node/Edge property
      value if *overridable=false*

    Example:
    (start code js)
     node.getData('width'); //will return node.data.$width if Node.overridable=true;
    (end code)
    */
    getData: function(prop, type, force) {
      return getDataInternal.call(this, "", prop, type, force, this.Config);
    },


    /*
    Method: setData

    Sets the current data property with some specific value.
    This method is only useful for reserved (dollar prefixed) properties.

    Parameters:

      prop  - (string) The name of the property. The dollar sign is not necessary. For
              example *setData(width)* will set *data.$width*.
      value - (mixed) The value to store.
      type  - (string) The type of the data property to store. Default's "current" but
              can also be "start" or "end".

    Example:
    
    (start code js)
     node.setData('width', 30);
    (end code)
    
    If we were to make an animation of a node/edge width then we could do
    
    (start code js)
      var node = viz.getNode('nodeId');
      //set start and end values
      node.setData('width', 10, 'start');
      node.setData('width', 30, 'end');
      //will animate nodes width property
      viz.fx.animate({
        modes: ['node-property:width'],
        duration: 1000
      });
    (end code)
    */
    setData: function(prop, value, type) {
      setDataInternal.call(this, "", prop, value, type);
    },

    /*
    Method: setDataset

    Convenience method to set multiple data values at once.
    
    Parameters:
    
    types - (array|string) A set of 'current', 'end' or 'start' values.
    obj - (object) A hash containing the names and values of the properties to be altered.

    Example:
    (start code js)
      node.setDataset(['current', 'end'], {
        'width': [100, 5],
        'color': ['#fff', '#ccc']
      });
      //...or also
      node.setDataset('end', {
        'width': 5,
        'color': '#ccc'
      });
    (end code)
    
    See also: 
    
    <Accessors.setData>
    
    */
    setDataset: function(types, obj) {
      types = $.splat(types);
      for(var attr in obj) {
        for(var i=0, val = $.splat(obj[attr]), l=types.length; i<l; i++) {
          this.setData(attr, val[i], types[i]);
        }
      }
    },
    
    /*
    Method: removeData

    Remove data properties.

    Parameters:

    One or more property names as arguments. The dollar sign is not needed.

    Example:
    (start code js)
    node.removeData('width'); //now the default width value is returned
    (end code)
    */
    removeData: function() {
      removeDataInternal.call(this, "", Array.prototype.slice.call(arguments));
    },

    /*
    Method: getCanvasStyle

    Returns the specified canvas style data value property. This is useful for
    querying special/reserved <Graph.Node> canvas style data properties (i.e.
    dollar prefixed properties that match with $canvas-<name of canvas style>).

    Parameters:

      prop  - (string) The name of the property. The dollar sign is not needed. For
              example *getCanvasStyle(shadowBlur)* will return *data[$canvas-shadowBlur]*.
      type  - (string) The type of the data property queried. Default's *current*. You can access *start* and *end* 
              data properties also.
              
    Example:
    (start code js)
      node.getCanvasStyle('shadowBlur');
    (end code)
    
    See also:
    
    <Accessors.getData>
    */
    getCanvasStyle: function(prop, type, force) {
      return getDataInternal.call(
          this, 'canvas', prop, type, force, this.Config.CanvasStyles);
    },

    /*
    Method: setCanvasStyle

    Sets the canvas style data property with some specific value.
    This method is only useful for reserved (dollar prefixed) properties.
    
    Parameters:
    
    prop - (string) Name of the property. Can be any canvas property like 'shadowBlur', 'shadowColor', 'strokeStyle', etc.
    value - (mixed) The value to set to the property.
    type - (string) Default's *current*. Whether to set *start*, *current* or *end* type properties.
    
    Example:
    
    (start code js)
     node.setCanvasStyle('shadowBlur', 30);
    (end code)
    
    If we were to make an animation of a node/edge shadowBlur canvas style then we could do
    
    (start code js)
      var node = viz.getNode('nodeId');
      //set start and end values
      node.setCanvasStyle('shadowBlur', 10, 'start');
      node.setCanvasStyle('shadowBlur', 30, 'end');
      //will animate nodes canvas style property for nodes
      viz.fx.animate({
        modes: ['node-style:shadowBlur'],
        duration: 1000
      });
    (end code)
    
    See also:
    
    <Accessors.setData>.
    */
    setCanvasStyle: function(prop, value, type) {
      setDataInternal.call(this, 'canvas', prop, value, type);
    },

    /*
    Method: setCanvasStyles

    Convenience method to set multiple styles at once.

    Parameters:
    
    types - (array|string) A set of 'current', 'end' or 'start' values.
    obj - (object) A hash containing the names and values of the properties to be altered.

    See also:
    
    <Accessors.setDataset>.
    */
    setCanvasStyles: function(types, obj) {
      types = $.splat(types);
      for(var attr in obj) {
        for(var i=0, val = $.splat(obj[attr]), l=types.length; i<l; i++) {
          this.setCanvasStyle(attr, val[i], types[i]);
        }
      }
    },

    /*
    Method: removeCanvasStyle

    Remove canvas style properties from data.

    Parameters:
    
    A variable number of canvas style strings.

    See also:
    
    <Accessors.removeData>.
    */
    removeCanvasStyle: function() {
      removeDataInternal.call(this, 'canvas', Array.prototype.slice.call(arguments));
    },

    /*
    Method: getLabelData

    Returns the specified label data value property. This is useful for
    querying special/reserved <Graph.Node> label options (i.e.
    dollar prefixed properties that match with $label-<name of label style>).

    Parameters:

      prop  - (string) The name of the property. The dollar sign prefix is not needed. For
              example *getLabelData(size)* will return *data[$label-size]*.
      type  - (string) The type of the data property queried. Default's *current*. You can access *start* and *end* 
              data properties also.
              
    See also:
    
    <Accessors.getData>.
    */
    getLabelData: function(prop, type, force) {
      return getDataInternal.call(
          this, 'label', prop, type, force, this.Label);
    },

    /*
    Method: setLabelData

    Sets the current label data with some specific value.
    This method is only useful for reserved (dollar prefixed) properties.

    Parameters:
    
    prop - (string) Name of the property. Can be any canvas property like 'shadowBlur', 'shadowColor', 'strokeStyle', etc.
    value - (mixed) The value to set to the property.
    type - (string) Default's *current*. Whether to set *start*, *current* or *end* type properties.
    
    Example:
    
    (start code js)
     node.setLabelData('size', 30);
    (end code)
    
    If we were to make an animation of a node label size then we could do
    
    (start code js)
      var node = viz.getNode('nodeId');
      //set start and end values
      node.setLabelData('size', 10, 'start');
      node.setLabelData('size', 30, 'end');
      //will animate nodes label size
      viz.fx.animate({
        modes: ['label-property:size'],
        duration: 1000
      });
    (end code)
    
    See also:
    
    <Accessors.setData>.
    */
    setLabelData: function(prop, value, type) {
      setDataInternal.call(this, 'label', prop, value, type);
    },

    /*
    Method: setLabelDataset

    Convenience function to set multiple label data at once.

    Parameters:
    
    types - (array|string) A set of 'current', 'end' or 'start' values.
    obj - (object) A hash containing the names and values of the properties to be altered.

    See also:
    
    <Accessors.setDataset>.
    */
    setLabelDataset: function(types, obj) {
      types = $.splat(types);
      for(var attr in obj) {
        for(var i=0, val = $.splat(obj[attr]), l=types.length; i<l; i++) {
          this.setLabelData(attr, val[i], types[i]);
        }
      }
    },

    /*
    Method: removeLabelData

    Remove label properties from data.
    
    Parameters:
    
    A variable number of label property strings.

    See also:
    
    <Accessors.removeData>.
    */
    removeLabelData: function() {
      removeDataInternal.call(this, 'label', Array.prototype.slice.call(arguments));
    }
  };
})();

/*
     Class: Graph.Node

     A <Graph> node.
     
     Implements:
     
     <Accessors> methods.
     
     The following <Graph.Util> methods are implemented by <Graph.Node>
     
    - <Graph.Util.eachAdjacency>
    - <Graph.Util.eachLevel>
    - <Graph.Util.eachSubgraph>
    - <Graph.Util.eachSubnode>
    - <Graph.Util.anySubnode>
    - <Graph.Util.getSubnodes>
    - <Graph.Util.getParents>
    - <Graph.Util.isDescendantOf>     
*/
Graph.Node = new Class({
    
  initialize: function(opt, klass, Node, Edge, Label) {
    var innerOptions = {
      'id': '',
      'name': '',
      'data': {},
      'startData': {},
      'endData': {},
      'adjacencies': {},

      'selected': false,
      'drawn': false,
      'exist': false,

      'angleSpan': {
        'begin': 0,
        'end' : 0
      },

      'pos': new klass,
      'startPos': new klass,
      'endPos': new klass
    };
    
    $.extend(this, $.extend(innerOptions, opt));
    this.Config = this.Node = Node;
    this.Edge = Edge;
    this.Label = Label;
  },

    /*
       Method: adjacentTo
    
       Indicates if the node is adjacent to the node specified by id

       Parameters:
    
          id - (string) A node id.
    
       Example:
       (start code js)
        node.adjacentTo('nodeId') == true;
       (end code)
    */
    adjacentTo: function(node) {
        return node.id in this.adjacencies;
    },

    /*
       Method: getAdjacency
    
       Returns a <Graph.Adjacence> object connecting the current <Graph.Node> and the node having *id* as id.

       Parameters:
    
          id - (string) A node id.
    */  
    getAdjacency: function(id) {
        return this.adjacencies[id];
    },

    /*
      Method: getPos
   
      Returns the position of the node.
  
      Parameters:
   
         type - (string) Default's *current*. Possible values are "start", "end" or "current".
   
      Returns:
   
        A <Complex> or <Polar> instance.
  
      Example:
      (start code js)
       var pos = node.getPos('end');
      (end code)
   */
   getPos: function(type) {
       type = type || "current";
       if(type == "current") {
         return this.pos;
       } else if(type == "end") {
         return this.endPos;
       } else if(type == "start") {
         return this.startPos;
       }
   },
   /*
     Method: setPos
  
     Sets the node's position.
  
     Parameters:
  
        value - (object) A <Complex> or <Polar> instance.
        type - (string) Default's *current*. Possible values are "start", "end" or "current".
  
     Example:
     (start code js)
      node.setPos(new $jit.Complex(0, 0), 'end');
     (end code)
  */
  setPos: function(value, type) {
      type = type || "current";
      var pos;
      if(type == "current") {
        pos = this.pos;
      } else if(type == "end") {
        pos = this.endPos;
      } else if(type == "start") {
        pos = this.startPos;
      }
      pos.set(value);
  }
});

Graph.Node.implement(Accessors);

/*
     Class: Graph.Adjacence

     A <Graph> adjacence (or edge) connecting two <Graph.Nodes>.
     
     Implements:
     
     <Accessors> methods.

     See also:

     <Graph>, <Graph.Node>

     Properties:
     
      nodeFrom - A <Graph.Node> connected by this edge.
      nodeTo - Another  <Graph.Node> connected by this edge.
      data - Node data property containing a hash (i.e {}) with custom options.
*/
Graph.Adjacence = new Class({
  
  initialize: function(nodeFrom, nodeTo, data, Edge, Label) {
    this.nodeFrom = nodeFrom;
    this.nodeTo = nodeTo;
    this.data = data || {};
    this.startData = {};
    this.endData = {};
    this.Config = this.Edge = Edge;
    this.Label = Label;
  }
});

Graph.Adjacence.implement(Accessors);

/*
   Object: Graph.Util

   <Graph> traversal and processing utility object.
   
   Note:
   
   For your convenience some of these methods have also been appended to <Graph> and <Graph.Node> classes.
*/
Graph.Util = {
    /*
       filter
    
       For internal use only. Provides a filtering function based on flags.
    */
    filter: function(param) {
        if(!param || !($.type(param) == 'string')) return function() { return true; };
        var props = param.split(" ");
        return function(elem) {
            for(var i=0; i<props.length; i++) { 
              if(elem[props[i]]) { 
                return false; 
              }
            }
            return true;
        };
    },
    /*
       Method: getNode
    
       Returns a <Graph.Node> by *id*.
       
       Also implemented by:
       
       <Graph>

       Parameters:

       graph - (object) A <Graph> instance.
       id - (string) A <Graph.Node> id.

       Example:

       (start code js)
         $jit.Graph.Util.getNode(graph, 'nodeid');
         //or...
         graph.getNode('nodeid');
       (end code)
    */
    getNode: function(graph, id) {
        return graph.nodes[id];
    },
    
    /*
       Method: eachNode
    
       Iterates over <Graph> nodes performing an *action*.
       
       Also implemented by:
       
       <Graph>.

       Parameters:

       graph - (object) A <Graph> instance.
       action - (function) A callback function having a <Graph.Node> as first formal parameter.

       Example:
       (start code js)
         $jit.Graph.Util.eachNode(graph, function(node) {
          alert(node.name);
         });
         //or...
         graph.eachNode(function(node) {
           alert(node.name);
         });
       (end code)
    */
    eachNode: function(graph, action, flags) {
        var filter = this.filter(flags);
        for(var i in graph.nodes) {
          if(filter(graph.nodes[i])) action(graph.nodes[i]);
        } 
    },
    
    /*
      Method: each
   
      Iterates over <Graph> nodes performing an *action*. It's an alias for <Graph.Util.eachNode>.
      
      Also implemented by:
      
      <Graph>.
  
      Parameters:
  
      graph - (object) A <Graph> instance.
      action - (function) A callback function having a <Graph.Node> as first formal parameter.
  
      Example:
      (start code js)
        $jit.Graph.Util.each(graph, function(node) {
         alert(node.name);
        });
        //or...
        graph.each(function(node) {
          alert(node.name);
        });
      (end code)
   */
   each: function(graph, action, flags) {
      this.eachNode(graph, action, flags); 
   },

 /*
       Method: eachAdjacency
    
       Iterates over <Graph.Node> adjacencies applying the *action* function.
       
       Also implemented by:
       
       <Graph.Node>.

       Parameters:

       node - (object) A <Graph.Node>.
       action - (function) A callback function having <Graph.Adjacence> as first formal parameter.

       Example:
       (start code js)
         $jit.Graph.Util.eachAdjacency(node, function(adj) {
          alert(adj.nodeTo.name);
         });
         //or...
         node.eachAdjacency(function(adj) {
           alert(adj.nodeTo.name);
         });
       (end code)
    */
    eachAdjacency: function(node, action, flags) {
        var adj = node.adjacencies, filter = this.filter(flags);
        for(var id in adj) {
          var a = adj[id];
          if(filter(a)) {
            if(a.nodeFrom != node) {
              var tmp = a.nodeFrom;
              a.nodeFrom = a.nodeTo;
              a.nodeTo = tmp;
            }
            action(a, id);
          }
        }
    },

     /*
       Method: computeLevels
    
       Performs a BFS traversal setting the correct depth for each node.
        
       Also implemented by:
       
       <Graph>.
       
       Note:
       
       The depth of each node can then be accessed by 
       >node._depth

       Parameters:

       graph - (object) A <Graph>.
       id - (string) A starting node id for the BFS traversal.
       startDepth - (optional|number) A minimum depth value. Default's 0.

    */
    computeLevels: function(graph, id, startDepth, flags) {
        startDepth = startDepth || 0;
        var filter = this.filter(flags);
        this.eachNode(graph, function(elem) {
            elem._flag = false;
            elem._depth = -1;
        }, flags);
        var root = graph.getNode(id);
        root._depth = startDepth;
        var queue = [root];
        while(queue.length != 0) {
            var node = queue.pop();
            node._flag = true;
            this.eachAdjacency(node, function(adj) {
                var n = adj.nodeTo;
                if(n._flag == false && filter(n)) {
                    if(n._depth < 0) n._depth = node._depth + 1 + startDepth;
                    queue.unshift(n);
                }
            }, flags);
        }
    },

    /*
       Method: eachBFS
    
       Performs a BFS traversal applying *action* to each <Graph.Node>.
       
       Also implemented by:
       
       <Graph>.

       Parameters:

       graph - (object) A <Graph>.
       id - (string) A starting node id for the BFS traversal.
       action - (function) A callback function having a <Graph.Node> as first formal parameter.

       Example:
       (start code js)
         $jit.Graph.Util.eachBFS(graph, 'mynodeid', function(node) {
          alert(node.name);
         });
         //or...
         graph.eachBFS('mynodeid', function(node) {
           alert(node.name);
         });
       (end code)
    */
    eachBFS: function(graph, id, action, flags) {
        var filter = this.filter(flags);
        this.clean(graph);
        var queue = [graph.getNode(id)];
        while(queue.length != 0) {
            var node = queue.pop();
            node._flag = true;
            action(node, node._depth);
            this.eachAdjacency(node, function(adj) {
                var n = adj.nodeTo;
                if(n._flag == false && filter(n)) {
                    n._flag = true;
                    queue.unshift(n);
                }
            }, flags);
        }
    },
    
    /*
       Method: eachLevel
    
       Iterates over a node's subgraph applying *action* to the nodes of relative depth between *levelBegin* and *levelEnd*.
       
       Also implemented by:
       
       <Graph.Node>.

       Parameters:
       
       node - (object) A <Graph.Node>.
       levelBegin - (number) A relative level value.
       levelEnd - (number) A relative level value.
       action - (function) A callback function having a <Graph.Node> as first formal parameter.

    */
    eachLevel: function(node, levelBegin, levelEnd, action, flags) {
        var d = node._depth, filter = this.filter(flags), that = this;
        levelEnd = levelEnd === false? Number.MAX_VALUE -d : levelEnd;
        (function loopLevel(node, levelBegin, levelEnd) {
            var d = node._depth;
            if(d >= levelBegin && d <= levelEnd && filter(node)) action(node, d);
            if(d < levelEnd) {
                that.eachAdjacency(node, function(adj) {
                    var n = adj.nodeTo;
                    if(n._depth > d) loopLevel(n, levelBegin, levelEnd);
                });
            }
        })(node, levelBegin + d, levelEnd + d);      
    },

    /*
       Method: eachSubgraph
    
       Iterates over a node's children recursively.
       
       Also implemented by:
       
       <Graph.Node>.

       Parameters:
       node - (object) A <Graph.Node>.
       action - (function) A callback function having a <Graph.Node> as first formal parameter.

       Example:
       (start code js)
         $jit.Graph.Util.eachSubgraph(node, function(node) {
           alert(node.name);
         });
         //or...
         node.eachSubgraph(function(node) {
           alert(node.name);
         });
       (end code)
    */
    eachSubgraph: function(node, action, flags) {
      this.eachLevel(node, 0, false, action, flags);
    },

    /*
       Method: eachSubnode
    
       Iterates over a node's children (without deeper recursion).
       
       Also implemented by:
       
       <Graph.Node>.
       
       Parameters:
       node - (object) A <Graph.Node>.
       action - (function) A callback function having a <Graph.Node> as first formal parameter.

       Example:
       (start code js)
         $jit.Graph.Util.eachSubnode(node, function(node) {
          alert(node.name);
         });
         //or...
         node.eachSubnode(function(node) {
           alert(node.name);
         });
       (end code)
    */
    eachSubnode: function(node, action, flags) {
        this.eachLevel(node, 1, 1, action, flags);
    },

    /*
       Method: anySubnode
    
       Returns *true* if any subnode matches the given condition.
       
       Also implemented by:
       
       <Graph.Node>.

       Parameters:
       node - (object) A <Graph.Node>.
       cond - (function) A callback function returning a Boolean instance. This function has as first formal parameter a <Graph.Node>.

       Example:
       (start code js)
         $jit.Graph.Util.anySubnode(node, function(node) { return node.name == "mynodename"; });
         //or...
         node.anySubnode(function(node) { return node.name == 'mynodename'; });
       (end code)
    */
    anySubnode: function(node, cond, flags) {
      var flag = false;
      cond = cond || $.lambda(true);
      var c = $.type(cond) == 'string'? function(n) { return n[cond]; } : cond;
      this.eachSubnode(node, function(elem) {
        if(c(elem)) flag = true;
      }, flags);
      return flag;
    },
  
    /*
       Method: getSubnodes
    
       Collects all subnodes for a specified node. 
       The *level* parameter filters nodes having relative depth of *level* from the root node. 
       
       Also implemented by:
       
       <Graph.Node>.

       Parameters:
       node - (object) A <Graph.Node>.
       level - (optional|number) Default's *0*. A starting relative depth for collecting nodes.

       Returns:
       An array of nodes.

    */
    getSubnodes: function(node, level, flags) {
        var ans = [], that = this;
        level = level || 0;
        var levelStart, levelEnd;
        if($.type(level) == 'array') {
            levelStart = level[0];
            levelEnd = level[1];
        } else {
            levelStart = level;
            levelEnd = Number.MAX_VALUE - node._depth;
        }
        this.eachLevel(node, levelStart, levelEnd, function(n) {
            ans.push(n);
        }, flags);
        return ans;
    },
  
  
    /*
       Method: getParents
    
       Returns an Array of <Graph.Nodes> which are parents of the given node.
       
       Also implemented by:
       
       <Graph.Node>.

       Parameters:
       node - (object) A <Graph.Node>.

       Returns:
       An Array of <Graph.Nodes>.

       Example:
       (start code js)
         var pars = $jit.Graph.Util.getParents(node);
         //or...
         var pars = node.getParents();
         
         if(pars.length > 0) {
           //do stuff with parents
         }
       (end code)
    */
    getParents: function(node) {
        var ans = [];
        this.eachAdjacency(node, function(adj) {
            var n = adj.nodeTo;
            if(n._depth < node._depth) ans.push(n);
        });
        return ans;
    },
    
    /*
    Method: isDescendantOf
 
    Returns a boolean indicating if some node is descendant of the node with the given id. 

    Also implemented by:
    
    <Graph.Node>.
    
    
    Parameters:
    node - (object) A <Graph.Node>.
    id - (string) A <Graph.Node> id.

    Example:
    (start code js)
      $jit.Graph.Util.isDescendantOf(node, "nodeid"); //true|false
      //or...
      node.isDescendantOf('nodeid');//true|false
    (end code)
 */
 isDescendantOf: function(node, id) {
    if(node.id == id) return true;
    var pars = this.getParents(node), ans = false;
    for ( var i = 0; !ans && i < pars.length; i++) {
    ans = ans || this.isDescendantOf(pars[i], id);
  }
    return ans;
 },

 /*
     Method: clean
  
     Cleans flags from nodes.

     Also implemented by:
     
     <Graph>.
     
     Parameters:
     graph - A <Graph> instance.
  */
  clean: function(graph) { this.eachNode(graph, function(elem) { elem._flag = false; }); },
  
  /* 
    Method: getClosestNodeToOrigin 
  
    Returns the closest node to the center of canvas.
  
    Also implemented by:
    
    <Graph>.
    
    Parameters:
   
     graph - (object) A <Graph> instance.
     prop - (optional|string) Default's 'current'. A <Graph.Node> position property. Possible properties are 'start', 'current' or 'end'.
  
  */
  getClosestNodeToOrigin: function(graph, prop, flags) {
   return this.getClosestNodeToPos(graph, Polar.KER, prop, flags);
  },
  
  /* 
    Method: getClosestNodeToPos
  
    Returns the closest node to the given position.
  
    Also implemented by:
    
    <Graph>.
    
    Parameters:
   
     graph - (object) A <Graph> instance.
     pos - (object) A <Complex> or <Polar> instance.
     prop - (optional|string) Default's *current*. A <Graph.Node> position property. Possible properties are 'start', 'current' or 'end'.
  
  */
  getClosestNodeToPos: function(graph, pos, prop, flags) {
   var node = null;
   prop = prop || 'current';
   pos = pos && pos.getc(true) || Complex.KER;
   var distance = function(a, b) {
     var d1 = a.x - b.x, d2 = a.y - b.y;
     return d1 * d1 + d2 * d2;
   };
   this.eachNode(graph, function(elem) {
     node = (node == null || distance(elem.getPos(prop).getc(true), pos) < distance(
         node.getPos(prop).getc(true), pos)) ? elem : node;
   }, flags);
   return node;
  } 
};

//Append graph methods to <Graph>
$.each(['get', 'getNode', 'each', 'eachNode', 'computeLevels', 'eachBFS', 'clean', 'getClosestNodeToPos', 'getClosestNodeToOrigin'], function(m) {
  Graph.prototype[m] = function() {
    return Graph.Util[m].apply(Graph.Util, [this].concat(Array.prototype.slice.call(arguments)));
  };
});

//Append node methods to <Graph.Node>
$.each(['eachAdjacency', 'eachLevel', 'eachSubgraph', 'eachSubnode', 'anySubnode', 'getSubnodes', 'getParents', 'isDescendantOf'], function(m) {
  Graph.Node.prototype[m] = function() {
    return Graph.Util[m].apply(Graph.Util, [this].concat(Array.prototype.slice.call(arguments)));
  };
});

/*
 * File: Graph.Op.js
 *
*/

/*
   Object: Graph.Op

   Perform <Graph> operations like adding/removing <Graph.Nodes> or <Graph.Adjacences>, 
   morphing a <Graph> into another <Graph>, contracting or expanding subtrees, etc.

*/
Graph.Op = {

    options: {
      type: 'nothing',
      duration: 2000,
      hideLabels: true,
      fps:30
    },
    
    initialize: function(viz) {
      this.viz = viz;
    },

    /*
       Method: removeNode
    
       Removes one or more <Graph.Nodes> from the visualization. 
       It can also perform several animations like fading sequentially, fading concurrently, iterating or replotting.

       Parameters:
    
        node - (string|array) The node's id. Can also be an array having many ids.
        opt - (object) Animation options. It's an object with optional properties described below
        type - (string) Default's *nothing*. Type of the animation. Can be "nothing", "replot", "fade:seq",  "fade:con" or "iter".
        duration - Described in <Options.Fx>.
        fps - Described in <Options.Fx>.
        transition - Described in <Options.Fx>.
        hideLabels - (boolean) Default's *true*. Hide labels during the animation.
   
      Example:
      (start code js)
        var viz = new $jit.Viz(options);
        viz.op.removeNode('nodeId', {
          type: 'fade:seq',
          duration: 1000,
          hideLabels: false,
          transition: $jit.Trans.Quart.easeOut
        });
        //or also
        viz.op.removeNode(['someId', 'otherId'], {
          type: 'fade:con',
          duration: 1500
        });
      (end code)
    */
  
    removeNode: function(node, opt) {
        var viz = this.viz;
        var options = $.merge(this.options, viz.controller, opt);
        var n = $.splat(node);
        var i, that, nodeObj;
        switch(options.type) {
            case 'nothing':
                for(i=0; i<n.length; i++) viz.graph.removeNode(n[i]);
                break;
            
            case 'replot':
                this.removeNode(n, { type: 'nothing' });
                viz.labels.clearLabels();
                viz.refresh(true);
                break;
            
            case 'fade:seq': case 'fade':
                that = this;
                //set alpha to 0 for nodes to remove.
                for(i=0; i<n.length; i++) {
                    nodeObj = viz.graph.getNode(n[i]);
                    nodeObj.setData('alpha', 0, 'end');
                }
                viz.fx.animate($.merge(options, {
                    modes: ['node-property:alpha'],
                    onComplete: function() {
                        that.removeNode(n, { type: 'nothing' });
                        viz.labels.clearLabels();
                        viz.reposition();
                        viz.fx.animate($.merge(options, {
                            modes: ['linear']
                        }));
                    }
                }));
                break;
            
            case 'fade:con':
                that = this;
                //set alpha to 0 for nodes to remove. Tag them for being ignored on computing positions.
                for(i=0; i<n.length; i++) {
                    nodeObj = viz.graph.getNode(n[i]);
                    nodeObj.setData('alpha', 0, 'end');
                    nodeObj.ignore = true;
                }
                viz.reposition();
                viz.fx.animate($.merge(options, {
                    modes: ['node-property:alpha', 'linear'],
                    onComplete: function() {
                        that.removeNode(n, { type: 'nothing' });
                        options.onComplete && options.onComplete();
                    }
                }));
                break;
            
            case 'iter':
                that = this;
                viz.fx.sequence({
                    condition: function() { return n.length != 0; },
                    step: function() { that.removeNode(n.shift(), { type: 'nothing' });  viz.labels.clearLabels(); },
                    onComplete: function() { options.onComplete && options.onComplete(); },
                    duration: Math.ceil(options.duration / n.length)
                });
                break;
                
            default: this.doError();
        }
    },
    
    /*
       Method: removeEdge
    
       Removes one or more <Graph.Adjacences> from the visualization. 
       It can also perform several animations like fading sequentially, fading concurrently, iterating or replotting.

       Parameters:
    
       vertex - (array) An array having two strings which are the ids of the nodes connected by this edge (i.e ['id1', 'id2']). Can also be a two dimensional array holding many edges (i.e [['id1', 'id2'], ['id3', 'id4'], ...]).
       opt - (object) Animation options. It's an object with optional properties described below
       type - (string) Default's *nothing*. Type of the animation. Can be "nothing", "replot", "fade:seq",  "fade:con" or "iter".
       duration - Described in <Options.Fx>.
       fps - Described in <Options.Fx>.
       transition - Described in <Options.Fx>.
       hideLabels - (boolean) Default's *true*. Hide labels during the animation.
   
      Example:
      (start code js)
        var viz = new $jit.Viz(options);
        viz.op.removeEdge(['nodeId', 'otherId'], {
          type: 'fade:seq',
          duration: 1000,
          hideLabels: false,
          transition: $jit.Trans.Quart.easeOut
        });
        //or also
        viz.op.removeEdge([['someId', 'otherId'], ['id3', 'id4']], {
          type: 'fade:con',
          duration: 1500
        });
      (end code)
    
    */
    removeEdge: function(vertex, opt) {
        var viz = this.viz;
        var options = $.merge(this.options, viz.controller, opt);
        var v = ($.type(vertex[0]) == 'string')? [vertex] : vertex;
        var i, that, adj;
        switch(options.type) {
            case 'nothing':
                for(i=0; i<v.length; i++)   viz.graph.removeAdjacence(v[i][0], v[i][1]);
                break;
            
            case 'replot':
                this.removeEdge(v, { type: 'nothing' });
                viz.refresh(true);
                break;
            
            case 'fade:seq': case 'fade':
                that = this;
                //set alpha to 0 for edges to remove.
                for(i=0; i<v.length; i++) {
                    adj = viz.graph.getAdjacence(v[i][0], v[i][1]);
                    if(adj) {
                        adj.setData('alpha', 0,'end');
                    }
                }
                viz.fx.animate($.merge(options, {
                    modes: ['edge-property:alpha'],
                    onComplete: function() {
                        that.removeEdge(v, { type: 'nothing' });
                        viz.reposition();
                        viz.fx.animate($.merge(options, {
                            modes: ['linear']
                        }));
                    }
                }));
                break;
            
            case 'fade:con':
                that = this;
                //set alpha to 0 for nodes to remove. Tag them for being ignored when computing positions.
                for(i=0; i<v.length; i++) {
                    adj = viz.graph.getAdjacence(v[i][0], v[i][1]);
                    if(adj) {
                        adj.setData('alpha',0 ,'end');
                        adj.ignore = true;
                    }
                }
                viz.reposition();
                viz.fx.animate($.merge(options, {
                    modes: ['edge-property:alpha', 'linear'],
                    onComplete: function() {
                        that.removeEdge(v, { type: 'nothing' });
                        options.onComplete && options.onComplete();
                    }
                }));
                break;
            
            case 'iter':
                that = this;
                viz.fx.sequence({
                    condition: function() { return v.length != 0; },
                    step: function() { that.removeEdge(v.shift(), { type: 'nothing' }); viz.labels.clearLabels(); },
                    onComplete: function() { options.onComplete(); },
                    duration: Math.ceil(options.duration / v.length)
                });
                break;
                
            default: this.doError();
        }
    },
    
    /*
       Method: sum
    
       Adds a new graph to the visualization. 
       The JSON graph (or tree) must at least have a common node with the current graph plotted by the visualization. 
       The resulting graph can be defined as follows <http://mathworld.wolfram.com/GraphSum.html>

       Parameters:
    
       json - (object) A json tree or graph structure. See also <Loader.loadJSON>.
       opt - (object) Animation options. It's an object with optional properties described below
       type - (string) Default's *nothing*. Type of the animation. Can be "nothing", "replot", "fade:seq",  "fade:con".
       duration - Described in <Options.Fx>.
       fps - Described in <Options.Fx>.
       transition - Described in <Options.Fx>.
       hideLabels - (boolean) Default's *true*. Hide labels during the animation.
   
      Example:
      (start code js)
        //...json contains a tree or graph structure...

        var viz = new $jit.Viz(options);
        viz.op.sum(json, {
          type: 'fade:seq',
          duration: 1000,
          hideLabels: false,
          transition: $jit.Trans.Quart.easeOut
        });
        //or also
        viz.op.sum(json, {
          type: 'fade:con',
          duration: 1500
        });
      (end code)
    
    */
    sum: function(json, opt) {
        var viz = this.viz;
        var options = $.merge(this.options, viz.controller, opt), root = viz.root;
        var graph;
        viz.root = opt.id || viz.root;
        switch(options.type) {
            case 'nothing':
                graph = viz.construct(json);
                graph.eachNode(function(elem) {
                    elem.eachAdjacency(function(adj) {
                        viz.graph.addAdjacence(adj.nodeFrom, adj.nodeTo, adj.data);
                    });
                });
                break;
            
            case 'replot':
                viz.refresh(true);
                this.sum(json, { type: 'nothing' });
                viz.refresh(true);
                break;
            
            case 'fade:seq': case 'fade': case 'fade:con':
                that = this;
                graph = viz.construct(json);

                //set alpha to 0 for nodes to add.
                var fadeEdges = this.preprocessSum(graph);
                var modes = !fadeEdges? ['node-property:alpha'] : ['node-property:alpha', 'edge-property:alpha'];
                viz.reposition();
                if(options.type != 'fade:con') {
                    viz.fx.animate($.merge(options, {
                        modes: ['linear'],
                        onComplete: function() {
                            viz.fx.animate($.merge(options, {
                                modes: modes,
                                onComplete: function() {
                                    options.onComplete();
                                }
                            }));
                        }
                    }));
                } else {
                    viz.graph.eachNode(function(elem) {
                        if (elem.id != root && elem.pos.isZero()) {
                          elem.pos.set(elem.endPos); 
                          elem.startPos.set(elem.endPos);
                        }
                    });
                    viz.fx.animate($.merge(options, {
                        modes: ['linear'].concat(modes)
                    }));
                }
                break;

            default: this.doError();
        }
    },
    
    /*
       Method: morph
    
       This method will transform the current visualized graph into the new JSON representation passed in the method. 
       The JSON object must at least have the root node in common with the current visualized graph.

       Parameters:
    
       json - (object) A json tree or graph structure. See also <Loader.loadJSON>.
       opt - (object) Animation options. It's an object with optional properties described below
       type - (string) Default's *nothing*. Type of the animation. Can be "nothing", "replot", "fade:con".
       duration - Described in <Options.Fx>.
       fps - Described in <Options.Fx>.
       transition - Described in <Options.Fx>.
       hideLabels - (boolean) Default's *true*. Hide labels during the animation.
       id - (string) The shared <Graph.Node> id between both graphs.
       
       extraModes - (optional|object) When morphing with an animation, dollar prefixed data parameters are added to 
                    *endData* and not *data* itself. This way you can animate dollar prefixed parameters during your morphing operation. 
                    For animating these extra-parameters you have to specify an object that has animation groups as keys and animation 
                    properties as values, just like specified in <Graph.Plot.animate>.
   
      Example:
      (start code js)
        //...json contains a tree or graph structure...

        var viz = new $jit.Viz(options);
        viz.op.morph(json, {
          type: 'fade',
          duration: 1000,
          hideLabels: false,
          transition: $jit.Trans.Quart.easeOut
        });
        //or also
        viz.op.morph(json, {
          type: 'fade',
          duration: 1500
        });
        //if the json data contains dollar prefixed params
        //like $width or $height these too can be animated
        viz.op.morph(json, {
          type: 'fade',
          duration: 1500
        }, {
          'node-property': ['width', 'height']
        });
      (end code)
    
    */
    morph: function(json, opt, extraModes) {
        extraModes = extraModes || {};
        var viz = this.viz;
        var options = $.merge(this.options, viz.controller, opt), root = viz.root;
        var graph;
        //TODO(nico) this hack makes morphing work with the Hypertree. 
        //Need to check if it has been solved and this can be removed.
        viz.root = opt.id || viz.root;
        switch(options.type) {
            case 'nothing':
                graph = viz.construct(json);
                graph.eachNode(function(elem) {
                  var nodeExists = viz.graph.hasNode(elem.id);  
                  elem.eachAdjacency(function(adj) {
                    var adjExists = !!viz.graph.getAdjacence(adj.nodeFrom.id, adj.nodeTo.id);
                    viz.graph.addAdjacence(adj.nodeFrom, adj.nodeTo, adj.data);
                    //Update data properties if the node existed
                    if(adjExists) {
                      var addedAdj = viz.graph.getAdjacence(adj.nodeFrom.id, adj.nodeTo.id);
                      for(var prop in (adj.data || {})) {
                        addedAdj.data[prop] = adj.data[prop];
                      }
                    }
                  });
                  //Update data properties if the node existed
                  if(nodeExists) {
                    var addedNode = viz.graph.getNode(elem.id);
                    for(var prop in (elem.data || {})) {
                      addedNode.data[prop] = elem.data[prop];
                    }
                  }
                });
                viz.graph.eachNode(function(elem) {
                    elem.eachAdjacency(function(adj) {
                        if(!graph.getAdjacence(adj.nodeFrom.id, adj.nodeTo.id)) {
                            viz.graph.removeAdjacence(adj.nodeFrom.id, adj.nodeTo.id);
                        }
                    });
                    if(!graph.hasNode(elem.id)) viz.graph.removeNode(elem.id);
                });
                
                break;
            
            case 'replot':
                viz.labels.clearLabels(true);
                this.morph(json, { type: 'nothing' });
                viz.refresh(true);
                viz.refresh(true);
                break;
                
            case 'fade:seq': case 'fade': case 'fade:con':
                that = this;
                graph = viz.construct(json);
                //preprocessing for nodes to delete.
                //get node property modes to interpolate
                var nodeModes = ('node-property' in extraModes) 
                  && $.map($.splat(extraModes['node-property']), 
                      function(n) { return '$' + n; });
                viz.graph.eachNode(function(elem) {
                  var graphNode = graph.getNode(elem.id);   
                  if(!graphNode) {
                      elem.setData('alpha', 1);
                      elem.setData('alpha', 1, 'start');
                      elem.setData('alpha', 0, 'end');
                      elem.ignore = true;
                    } else {
                      //Update node data information
                      var graphNodeData = graphNode.data;
                      for(var prop in graphNodeData) {
                        if(nodeModes && ($.indexOf(nodeModes, prop) > -1)) {
                          elem.endData[prop] = graphNodeData[prop];
                        } else {
                          elem.data[prop] = graphNodeData[prop];
                        }
                      }
                    }
                }); 
                viz.graph.eachNode(function(elem) {
                    if(elem.ignore) return;
                    elem.eachAdjacency(function(adj) {
                        if(adj.nodeFrom.ignore || adj.nodeTo.ignore) return;
                        var nodeFrom = graph.getNode(adj.nodeFrom.id);
                        var nodeTo = graph.getNode(adj.nodeTo.id);
                        if(!nodeFrom.adjacentTo(nodeTo)) {
                            var adj = viz.graph.getAdjacence(nodeFrom.id, nodeTo.id);
                            fadeEdges = true;
                            adj.setData('alpha', 1);
                            adj.setData('alpha', 1, 'start');
                            adj.setData('alpha', 0, 'end');
                        }
                    });
                }); 
                //preprocessing for adding nodes.
                var fadeEdges = this.preprocessSum(graph);

                var modes = !fadeEdges? ['node-property:alpha'] : 
                                        ['node-property:alpha', 
                                         'edge-property:alpha'];
                //Append extra node-property animations (if any)
                modes[0] = modes[0] + (('node-property' in extraModes)? 
                    (':' + $.splat(extraModes['node-property']).join(':')) : '');
                //Append extra edge-property animations (if any)
                modes[1] = (modes[1] || 'edge-property:alpha') + (('edge-property' in extraModes)? 
                    (':' + $.splat(extraModes['edge-property']).join(':')) : '');
                //Add label-property animations (if any)
                if('label-property' in extraModes) {
                  modes.push('label-property:' + $.splat(extraModes['label-property']).join(':'))
                }
                //only use reposition if its implemented.
                if (viz.reposition) {
                  viz.reposition();
                } else {
                  viz.compute('end');
                }
                viz.graph.eachNode(function(elem) {
                    if (elem.id != root && elem.pos.getp().equals(Polar.KER)) {
                      elem.pos.set(elem.endPos); elem.startPos.set(elem.endPos);
                    }
                });
                viz.fx.animate($.merge(options, {
                    modes: [extraModes.position || 'polar'].concat(modes),
                    onComplete: function() {
                        viz.graph.eachNode(function(elem) {
                            if(elem.ignore) viz.graph.removeNode(elem.id);
                        });
                        viz.graph.eachNode(function(elem) {
                            elem.eachAdjacency(function(adj) {
                                if(adj.ignore) viz.graph.removeAdjacence(adj.nodeFrom.id, adj.nodeTo.id);
                            });
                        });
                        options.onComplete();
                    }
                }));
                break;

            default:;
        }
    },

    
  /*
    Method: contract
 
    Collapses the subtree of the given node. The node will have a _collapsed=true_ property.
    
    Parameters:
 
    node - (object) A <Graph.Node>.
    opt - (object) An object containing options described below
    type - (string) Whether to 'replot' or 'animate' the contraction.
   
    There are also a number of Animation options. For more information see <Options.Fx>.

    Example:
    (start code js)
     var viz = new $jit.Viz(options);
     viz.op.contract(node, {
       type: 'animate',
       duration: 1000,
       hideLabels: true,
       transition: $jit.Trans.Quart.easeOut
     });
   (end code)
 
   */
    contract: function(node, opt) {
      var viz = this.viz;
      if(node.collapsed || !node.anySubnode($.lambda(true))) return;
      opt = $.merge(this.options, viz.config, opt || {}, {
        'modes': ['node-property:alpha:span', 'linear']
      });
      node.collapsed = true;
      (function subn(n) {
        n.eachSubnode(function(ch) {
          ch.ignore = true;
          ch.setData('alpha', 0, opt.type == 'animate'? 'end' : 'current');
          subn(ch);
        });
      })(node);
      if(opt.type == 'animate') {
        viz.compute('end');
        if(viz.rotated) {
          viz.rotate(viz.rotated, 'none', {
            'property':'end'
          });
        }
        (function subn(n) {
          n.eachSubnode(function(ch) {
            ch.setPos(node.getPos('end'), 'end');
            subn(ch);
          });
        })(node);
        viz.fx.animate(opt);
      } else if(opt.type == 'replot'){
        viz.refresh();
      }
    },
    
    /*
    Method: expand
 
    Expands the previously contracted subtree. The given node must have the _collapsed=true_ property.
    
    Parameters:
 
    node - (object) A <Graph.Node>.
    opt - (object) An object containing options described below
    type - (string) Whether to 'replot' or 'animate'.
     
    There are also a number of Animation options. For more information see <Options.Fx>.

    Example:
    (start code js)
      var viz = new $jit.Viz(options);
      viz.op.expand(node, {
        type: 'animate',
        duration: 1000,
        hideLabels: true,
        transition: $jit.Trans.Quart.easeOut
      });
    (end code)
 
   */
    expand: function(node, opt) {
      if(!('collapsed' in node)) return;
      var viz = this.viz;
      opt = $.merge(this.options, viz.config, opt || {}, {
        'modes': ['node-property:alpha:span', 'linear']
      });
      delete node.collapsed;
      (function subn(n) {
        n.eachSubnode(function(ch) {
          delete ch.ignore;
          ch.setData('alpha', 1, opt.type == 'animate'? 'end' : 'current');
          subn(ch);
        });
      })(node);
      if(opt.type == 'animate') {
        viz.compute('end');
        if(viz.rotated) {
          viz.rotate(viz.rotated, 'none', {
            'property':'end'
          });
        }
        viz.fx.animate(opt);
      } else if(opt.type == 'replot'){
        viz.refresh();
      }
    },

    preprocessSum: function(graph) {
        var viz = this.viz;
        graph.eachNode(function(elem) {
            if(!viz.graph.hasNode(elem.id)) {
                viz.graph.addNode(elem);
                var n = viz.graph.getNode(elem.id);
                n.setData('alpha', 0);
                n.setData('alpha', 0, 'start');
                n.setData('alpha', 1, 'end');
            }
        }); 
        var fadeEdges = false;
        graph.eachNode(function(elem) {
            elem.eachAdjacency(function(adj) {
                var nodeFrom = viz.graph.getNode(adj.nodeFrom.id);
                var nodeTo = viz.graph.getNode(adj.nodeTo.id);
                if(!nodeFrom.adjacentTo(nodeTo)) {
                    var adj = viz.graph.addAdjacence(nodeFrom, nodeTo, adj.data);
                    if(nodeFrom.startAlpha == nodeFrom.endAlpha 
                    && nodeTo.startAlpha == nodeTo.endAlpha) {
                        fadeEdges = true;
                        adj.setData('alpha', 0);
                        adj.setData('alpha', 0, 'start');
                        adj.setData('alpha', 1, 'end');
                    } 
                }
            });
        }); 
        return fadeEdges;
    }
};



/*
   File: Helpers.js
 
   Helpers are objects that contain rendering primitives (like rectangles, ellipses, etc), for plotting nodes and edges.
   Helpers also contain implementations of the *contains* method, a method returning a boolean indicating whether the mouse
   position is over the rendered shape.
   
   Helpers are very useful when implementing new NodeTypes, since you can access them through *this.nodeHelper* and 
   *this.edgeHelper* <Graph.Plot> properties, providing you with simple primitives and mouse-position check functions.
   
   Example:
   (start code js)
   //implement a new node type
   $jit.Viz.Plot.NodeTypes.implement({
     'customNodeType': {
       'render': function(node, canvas) {
         this.nodeHelper.circle.render ...
       },
       'contains': function(node, pos) {
         this.nodeHelper.circle.contains ...
       }
     }
   });
   //implement an edge type
   $jit.Viz.Plot.EdgeTypes.implement({
     'customNodeType': {
       'render': function(node, canvas) {
         this.edgeHelper.circle.render ...
       },
       //optional
       'contains': function(node, pos) {
         this.edgeHelper.circle.contains ...
       }
     }
   });
   (end code)

*/

/*
   Object: NodeHelper
   
   Contains rendering and other type of primitives for simple shapes.
 */
var NodeHelper = {
  'none': {
    'render': $.empty,
    'contains': $.lambda(false)
  },
  /*
   Object: NodeHelper.circle
   */
  'circle': {
    /*
     Method: render
     
     Renders a circle into the canvas.
     
     Parameters:
     
     type - (string) Possible options are 'fill' or 'stroke'.
     pos - (object) An *x*, *y* object with the position of the center of the circle.
     radius - (number) The radius of the circle to be rendered.
     canvas - (object) A <Canvas> instance.
     
     Example:
     (start code js)
     NodeHelper.circle.render('fill', { x: 10, y: 30 }, 30, viz.canvas);
     (end code)
     */
    'render': function(type, pos, radius, canvas){
      var ctx = canvas.getCtx();
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx[type]();
    },
    /*
    Method: contains
    
    Returns *true* if *pos* is contained in the area of the shape. Returns *false* otherwise.
    
    Parameters:
    
    npos - (object) An *x*, *y* object with the <Graph.Node> position.
    pos - (object) An *x*, *y* object with the position to check.
    radius - (number) The radius of the rendered circle.
    
    Example:
    (start code js)
    NodeHelper.circle.contains({ x: 10, y: 30 }, { x: 15, y: 35 }, 30); //true
    (end code)
    */
    'contains': function(npos, pos, radius){
      var diffx = npos.x - pos.x, 
          diffy = npos.y - pos.y, 
          diff = diffx * diffx + diffy * diffy;
      return diff <= radius * radius;
    }
  },
  /*
  Object: NodeHelper.ellipse
  */
  'ellipse': {
    /*
    Method: render
    
    Renders an ellipse into the canvas.
    
    Parameters:
    
    type - (string) Possible options are 'fill' or 'stroke'.
    pos - (object) An *x*, *y* object with the position of the center of the ellipse.
    width - (number) The width of the ellipse.
    height - (number) The height of the ellipse.
    canvas - (object) A <Canvas> instance.
    
    Example:
    (start code js)
    NodeHelper.ellipse.render('fill', { x: 10, y: 30 }, 30, 40, viz.canvas);
    (end code)
    */
    'render': function(type, pos, width, height, canvas){
      var ctx = canvas.getCtx(),
          scalex = 1,
          scaley = 1,
          scaleposx = 1,
          scaleposy = 1,
          radius = 0;

      if (width > height) {
          radius = width / 2;
          scaley = height / width;
          scaleposy = width / height;
      } else {
          radius = height / 2;
          scalex = width / height;
          scaleposx = height / width;
      }

      ctx.save();
      ctx.scale(scalex, scaley);
      ctx.beginPath();
      ctx.arc(pos.x * scaleposx, pos.y * scaleposy, radius, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx[type]();
      ctx.restore();
    },
    /*
    Method: contains
    
    Returns *true* if *pos* is contained in the area of the shape. Returns *false* otherwise.
    
    Parameters:
    
    npos - (object) An *x*, *y* object with the <Graph.Node> position.
    pos - (object) An *x*, *y* object with the position to check.
    width - (number) The width of the rendered ellipse.
    height - (number) The height of the rendered ellipse.
    
    Example:
    (start code js)
    NodeHelper.ellipse.contains({ x: 10, y: 30 }, { x: 15, y: 35 }, 30, 40);
    (end code)
    */
    'contains': function(npos, pos, width, height){
      var radius = 0,
          scalex = 1,
          scaley = 1,
          diffx = 0,
          diffy = 0,
          diff = 0;

      if (width > height) {
	      radius = width / 2;
	      scaley = height / width;
      } else {
          radius = height / 2;
          scalex = width / height;
      }

      diffx = (npos.x - pos.x) * (1 / scalex);
      diffy = (npos.y - pos.y) * (1 / scaley);
      diff = diffx * diffx + diffy * diffy;
      return diff <= radius * radius;
    }
  },
  /*
  Object: NodeHelper.square
  */
  'square': {
    /*
    Method: render
    
    Renders a square into the canvas.
    
    Parameters:
    
    type - (string) Possible options are 'fill' or 'stroke'.
    pos - (object) An *x*, *y* object with the position of the center of the square.
    dim - (number) The radius (or half-diameter) of the square.
    canvas - (object) A <Canvas> instance.
    
    Example:
    (start code js)
    NodeHelper.square.render('stroke', { x: 10, y: 30 }, 40, viz.canvas);
    (end code)
    */
    'render': function(type, pos, dim, canvas){
      canvas.getCtx()[type + "Rect"](pos.x - dim, pos.y - dim, 2*dim, 2*dim);
    },
    /*
    Method: contains
    
    Returns *true* if *pos* is contained in the area of the shape. Returns *false* otherwise.
    
    Parameters:
    
    npos - (object) An *x*, *y* object with the <Graph.Node> position.
    pos - (object) An *x*, *y* object with the position to check.
    dim - (number) The radius (or half-diameter) of the square.
    
    Example:
    (start code js)
    NodeHelper.square.contains({ x: 10, y: 30 }, { x: 15, y: 35 }, 30);
    (end code)
    */
    'contains': function(npos, pos, dim){
      return Math.abs(pos.x - npos.x) <= dim && Math.abs(pos.y - npos.y) <= dim;
    }
  },
  /*
  Object: NodeHelper.rectangle
  */
  'rectangle': {
    /*
    Method: render
    
    Renders a rectangle into the canvas.
    
    Parameters:
    
    type - (string) Possible options are 'fill' or 'stroke'.
    pos - (object) An *x*, *y* object with the position of the center of the rectangle.
    width - (number) The width of the rectangle.
    height - (number) The height of the rectangle.
    canvas - (object) A <Canvas> instance.
    
    Example:
    (start code js)
    NodeHelper.rectangle.render('fill', { x: 10, y: 30 }, 30, 40, viz.canvas);
    (end code)
    */
    'render': function(type, pos, width, height, canvas){
      canvas.getCtx()[type + "Rect"](pos.x - width / 2, pos.y - height / 2, 
                                      width, height);
    },
    /*
    Method: contains
    
    Returns *true* if *pos* is contained in the area of the shape. Returns *false* otherwise.
    
    Parameters:
    
    npos - (object) An *x*, *y* object with the <Graph.Node> position.
    pos - (object) An *x*, *y* object with the position to check.
    width - (number) The width of the rendered rectangle.
    height - (number) The height of the rendered rectangle.
    
    Example:
    (start code js)
    NodeHelper.rectangle.contains({ x: 10, y: 30 }, { x: 15, y: 35 }, 30, 40);
    (end code)
    */
    'contains': function(npos, pos, width, height){
      return Math.abs(pos.x - npos.x) <= width / 2
          && Math.abs(pos.y - npos.y) <= height / 2;
    }
  },
  /*
  Object: NodeHelper.triangle
  */
  'triangle': {
    /*
    Method: render
    
    Renders a triangle into the canvas.
    
    Parameters:
    
    type - (string) Possible options are 'fill' or 'stroke'.
    pos - (object) An *x*, *y* object with the position of the center of the triangle.
    dim - (number) Half the base and half the height of the triangle.
    canvas - (object) A <Canvas> instance.
    
    Example:
    (start code js)
    NodeHelper.triangle.render('stroke', { x: 10, y: 30 }, 40, viz.canvas);
    (end code)
    */
    'render': function(type, pos, dim, canvas){
      var ctx = canvas.getCtx(), 
          c1x = pos.x, 
          c1y = pos.y - dim, 
          c2x = c1x - dim, 
          c2y = pos.y + dim, 
          c3x = c1x + dim, 
          c3y = c2y;
      ctx.beginPath();
      ctx.moveTo(c1x, c1y);
      ctx.lineTo(c2x, c2y);
      ctx.lineTo(c3x, c3y);
      ctx.closePath();
      ctx[type]();
    },
    /*
    Method: contains
    
    Returns *true* if *pos* is contained in the area of the shape. Returns *false* otherwise.
    
    Parameters:
    
    npos - (object) An *x*, *y* object with the <Graph.Node> position.
    pos - (object) An *x*, *y* object with the position to check.
    dim - (number) Half the base and half the height of the triangle.
    
    Example:
    (start code js)
    NodeHelper.triangle.contains({ x: 10, y: 30 }, { x: 15, y: 35 }, 30);
    (end code)
    */
    'contains': function(npos, pos, dim) {
      return NodeHelper.circle.contains(npos, pos, dim);
    }
  },
  /*
  Object: NodeHelper.star
  */
  'star': {
    /*
    Method: render
    
    Renders a star (concave decagon) into the canvas.
    
    Parameters:
    
    type - (string) Possible options are 'fill' or 'stroke'.
    pos - (object) An *x*, *y* object with the position of the center of the star.
    dim - (number) The length of a side of a concave decagon.
    canvas - (object) A <Canvas> instance.
    
    Example:
    (start code js)
    NodeHelper.star.render('stroke', { x: 10, y: 30 }, 40, viz.canvas);
    (end code)
    */
    'render': function(type, pos, dim, canvas){
      var ctx = canvas.getCtx(), 
          pi5 = Math.PI / 5;
      ctx.save();
      ctx.translate(pos.x, pos.y);
      ctx.beginPath();
      ctx.moveTo(dim, 0);
      for (var i = 0; i < 9; i++) {
        ctx.rotate(pi5);
        if (i % 2 == 0) {
          ctx.lineTo((dim / 0.525731) * 0.200811, 0);
        } else {
          ctx.lineTo(dim, 0);
        }
      }
      ctx.closePath();
      ctx[type]();
      ctx.restore();
    },
    /*
    Method: contains
    
    Returns *true* if *pos* is contained in the area of the shape. Returns *false* otherwise.
    
    Parameters:
    
    npos - (object) An *x*, *y* object with the <Graph.Node> position.
    pos - (object) An *x*, *y* object with the position to check.
    dim - (number) The length of a side of a concave decagon.
    
    Example:
    (start code js)
    NodeHelper.star.contains({ x: 10, y: 30 }, { x: 15, y: 35 }, 30);
    (end code)
    */
    'contains': function(npos, pos, dim) {
      return NodeHelper.circle.contains(npos, pos, dim);
    }
  }
};

/*
  Object: EdgeHelper
  
  Contains rendering primitives for simple edge shapes.
*/
var EdgeHelper = {
  /*
    Object: EdgeHelper.line
  */
  'line': {
      /*
      Method: render
      
      Renders a line into the canvas.
      
      Parameters:
      
      from - (object) An *x*, *y* object with the starting position of the line.
      to - (object) An *x*, *y* object with the ending position of the line.
      canvas - (object) A <Canvas> instance.
      
      Example:
      (start code js)
      EdgeHelper.line.render({ x: 10, y: 30 }, { x: 10, y: 50 }, viz.canvas);
      (end code)
      */
      'render': function(from, to, canvas){
        var ctx = canvas.getCtx();
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      },
      /*
      Method: contains
      
      Returns *true* if *pos* is contained in the area of the shape. Returns *false* otherwise.
      
      Parameters:
      
      posFrom - (object) An *x*, *y* object with a <Graph.Node> position.
      posTo - (object) An *x*, *y* object with a <Graph.Node> position.
      pos - (object) An *x*, *y* object with the position to check.
      epsilon - (number) The dimension of the shape.
      
      Example:
      (start code js)
      EdgeHelper.line.contains({ x: 10, y: 30 }, { x: 15, y: 35 }, { x: 15, y: 35 }, 30);
      (end code)
      */
      'contains': function(posFrom, posTo, pos, epsilon) {
        var min = Math.min, 
            max = Math.max,
            minPosX = min(posFrom.x, posTo.x),
            maxPosX = max(posFrom.x, posTo.x),
            minPosY = min(posFrom.y, posTo.y),
            maxPosY = max(posFrom.y, posTo.y);
          
        if(pos.x >= minPosX && pos.x <= maxPosX 
            && pos.y >= minPosY && pos.y <= maxPosY) {
          if(Math.abs(posTo.x - posFrom.x) <= epsilon) {
            
            return true;
          }
          var dist = (posTo.y - posFrom.y) / (posTo.x - posFrom.x) * (pos.x - posFrom.x) + posFrom.y;
            
          return Math.abs(dist - pos.y) <= epsilon;
        }
        return false;
      }
    },
  /*
    Object: EdgeHelper.arrow
  */
  'arrow': {
      /*
      Method: render
      
      Renders an arrow into the canvas.
      
      Parameters:
      
      from - (object) An *x*, *y* object with the starting position of the arrow.
      to - (object) An *x*, *y* object with the ending position of the arrow.
      dim - (number) The dimension of the arrow.
      swap - (boolean) Whether to set the arrow pointing to the starting position or the ending position.
      canvas - (object) A <Canvas> instance.
      
      Example:
      (start code js)
      EdgeHelper.arrow.render({ x: 10, y: 30 }, { x: 10, y: 50 }, 13, false, viz.canvas);
      (end code)
      */
    'render': function(from, to, dim, swap, canvas){
        var ctx = canvas.getCtx();
        // invert edge direction
        if (swap) {
          var tmp = from;
          from = to;
          to = tmp;
        }
        var vect = new Complex(to.x - from.x, to.y - from.y);
        vect.$scale(dim / vect.norm());
        var intermediatePoint = new Complex(to.x - vect.x, to.y - vect.y),
            normal = new Complex(-vect.y / 2, vect.x / 2),
            v1 = intermediatePoint.add(normal), 
            v2 = intermediatePoint.$add(normal.$scale(-1));
        
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(v1.x, v1.y);
        ctx.lineTo(v2.x, v2.y);
        ctx.lineTo(to.x, to.y);
        ctx.closePath();
        ctx.fill();
    },
    /*
    Method: contains
    
    Returns *true* if *pos* is contained in the area of the shape. Returns *false* otherwise.
    
    Parameters:
    
    posFrom - (object) An *x*, *y* object with a <Graph.Node> position.
    posTo - (object) An *x*, *y* object with a <Graph.Node> position.
    pos - (object) An *x*, *y* object with the position to check.
    epsilon - (number) The dimension of the shape.
    
    Example:
    (start code js)
    EdgeHelper.arrow.contains({ x: 10, y: 30 }, { x: 15, y: 35 }, { x: 15, y: 35 }, 30);
    (end code)
    */
    'contains': function(posFrom, posTo, pos, epsilon) {
      return EdgeHelper.line.contains(posFrom, posTo, pos, epsilon);
    }
  },
  /*
    Object: EdgeHelper.hyperline
  */
  'hyperline': {
    /*
    Method: render
    
    Renders a hyperline into the canvas. A hyperline are the lines drawn for the <Hypertree> visualization.
    
    Parameters:
    
    from - (object) An *x*, *y* object with the starting position of the hyperline. *x* and *y* must belong to [0, 1).
    to - (object) An *x*, *y* object with the ending position of the hyperline. *x* and *y* must belong to [0, 1).
    r - (number) The scaling factor.
    canvas - (object) A <Canvas> instance.
    
    Example:
    (start code js)
    EdgeHelper.hyperline.render({ x: 10, y: 30 }, { x: 10, y: 50 }, 100, viz.canvas);
    (end code)
    */
    'render': function(from, to, r, canvas){
      var ctx = canvas.getCtx();  
      var centerOfCircle = computeArcThroughTwoPoints(from, to);
      if (centerOfCircle.a > 1000 || centerOfCircle.b > 1000
          || centerOfCircle.ratio < 0) {
        ctx.beginPath();
        ctx.moveTo(from.x * r, from.y * r);
        ctx.lineTo(to.x * r, to.y * r);
        ctx.stroke();
      } else {
        var angleBegin = Math.atan2(to.y - centerOfCircle.y, to.x
            - centerOfCircle.x);
        var angleEnd = Math.atan2(from.y - centerOfCircle.y, from.x
            - centerOfCircle.x);
        var sense = sense(angleBegin, angleEnd);
        ctx.beginPath();
        ctx.arc(centerOfCircle.x * r, centerOfCircle.y * r, centerOfCircle.ratio
            * r, angleBegin, angleEnd, sense);
        ctx.stroke();
      }
      /*      
        Calculates the arc parameters through two points.
        
        More information in <http://en.wikipedia.org/wiki/Poincar%C3%A9_disc_model#Analytic_geometry_constructions_in_the_hyperbolic_plane> 
      
        Parameters:
      
        p1 - A <Complex> instance.
        p2 - A <Complex> instance.
        scale - The Disk's diameter.
      
        Returns:
      
        An object containing some arc properties.
      */
      function computeArcThroughTwoPoints(p1, p2){
        var aDen = (p1.x * p2.y - p1.y * p2.x), bDen = aDen;
        var sq1 = p1.squaredNorm(), sq2 = p2.squaredNorm();
        // Fall back to a straight line
        if (aDen == 0)
          return {
            x: 0,
            y: 0,
            ratio: -1
          };
    
        var a = (p1.y * sq2 - p2.y * sq1 + p1.y - p2.y) / aDen;
        var b = (p2.x * sq1 - p1.x * sq2 + p2.x - p1.x) / bDen;
        var x = -a / 2;
        var y = -b / 2;
        var squaredRatio = (a * a + b * b) / 4 - 1;
        // Fall back to a straight line
        if (squaredRatio < 0)
          return {
            x: 0,
            y: 0,
            ratio: -1
          };
        var ratio = Math.sqrt(squaredRatio);
        var out = {
          x: x,
          y: y,
          ratio: ratio > 1000? -1 : ratio,
          a: a,
          b: b
        };
    
        return out;
      }
      /*      
        Sets angle direction to clockwise (true) or counterclockwise (false). 
         
        Parameters: 
      
           angleBegin - Starting angle for drawing the arc. 
           angleEnd - The HyperLine will be drawn from angleBegin to angleEnd. 
      
        Returns: 
      
           A Boolean instance describing the sense for drawing the HyperLine. 
      */
      function sense(angleBegin, angleEnd){
        return (angleBegin < angleEnd)? ((angleBegin + Math.PI > angleEnd)? false
            : true) : ((angleEnd + Math.PI > angleBegin)? true : false);
      }
    },
    /*
    Method: contains
    
    Not Implemented
    
    Returns *true* if *pos* is contained in the area of the shape. Returns *false* otherwise.
    
    Parameters:
    
    posFrom - (object) An *x*, *y* object with a <Graph.Node> position.
    posTo - (object) An *x*, *y* object with a <Graph.Node> position.
    pos - (object) An *x*, *y* object with the position to check.
    epsilon - (number) The dimension of the shape.
    
    Example:
    (start code js)
    EdgeHelper.hyperline.contains({ x: 10, y: 30 }, { x: 15, y: 35 }, { x: 15, y: 35 }, 30);
    (end code)
    */
    'contains': $.lambda(false)
  }
};


/*
 * File: Graph.Plot.js
 */

/*
   Object: Graph.Plot

   <Graph> rendering and animation methods.
   
   Properties:
   
   nodeHelper - <NodeHelper> object.
   edgeHelper - <EdgeHelper> object.
*/
Graph.Plot = {
    //Default initializer
    initialize: function(viz, klass){
      this.viz = viz;
      this.config = viz.config;
      this.node = viz.config.Node;
      this.edge = viz.config.Edge;
      this.animation = new Animation;
      this.nodeTypes = new klass.Plot.NodeTypes;
      this.edgeTypes = new klass.Plot.EdgeTypes;
      this.labels = viz.labels;
   },

    //Add helpers
    nodeHelper: NodeHelper,
    edgeHelper: EdgeHelper,
    
    Interpolator: {
        //node/edge property parsers
        'map': {
          'border': 'color',
          'color': 'color',
          'width': 'number',
          'height': 'number',
          'dim': 'number',
          'alpha': 'number',
          'lineWidth': 'number',
          'angularWidth':'number',
          'span':'number',
          'valueArray':'array-number',
          'dimArray':'array-number'
          //'colorArray':'array-color'
        },
        
        //canvas specific parsers
        'canvas': {
          'globalAlpha': 'number',
          'fillStyle': 'color',
          'strokeStyle': 'color',
          'lineWidth': 'number',
          'shadowBlur': 'number',
          'shadowColor': 'color',
          'shadowOffsetX': 'number',
          'shadowOffsetY': 'number',
          'miterLimit': 'number'
        },
  
        //label parsers
        'label': {
          'size': 'number',
          'color': 'color'
        },
  
        //Number interpolator
        'compute': function(from, to, delta) {
          return from + (to - from) * delta;
        },
        
        //Position interpolators
        'moebius': function(elem, props, delta, vector) {
          var v = vector.scale(-delta);  
          if(v.norm() < 1) {
              var x = v.x, y = v.y;
              var ans = elem.startPos
                .getc().moebiusTransformation(v);
              elem.pos.setc(ans.x, ans.y);
              v.x = x; v.y = y;
            }           
        },

        'linear': function(elem, props, delta) {
            var from = elem.startPos.getc(true);
            var to = elem.endPos.getc(true);
            elem.pos.setc(this.compute(from.x, to.x, delta), 
                          this.compute(from.y, to.y, delta));
        },

        'polar': function(elem, props, delta) {
          var from = elem.startPos.getp(true);
          var to = elem.endPos.getp();
          var ans = to.interpolate(from, delta);
          elem.pos.setp(ans.theta, ans.rho);
        },
        
        //Graph's Node/Edge interpolators
        'number': function(elem, prop, delta, getter, setter) {
          var from = elem[getter](prop, 'start');
          var to = elem[getter](prop, 'end');
          elem[setter](prop, this.compute(from, to, delta));
        },

        'color': function(elem, prop, delta, getter, setter) {
          var from = $.hexToRgb(elem[getter](prop, 'start'));
          var to = $.hexToRgb(elem[getter](prop, 'end'));
          var comp = this.compute;
          var val = $.rgbToHex([parseInt(comp(from[0], to[0], delta)),
                                parseInt(comp(from[1], to[1], delta)),
                                parseInt(comp(from[2], to[2], delta))]);
          
          elem[setter](prop, val);
        },
        
        'array-number': function(elem, prop, delta, getter, setter) {
          var from = elem[getter](prop, 'start'),
              to = elem[getter](prop, 'end'),
              cur = [];
          for(var i=0, l=from.length; i<l; i++) {
            var fromi = from[i], toi = to[i];
            if(fromi.length) {
              for(var j=0, len=fromi.length, curi=[]; j<len; j++) {
                curi.push(this.compute(fromi[j], toi[j], delta));
              }
              cur.push(curi);
            } else {
              cur.push(this.compute(fromi, toi, delta));
            }
          }
          elem[setter](prop, cur);
        },
        
        'node': function(elem, props, delta, map, getter, setter) {
          map = this[map];
          if(props) {
            var len = props.length;
            for(var i=0; i<len; i++) {
              var pi = props[i];
              this[map[pi]](elem, pi, delta, getter, setter);
            }
          } else {
            for(var pi in map) {
              this[map[pi]](elem, pi, delta, getter, setter);
            }
          }
        },
        
        'edge': function(elem, props, delta, mapKey, getter, setter) {
            var adjs = elem.adjacencies;
            for(var id in adjs) this['node'](adjs[id], props, delta, mapKey, getter, setter);
        },
        
        'node-property': function(elem, props, delta) {
          this['node'](elem, props, delta, 'map', 'getData', 'setData');
        },
        
        'edge-property': function(elem, props, delta) {
          this['edge'](elem, props, delta, 'map', 'getData', 'setData');  
        },

        'label-property': function(elem, props, delta) {
          this['node'](elem, props, delta, 'label', 'getLabelData', 'setLabelData');
        },
        
        'node-style': function(elem, props, delta) {
          this['node'](elem, props, delta, 'canvas', 'getCanvasStyle', 'setCanvasStyle');
        },
        
        'edge-style': function(elem, props, delta) {
          this['edge'](elem, props, delta, 'canvas', 'getCanvasStyle', 'setCanvasStyle');  
        }
    },
    
  
    /*
       sequence
    
       Iteratively performs an action while refreshing the state of the visualization.

       Parameters:

       options - (object) An object containing some sequence options described below
       condition - (function) A function returning a boolean instance in order to stop iterations.
       step - (function) A function to execute on each step of the iteration.
       onComplete - (function) A function to execute when the sequence finishes.
       duration - (number) Duration (in milliseconds) of each step.

      Example:
       (start code js)
        var rg = new $jit.RGraph(options);
        var i = 0;
        rg.fx.sequence({
          condition: function() {
           return i == 10;
          },
          step: function() {
            alert(i++);
          },
          onComplete: function() {
           alert('done!');
          }
        });
       (end code)

    */
    sequence: function(options) {
        var that = this;
        options = $.merge({
          condition: $.lambda(false),
          step: $.empty,
          onComplete: $.empty,
          duration: 200
        }, options || {});

        var interval = setInterval(function() {
          if(options.condition()) {
            options.step();
          } else {
            clearInterval(interval);
            options.onComplete();
          }
          that.viz.refresh(true);
        }, options.duration);
    },
    
    /*
      prepare
 
      Prepare graph position and other attribute values before performing an Animation. 
      This method is used internally by the Toolkit.
      
      See also:
       
       <Animation>, <Graph.Plot.animate>

    */
    prepare: function(modes) {
      var graph = this.viz.graph,
          accessors = {
            'node-property': {
              'getter': 'getData',
              'setter': 'setData'
            },
            'edge-property': {
              'getter': 'getData',
              'setter': 'setData'
            },
            'node-style': {
              'getter': 'getCanvasStyle',
              'setter': 'setCanvasStyle'
            },
            'edge-style': {
              'getter': 'getCanvasStyle',
              'setter': 'setCanvasStyle'
            }
          };

      //parse modes
      var m = {};
      if($.type(modes) == 'array') {
        for(var i=0, len=modes.length; i < len; i++) {
          var elems = modes[i].split(':');
          m[elems.shift()] = elems;
        }
      } else {
        for(var p in modes) {
          if(p == 'position') {
            m[modes.position] = [];
          } else {
            m[p] = $.splat(modes[p]);
          }
        }
      }
      
      graph.eachNode(function(node) { 
        node.startPos.set(node.pos);
        $.each(['node-property', 'node-style'], function(p) {
          if(p in m) {
            var prop = m[p];
            for(var i=0, l=prop.length; i < l; i++) {
              node[accessors[p].setter](prop[i], node[accessors[p].getter](prop[i]), 'start');
            }
          }
        });
        $.each(['edge-property', 'edge-style'], function(p) {
          if(p in m) {
            var prop = m[p];
            node.eachAdjacency(function(adj) {
              for(var i=0, l=prop.length; i < l; i++) {
                adj[accessors[p].setter](prop[i], adj[accessors[p].getter](prop[i]), 'start');
              }
            });
          }
        });
      });
      return m;
    },
    
    /*
       Method: animate
    
       Animates a <Graph> by interpolating some <Graph.Node>, <Graph.Adjacence> or <Graph.Label> properties.

       Parameters:

       opt - (object) Animation options. The object properties are described below
       duration - (optional) Described in <Options.Fx>.
       fps - (optional) Described in <Options.Fx>.
       hideLabels - (optional|boolean) Whether to hide labels during the animation.
       modes - (required|object) An object with animation modes (described below).

       Animation modes:
       
       Animation modes are strings representing different node/edge and graph properties that you'd like to animate. 
       They are represented by an object that has as keys main categories of properties to animate and as values a list 
       of these specific properties. The properties are described below
       
       position - Describes the way nodes' positions must be interpolated. Possible values are 'linear', 'polar' or 'moebius'.
       node-property - Describes which Node properties will be interpolated. These properties can be any of the ones defined in <Options.Node>.
       edge-property - Describes which Edge properties will be interpolated. These properties can be any the ones defined in <Options.Edge>.
       label-property - Describes which Label properties will be interpolated. These properties can be any of the ones defined in <Options.Label> like color or size.
       node-style - Describes which Node Canvas Styles will be interpolated. These are specific canvas properties like fillStyle, strokeStyle, lineWidth, shadowBlur, shadowColor, shadowOffsetX, shadowOffsetY, etc.
       edge-style - Describes which Edge Canvas Styles will be interpolated. These are specific canvas properties like fillStyle, strokeStyle, lineWidth, shadowBlur, shadowColor, shadowOffsetX, shadowOffsetY, etc.

       Example:
       (start code js)
       var viz = new $jit.Viz(options);
       //...tweak some Data, CanvasStyles or LabelData properties...
       viz.fx.animate({
         modes: {
           'position': 'linear',
           'node-property': ['width', 'height'],
           'node-style': 'shadowColor',
           'label-property': 'size'
         },
         hideLabels: false
       });
       //...can also be written like this...
       viz.fx.animate({
         modes: ['linear',
                 'node-property:width:height',
                 'node-style:shadowColor',
                 'label-property:size'],
         hideLabels: false
       });
       (end code)
    */
    animate: function(opt, versor) {
      opt = $.merge(this.viz.config, opt || {});
      var that = this,
          viz = this.viz,
          graph  = viz.graph,
          interp = this.Interpolator,
          animation =  opt.type === 'nodefx'? this.nodeFxAnimation : this.animation;
      //prepare graph values
      var m = this.prepare(opt.modes);
      
      //animate
      if(opt.hideLabels) this.labels.hideLabels(true);
      animation.setOptions($.extend(opt, {
        $animating: false,
        compute: function(delta) {
          graph.eachNode(function(node) { 
            for(var p in m) {
              interp[p](node, m[p], delta, versor);
            }
          });
          that.plot(opt, this.$animating, delta);
          this.$animating = true;
        },
        complete: function() {
          if(opt.hideLabels) that.labels.hideLabels(false);
          that.plot(opt);
          opt.onComplete();
          //TODO(nico): This shouldn't be here!
          //opt.onAfterCompute();
        }       
      })).start();
    },
    
    /*
      nodeFx
   
      Apply animation to node properties like color, width, height, dim, etc.
  
      Parameters:
  
      options - Animation options. This object properties is described below
      elements - The Elements to be transformed. This is an object that has a properties
      
      (start code js)
      'elements': {
        //can also be an array of ids
        'id': 'id-of-node-to-transform',
        //properties to be modified. All properties are optional.
        'properties': {
          'color': '#ccc', //some color
          'width': 10, //some width
          'height': 10, //some height
          'dim': 20, //some dim
          'lineWidth': 10 //some line width
        } 
      }
      (end code)
      
      - _reposition_ Whether to recalculate positions and add a motion animation. 
      This might be used when changing _width_ or _height_ properties in a <Layouts.Tree> like layout. Default's *false*.
      
      - _onComplete_ A method that is called when the animation completes.
      
      ...and all other <Graph.Plot.animate> options like _duration_, _fps_, _transition_, etc.
  
      Example:
      (start code js)
       var rg = new RGraph(canvas, config); //can be also Hypertree or ST
       rg.fx.nodeFx({
         'elements': {
           'id':'mynodeid',
           'properties': {
             'color':'#ccf'
           },
           'transition': Trans.Quart.easeOut
         }
       });
      (end code)    
   */
   nodeFx: function(opt) {
     var viz = this.viz,
         graph  = viz.graph,
         animation = this.nodeFxAnimation,
         options = $.merge(this.viz.config, {
           'elements': {
             'id': false,
             'properties': {}
           },
           'reposition': false
         });
     opt = $.merge(options, opt || {}, {
       onBeforeCompute: $.empty,
       onAfterCompute: $.empty
     });
     //check if an animation is running
     animation.stopTimer();
     var props = opt.elements.properties;
     //set end values for nodes
     if(!opt.elements.id) {
       graph.eachNode(function(n) {
         for(var prop in props) {
           n.setData(prop, props[prop], 'end');
         }
       });
     } else {
       var ids = $.splat(opt.elements.id);
       $.each(ids, function(id) {
         var n = graph.getNode(id);
         if(n) {
           for(var prop in props) {
             n.setData(prop, props[prop], 'end');
           }
         }
       });
     }
     //get keys
     var propnames = [];
     for(var prop in props) propnames.push(prop);
     //add node properties modes
     var modes = ['node-property:' + propnames.join(':')];
     //set new node positions
     if(opt.reposition) {
       modes.push('linear');
       viz.compute('end');
     }
     //animate
     this.animate($.merge(opt, {
       modes: modes,
       type: 'nodefx'
     }));
   },

    
    /*
       Method: plot
    
       Plots a <Graph>.

       Parameters:

       opt - (optional) Plotting options. Most of them are described in <Options.Fx>.

       Example:

       (start code js)
       var viz = new $jit.Viz(options);
       viz.fx.plot(); 
       (end code)

    */
   plot: function(opt, animating) {
     var viz = this.viz, 
         aGraph = viz.graph, 
         canvas = viz.canvas, 
         id = viz.root, 
         that = this, 
         ctx = canvas.getCtx(), 
         min = Math.min,
         opt = opt || this.viz.controller;
     
     opt.clearCanvas && canvas.clear();
       
     var root = aGraph.getNode(id);
     if(!root) return;
     
     var T = !!root.visited;
    
    //START METAMAPS CODE
    if (Mapmaker.Mouse.synapseStartCoordinates.length > 0) {
        ctx.save();
        var start;
        var end = Mapmaker.Mouse.synapseEndCoordinates;
        
        var l = Mapmaker.Mouse.synapseStartCoordinates.length;
        for (var i = l - 1; i >= 0; i -= 1) {
            start = Mapmaker.Mouse.synapseStartCoordinates[i];
            Mapmaker.JIT.renderMidArrow(start, end, 13, false, canvas, 0.3, true);
            Mapmaker.JIT.renderMidArrow(start, end, 13, false, canvas, 0.7, true);
        }
        ctx.restore();
    }
    //END METAMAPS CODE  

     aGraph.eachNode(function(node) {
       var nodeAlpha = node.getData('alpha');
       node.eachAdjacency(function(adj) {
         var nodeTo = adj.nodeTo;
         if(!!nodeTo.visited === T && node.drawn && nodeTo.drawn) {
           !animating && opt.onBeforePlotLine(adj);
           that.plotLine(adj, canvas, animating);
           !animating && opt.onAfterPlotLine(adj);
         }
       });
       if(node.drawn) {
         !animating && opt.onBeforePlotNode(node);
         that.plotNode(node, canvas, animating);
         !animating && opt.onAfterPlotNode(node);
       }
       if(!that.labelsHidden && opt.withLabels) {
         if(node.drawn && nodeAlpha >= 0.95) {
           that.labels.plotLabel(canvas, node, opt);
         } else {
           that.labels.hideLabel(node, false);
         }
       }
       node.visited = !T;
     });
    },

  /*
      Plots a Subtree.
   */
   plotTree: function(node, opt, animating) {
       var that = this, 
       viz = this.viz, 
       canvas = viz.canvas,
       config = this.config,
       ctx = canvas.getCtx();
       var nodeAlpha = node.getData('alpha');
       node.eachSubnode(function(elem) {
         if(opt.plotSubtree(node, elem) && elem.exist && elem.drawn) {
             var adj = node.getAdjacency(elem.id);
             !animating && opt.onBeforePlotLine(adj);
             that.plotLine(adj, canvas, animating);
             !animating && opt.onAfterPlotLine(adj);
             that.plotTree(elem, opt, animating);
         }
       });
       if(node.drawn) {
           !animating && opt.onBeforePlotNode(node);
           this.plotNode(node, canvas, animating);
           !animating && opt.onAfterPlotNode(node);
           if(!opt.hideLabels && opt.withLabels && nodeAlpha >= 0.95) 
               this.labels.plotLabel(canvas, node, opt);
           else 
               this.labels.hideLabel(node, false);
       } else {
           this.labels.hideLabel(node, true);
       }
   },

  /*
       Method: plotNode
    
       Plots a <Graph.Node>.

       Parameters:
       
       node - (object) A <Graph.Node>.
       canvas - (object) A <Canvas> element.

    */
    plotNode: function(node, canvas, animating) {
        var f = node.getData('type'), 
            ctxObj = this.node.CanvasStyles;
        if(f != 'none') {
          var width = node.getData('lineWidth'),
              color = node.getData('color'),
              alpha = node.getData('alpha'),
              ctx = canvas.getCtx();
          ctx.save();
          ctx.lineWidth = width;
          ctx.fillStyle = ctx.strokeStyle = color;
          ctx.globalAlpha = alpha;
          
          for(var s in ctxObj) {
            ctx[s] = node.getCanvasStyle(s);
          }

          this.nodeTypes[f].render.call(this, node, canvas, animating);
          ctx.restore();
        }
    },
    
    /*
       Method: plotLine
    
       Plots a <Graph.Adjacence>.

       Parameters:

       adj - (object) A <Graph.Adjacence>.
       canvas - (object) A <Canvas> instance.

    */
    plotLine: function(adj, canvas, animating) {
      var f = adj.getData('type'),
          ctxObj = this.edge.CanvasStyles;
      if(f != 'none') {
        var width = adj.getData('lineWidth'),
            color = adj.getData('color'),
            ctx = canvas.getCtx(),
            nodeFrom = adj.nodeFrom,
            nodeTo = adj.nodeTo;
        
        ctx.save();
        ctx.lineWidth = width;
        ctx.fillStyle = ctx.strokeStyle = color;
        ctx.globalAlpha = Math.min(nodeFrom.getData('alpha'), 
            nodeTo.getData('alpha'), 
            adj.getData('alpha'));
        
        for(var s in ctxObj) {
          ctx[s] = adj.getCanvasStyle(s);
        }

        this.edgeTypes[f].render.call(this, adj, canvas, animating);
        ctx.restore();
      }
    }    
  
};

/*
  Object: Graph.Plot3D
  
  <Graph> 3D rendering and animation methods.
  
  Properties:
  
  nodeHelper - <NodeHelper> object.
  edgeHelper - <EdgeHelper> object.

*/
Graph.Plot3D = $.merge(Graph.Plot, {
  Interpolator: {
    'linear': function(elem, props, delta) {
      var from = elem.startPos.getc(true);
      var to = elem.endPos.getc(true);
      elem.pos.setc(this.compute(from.x, to.x, delta), 
                    this.compute(from.y, to.y, delta),
                    this.compute(from.z, to.z, delta));
    }
  },
  
  plotNode: function(node, canvas) {
    if(node.getData('type') == 'none') return;
    this.plotElement(node, canvas, {
      getAlpha: function() {
        return node.getData('alpha');
      }
    });
  },
  
  plotLine: function(adj, canvas) {
    if(adj.getData('type') == 'none') return;
    this.plotElement(adj, canvas, {
      getAlpha: function() {
        return Math.min(adj.nodeFrom.getData('alpha'),
                        adj.nodeTo.getData('alpha'),
                        adj.getData('alpha'));
      }
    });
  },
  
  plotElement: function(elem, canvas, opt) {
    var gl = canvas.getCtx(),
        viewMatrix = new Matrix4,
        lighting = canvas.config.Scene.Lighting,
        wcanvas = canvas.canvases[0],
        program = wcanvas.program,
        camera = wcanvas.camera;
    
    if(!elem.geometry) {
      elem.geometry = new O3D[elem.getData('type')];
    }
    elem.geometry.update(elem);
    if(!elem.webGLVertexBuffer) {
      var vertices = [],
          faces = [],
          normals = [],
          vertexIndex = 0,
          geom = elem.geometry;
      
      for(var i=0, vs=geom.vertices, fs=geom.faces, fsl=fs.length; i<fsl; i++) {
        var face = fs[i],
            v1 = vs[face.a],
            v2 = vs[face.b],
            v3 = vs[face.c],
            v4 = face.d? vs[face.d] : false,
            n = face.normal;
        
        vertices.push(v1.x, v1.y, v1.z);
        vertices.push(v2.x, v2.y, v2.z);
        vertices.push(v3.x, v3.y, v3.z);
        if(v4) vertices.push(v4.x, v4.y, v4.z);
            
        normals.push(n.x, n.y, n.z);
        normals.push(n.x, n.y, n.z);
        normals.push(n.x, n.y, n.z);
        if(v4) normals.push(n.x, n.y, n.z);
            
        faces.push(vertexIndex, vertexIndex +1, vertexIndex +2);
        if(v4) {
          faces.push(vertexIndex, vertexIndex +2, vertexIndex +3);
          vertexIndex += 4;
        } else {
          vertexIndex += 3;
        }
      }
      //create and store vertex data
      elem.webGLVertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, elem.webGLVertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      //create and store faces index data
      elem.webGLFaceBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elem.webGLFaceBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(faces), gl.STATIC_DRAW);
      elem.webGLFaceCount = faces.length;
      //calculate vertex normals and store them
      elem.webGLNormalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, elem.webGLNormalBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    }
    viewMatrix.multiply(camera.matrix, elem.geometry.matrix);
    //send matrix data
    gl.uniformMatrix4fv(program.viewMatrix, false, viewMatrix.flatten());
    gl.uniformMatrix4fv(program.projectionMatrix, false, camera.projectionMatrix.flatten());
    //send normal matrix for lighting
    var normalMatrix = Matrix4.makeInvert(viewMatrix);
    normalMatrix.$transpose();
    gl.uniformMatrix4fv(program.normalMatrix, false, normalMatrix.flatten());
    //send color data
    var color = $.hexToRgb(elem.getData('color'));
    color.push(opt.getAlpha());
    gl.uniform4f(program.color, color[0] / 255, color[1] / 255, color[2] / 255, color[3]);
    //send lighting data
    gl.uniform1i(program.enableLighting, lighting.enable);
    if(lighting.enable) {
      //set ambient light color
      if(lighting.ambient) {
        var acolor = lighting.ambient;
        gl.uniform3f(program.ambientColor, acolor[0], acolor[1], acolor[2]);
      }
      //set directional light
      if(lighting.directional) {
        var dir = lighting.directional,
            color = dir.color,
            pos = dir.direction,
            vd = new Vector3(pos.x, pos.y, pos.z).normalize().$scale(-1);
        gl.uniform3f(program.lightingDirection, vd.x, vd.y, vd.z);
        gl.uniform3f(program.directionalColor, color[0], color[1], color[2]);
      }
    }
    //send vertices data
    gl.bindBuffer(gl.ARRAY_BUFFER, elem.webGLVertexBuffer);
    gl.vertexAttribPointer(program.position, 3, gl.FLOAT, false, 0, 0);
    //send normals data
    gl.bindBuffer(gl.ARRAY_BUFFER, elem.webGLNormalBuffer);
    gl.vertexAttribPointer(program.normal, 3, gl.FLOAT, false, 0, 0);
    //draw!
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elem.webGLFaceBuffer );
    gl.drawElements(gl.TRIANGLES, elem.webGLFaceCount, gl.UNSIGNED_SHORT, 0);
  }
});


/*
 * File: Graph.Label.js
 *
*/

/*
   Object: Graph.Label

   An interface for plotting/hiding/showing labels.

   Description:

   This is a generic interface for plotting/hiding/showing labels.
   The <Graph.Label> interface is implemented in multiple ways to provide
   different label types.

   For example, the Graph.Label interface is implemented as <Graph.Label.HTML> to provide
   HTML label elements. Also we provide the <Graph.Label.SVG> interface for SVG type labels. 
   The <Graph.Label.Native> interface implements these methods with the native Canvas text rendering functions.
   
   All subclasses (<Graph.Label.HTML>, <Graph.Label.SVG> and <Graph.Label.Native>) implement the method plotLabel.
*/

Graph.Label = {};

/*
   Class: Graph.Label.Native

   Implements labels natively, using the Canvas text API.
*/
Graph.Label.Native = new Class({
    initialize: function(viz) {
      this.viz = viz;
    },

    /*
       Method: plotLabel

       Plots a label for a given node.

       Parameters:

       canvas - (object) A <Canvas> instance.
       node - (object) A <Graph.Node>.
       controller - (object) A configuration object.
       
       Example:
       
       (start code js)
       var viz = new $jit.Viz(options);
       var node = viz.graph.getNode('nodeId');
       viz.labels.plotLabel(viz.canvas, node, viz.config);
       (end code)
    */
    plotLabel: function(canvas, node, controller) {
      
      var ctx = canvas.getCtx();
      var pos = node.pos.getc(true);

      ctx.font = node.getLabelData('style') + ' ' + node.getLabelData('size') + 'px ' + node.getLabelData('family');
      ctx.textAlign = node.getLabelData('textAlign');
      // ORIGINAL CODE ctx.fillStyle = ctx.strokeStyle = node.getLabelData('color');
      ctx.textBaseline = node.getLabelData('textBaseline');
      
      //START METAMAPS CODE
      
      var arrayOfLabelLines = Mapmaker.Utility.splitLine(node.name,30).split('\n');
      //render background
            ctx.fillStyle = ctx.strokeStyle = Mapmaker.Settings.colors.labels.background;
            ctx.lineWidth = 2;
            var height = 25 * arrayOfLabelLines.length; //font size + margin
            
            var index, lineWidths = [];
            for (index = 0; index < arrayOfLabelLines.length; ++index) {
              lineWidths.push( ctx.measureText( arrayOfLabelLines[index] ).width )
            }
            var width = Math.max.apply(null, lineWidths) + 8;
            var x = pos.x - width/2;
            var y = pos.y + node.getData("height") + 5;
            var radius = 5;
            
              ctx.beginPath();
              ctx.moveTo(x + radius, y);
              ctx.lineTo(x + width - radius, y);
              ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
              ctx.lineTo(x + width, y + height - radius);
              ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
              ctx.lineTo(x + radius, y + height);
              ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
              ctx.lineTo(x, y + radius);
              ctx.quadraticCurveTo(x, y, x + radius, y);
              ctx.closePath();
              ctx.fill();
              //ctx.stroke();
       
       ctx.fillStyle = ctx.strokeStyle = node.getLabelData('color');

      this.renderLabel(arrayOfLabelLines, canvas, node, controller);
      // END METAMAPS CODE
      // ORIGINAL CODE  this.renderLabel(canvas, node, controller);
    },

    /*
       renderLabel

       Does the actual rendering of the label in the canvas. The default
       implementation renders the label close to the position of the node, this
       method should be overriden to position the labels differently.

       Parameters:

       canvas - A <Canvas> instance.
       node - A <Graph.Node>.
       controller - A configuration object. See also <Hypertree>, <RGraph>, <ST>.
    */
    renderLabel: function(customLabel, canvas, node, controller) {
      var ctx = canvas.getCtx();
      var pos = node.pos.getc(true);
      //ctx.fillText(node.name, pos.x, pos.y + node.getData("height") / 2);
      // START METAMAPS CODE
      var index;
      for (index = 0; index < customLabel.length; ++index) {
        ctx.fillText(customLabel[index], pos.x, pos.y + node.getData("height") + 23 + (25*index));
      }
      // END METAMAPS CODE
    },

    hideLabel: $.empty,
    hideLabels: $.empty
});

/*
   Class: Graph.Label.DOM

   Abstract Class implementing some DOM label methods.

   Implemented by:

   <Graph.Label.HTML> and <Graph.Label.SVG>.

*/
Graph.Label.DOM = new Class({
    //A flag value indicating if node labels are being displayed or not.
    labelsHidden: false,
    //Label container
    labelContainer: false,
    //Label elements hash.
    labels: {},

    /*
       Method: getLabelContainer

       Lazy fetcher for the label container.

       Returns:

       The label container DOM element.

       Example:

      (start code js)
        var viz = new $jit.Viz(options);
        var labelContainer = viz.labels.getLabelContainer();
        alert(labelContainer.innerHTML);
      (end code)
    */
    getLabelContainer: function() {
      return this.labelContainer ?
        this.labelContainer :
        this.labelContainer = document.getElementById(this.viz.config.labelContainer);
    },

    /*
       Method: getLabel

       Lazy fetcher for the label element.

       Parameters:

       id - (string) The label id (which is also a <Graph.Node> id).

       Returns:

       The label element.

       Example:

      (start code js)
        var viz = new $jit.Viz(options);
        var label = viz.labels.getLabel('someid');
        alert(label.innerHTML);
      (end code)

    */
    getLabel: function(id) {
      return (id in this.labels && this.labels[id] != null) ?
        this.labels[id] :
        this.labels[id] = document.getElementById(id);
    },

    /*
       Method: hideLabels

       Hides all labels (by hiding the label container).

       Parameters:

       hide - (boolean) A boolean value indicating if the label container must be hidden or not.

       Example:
       (start code js)
        var viz = new $jit.Viz(options);
        rg.labels.hideLabels(true);
       (end code)

    */
    hideLabels: function (hide) {
      var container = this.getLabelContainer();
      if(hide)
        container.style.display = 'none';
      else
        container.style.display = '';
      this.labelsHidden = hide;
    },

    /*
       Method: clearLabels

       Clears the label container.

       Useful when using a new visualization with the same canvas element/widget.

       Parameters:

       force - (boolean) Forces deletion of all labels.

       Example:
       (start code js)
        var viz = new $jit.Viz(options);
        viz.labels.clearLabels();
        (end code)
    */
    clearLabels: function(force) {
      for(var id in this.labels) {
        if (force || !this.viz.graph.hasNode(id)) {
          this.disposeLabel(id);
          delete this.labels[id];
        }
      }
    },

    /*
       Method: disposeLabel

       Removes a label.

       Parameters:

       id - (string) A label id (which generally is also a <Graph.Node> id).

       Example:
       (start code js)
        var viz = new $jit.Viz(options);
        viz.labels.disposeLabel('labelid');
       (end code)
    */
    disposeLabel: function(id) {
      var elem = this.getLabel(id);
      if(elem && elem.parentNode) {
        elem.parentNode.removeChild(elem);
      }
    },

    /*
       Method: hideLabel

       Hides the corresponding <Graph.Node> label.

       Parameters:

       node - (object) A <Graph.Node>. Can also be an array of <Graph.Nodes>.
       show - (boolean) If *true*, nodes will be shown. Otherwise nodes will be hidden.

       Example:
       (start code js)
        var rg = new $jit.Viz(options);
        viz.labels.hideLabel(viz.graph.getNode('someid'), false);
       (end code)
    */
    hideLabel: function(node, show) {
      node = $.splat(node);
      var st = show ? "" : "none", lab, that = this;
      $.each(node, function(n) {
        var lab = that.getLabel(n.id);
        if (lab) {
          lab.style.display = st;
        }
      });
    },

    /*
       fitsInCanvas

       Returns _true_ or _false_ if the label for the node is contained in the canvas dom element or not.

       Parameters:

       pos - A <Complex> instance (I'm doing duck typing here so any object with _x_ and _y_ parameters will do).
       canvas - A <Canvas> instance.

       Returns:

       A boolean value specifying if the label is contained in the <Canvas> DOM element or not.

    */
    fitsInCanvas: function(pos, canvas) {
      var size = canvas.getSize();
      if(pos.x >= size.width || pos.x < 0
         || pos.y >= size.height || pos.y < 0) return false;
       return true;
    }
});

/*
   Class: Graph.Label.HTML

   Implements HTML labels.

   Extends:

   All <Graph.Label.DOM> methods.

*/
Graph.Label.HTML = new Class({
    Implements: Graph.Label.DOM,

    /*
       Method: plotLabel

       Plots a label for a given node.

       Parameters:

       canvas - (object) A <Canvas> instance.
       node - (object) A <Graph.Node>.
       controller - (object) A configuration object.
       
      Example:
       
       (start code js)
       var viz = new $jit.Viz(options);
       var node = viz.graph.getNode('nodeId');
       viz.labels.plotLabel(viz.canvas, node, viz.config);
       (end code)


    */
    plotLabel: function(canvas, node, controller) {
      var id = node.id, tag = this.getLabel(id);

      if(!tag && !(tag = document.getElementById(id))) {
        tag = document.createElement('div');
        var container = this.getLabelContainer();
        tag.id = id;
        tag.className = 'node';
        tag.style.position = 'absolute';
        controller.onCreateLabel(tag, node);
        container.appendChild(tag);
        this.labels[node.id] = tag;
      }

      this.placeLabel(tag, node, controller);
    }
});

/*
   Class: Graph.Label.SVG

   Implements SVG labels.

   Extends:

   All <Graph.Label.DOM> methods.
*/
Graph.Label.SVG = new Class({
    Implements: Graph.Label.DOM,

    /*
       Method: plotLabel

       Plots a label for a given node.

       Parameters:

       canvas - (object) A <Canvas> instance.
       node - (object) A <Graph.Node>.
       controller - (object) A configuration object.
       
       Example:
       
       (start code js)
       var viz = new $jit.Viz(options);
       var node = viz.graph.getNode('nodeId');
       viz.labels.plotLabel(viz.canvas, node, viz.config);
       (end code)


    */
    plotLabel: function(canvas, node, controller) {
      var id = node.id, tag = this.getLabel(id);
      if(!tag && !(tag = document.getElementById(id))) {
        var ns = 'http://www.w3.org/2000/svg';
          tag = document.createElementNS(ns, 'svg:text');
        var tspan = document.createElementNS(ns, 'svg:tspan');
        tag.appendChild(tspan);
        var container = this.getLabelContainer();
        tag.setAttribute('id', id);
        tag.setAttribute('class', 'node');
        container.appendChild(tag);
        controller.onCreateLabel(tag, node);
        this.labels[node.id] = tag;
      }
      this.placeLabel(tag, node, controller);
    }
});



/*
 * File: Loader.js
 * 
 */

/*
   Object: Loader

   Provides methods for loading and serving JSON data.
*/
var Loader = {
     construct: function(json) {
        var isGraph = ($.type(json) == 'array');
        var ans = new Graph(this.graphOptions, this.config.Node, this.config.Edge, this.config.Label);
        if(!isGraph) 
            //make tree
            (function (ans, json) {
                ans.addNode(json);
                if(json.children) {
                  for(var i=0, ch = json.children; i<ch.length; i++) {
                    ans.addAdjacence(json, ch[i]);
                    arguments.callee(ans, ch[i]);
                  }
                }
            })(ans, json);
        else
            //make graph
            (function (ans, json) {
                var getNode = function(id) {
                  for(var i=0, l=json.length; i<l; i++) {
                    if(json[i].id == id) {
                      return json[i];
                    }
                  }
                  // The node was not defined in the JSON
                  // Let's create it
                  var newNode = {
                		"id" : id,
                		"name" : id
                	};
                  return ans.addNode(newNode);
                };

                for(var i=0, l=json.length; i<l; i++) {
                  ans.addNode(json[i]);
                  var adj = json[i].adjacencies;
                  if (adj) {
                    for(var j=0, lj=adj.length; j<lj; j++) {
                      var node = adj[j], data = {};
                      if(typeof adj[j] != 'string') {
                        data = $.merge(node.data, {});
                        node = node.nodeTo;
                      }
                      ans.addAdjacence(json[i], getNode(node), data);
                    }
                  }
                }
            })(ans, json);

        return ans;
    },

    /*
     Method: loadJSON
    
     Loads a JSON structure to the visualization. The JSON structure can be a JSON *tree* or *graph* structure.
     
      A JSON tree or graph structure consists of nodes, each having as properties
       
       id - (string) A unique identifier for the node
       name - (string) A node's name
       data - (object) The data optional property contains a hash (i.e {}) 
       where you can store all the information you want about this node.
        
      For JSON *Tree* structures, there's an extra optional property *children* of type Array which contains the node's children.
      
      Example:

      (start code js)
        var json = {  
          "id": "aUniqueIdentifier",  
          "name": "usually a nodes name",  
          "data": {
            "some key": "some value",
            "some other key": "some other value"
           },  
          "children": [ *other nodes or empty* ]  
        };  
      (end code)
        
        JSON *Graph* structures consist of an array of nodes, each specifying the nodes to which the current node is connected. 
        For JSON *Graph* structures, the *children* property is replaced by the *adjacencies* property.
        
        There are two types of *Graph* structures, *simple* and *extended* graph structures.
        
        For *simple* Graph structures, the adjacencies property contains an array of strings, each specifying the 
        id of the node connected to the main node.
        
        Example:
        
        (start code js)
        var json = [  
          {  
            "id": "aUniqueIdentifier",  
            "name": "usually a nodes name",  
            "data": {
              "some key": "some value",
              "some other key": "some other value"
             },  
            "adjacencies": ["anotherUniqueIdentifier", "yetAnotherUniqueIdentifier", 'etc']  
          },

          'other nodes go here...' 
        ];          
        (end code)
        
        For *extended Graph structures*, the adjacencies property contains an array of Adjacency objects that have as properties
        
        nodeTo - (string) The other node connected by this adjacency.
        data - (object) A data property, where we can store custom key/value information.
        
        Example:
        
        (start code js)
        var json = [  
          {  
            "id": "aUniqueIdentifier",  
            "name": "usually a nodes name",  
            "data": {
              "some key": "some value",
              "some other key": "some other value"
             },  
            "adjacencies": [  
            {  
              nodeTo:"aNodeId",  
              data: {} //put whatever you want here  
            },
            'other adjacencies go here...'  
          },

          'other nodes go here...' 
        ];          
        (end code)
       
       About the data property:
       
       As described before, you can store custom data in the *data* property of JSON *nodes* and *adjacencies*. 
       You can use almost any string as key for the data object. Some keys though are reserved by the toolkit, and 
       have special meanings. This is the case for keys starting with a dollar sign, for example, *$width*.
       
       For JSON *node* objects, adding dollar prefixed properties that match the names of the options defined in 
       <Options.Node> will override the general value for that option with that particular value. For this to work 
       however, you do have to set *overridable = true* in <Options.Node>.
       
       The same thing is true for JSON adjacencies. Dollar prefixed data properties will alter values set in <Options.Edge> 
       if <Options.Edge> has *overridable = true*.
       
       When loading JSON data into TreeMaps, the *data* property must contain a value for the *$area* key, 
       since this is the value which will be taken into account when creating the layout. 
       The same thing goes for the *$color* parameter.
       
       In JSON Nodes you can use also *$label-* prefixed properties to refer to <Options.Label> properties. For example, 
       *$label-size* will refer to <Options.Label> size property. Also, in JSON nodes and adjacencies you can set 
       canvas specific properties individually by using the *$canvas-* prefix. For example, *$canvas-shadowBlur* will refer 
       to the *shadowBlur* property.
       
       These properties can also be accessed after loading the JSON data from <Graph.Nodes> and <Graph.Adjacences> 
       by using <Accessors>. For more information take a look at the <Graph> and <Accessors> documentation.
       
       Finally, these properties can also be used to create advanced animations like with <Options.NodeStyles>. For more 
       information about creating animations please take a look at the <Graph.Plot> and <Graph.Plot.animate> documentation.
       
       loadJSON Parameters:
    
        json - A JSON Tree or Graph structure.
        i - For Graph structures only. Sets the indexed node as root for the visualization.

    */
    loadJSON: function(json, i) {
      this.json = json;
      //if they're canvas labels erase them.
      if(this.labels && this.labels.clearLabels) {
        this.labels.clearLabels(true);
      }
      this.graph = this.construct(json);
      if($.type(json) != 'array'){
        this.root = json.id;
      } else {
        this.root = json[i? i : 0].id;
      }
    },
    
    /*
      Method: toJSON
   
      Returns a JSON tree/graph structure from the visualization's <Graph>. 
      See <Loader.loadJSON> for the graph formats available.
      
      See also:
      
      <Loader.loadJSON>
      
      Parameters:
      
      type - (string) Default's "tree". The type of the JSON structure to be returned. 
      Possible options are "tree" or "graph".
    */    
    toJSON: function(type) {
      type = type || "tree";
      if(type == 'tree') {
        var ans = {};
        var rootNode = this.graph.getNode(this.root);
        var ans = (function recTree(node) {
          var ans = {};
          ans.id = node.id;
          ans.name = node.name;
          ans.data = node.data;
          var ch =[];
          node.eachSubnode(function(n) {
            ch.push(recTree(n));
          });
          ans.children = ch;
          return ans;
        })(rootNode);
        return ans;
      } else {
        var ans = [];
        var T = !!this.graph.getNode(this.root).visited;
        this.graph.eachNode(function(node) {
          var ansNode = {};
          ansNode.id = node.id;
          ansNode.name = node.name;
          ansNode.data = node.data;
          var adjs = [];
          node.eachAdjacency(function(adj) {
            var nodeTo = adj.nodeTo;
            if(!!nodeTo.visited === T) {
              var ansAdj = {};
              ansAdj.nodeTo = nodeTo.id;
              ansAdj.data = adj.data;
              adjs.push(ansAdj);
            }
          });
          ansNode.adjacencies = adjs;
          ans.push(ansNode);
          node.visited = !T;
        });
        return ans;
      }
    }
};



/*
 * File: Layouts.js
 * 
 * Implements base Tree and Graph layouts.
 *
 * Description:
 *
 * Implements base Tree and Graph layouts like Radial, Tree, etc.
 * 
 */

/*
 * Object: Layouts
 * 
 * Parent object for common layouts.
 *
 */
var Layouts = $jit.Layouts = {};


//Some util shared layout functions are defined here.
var NodeDim = {
  label: null,
  
  compute: function(graph, prop, opt) {
    this.initializeLabel(opt);
    var label = this.label, style = label.style;
    graph.eachNode(function(n) {
      var autoWidth  = n.getData('autoWidth'),
          autoHeight = n.getData('autoHeight');
      if(autoWidth || autoHeight) {
        //delete dimensions since these are
        //going to be overridden now.
        delete n.data.$width;
        delete n.data.$height;
        delete n.data.$dim;
        
        var width  = n.getData('width'),
            height = n.getData('height');
        //reset label dimensions
        style.width  = autoWidth? 'auto' : width + 'px';
        style.height = autoHeight? 'auto' : height + 'px';
        
        //TODO(nico) should let the user choose what to insert here.
        label.innerHTML = n.name;
        
        var offsetWidth  = label.offsetWidth,
            offsetHeight = label.offsetHeight;
        var type = n.getData('type');
        if($.indexOf(['circle', 'square', 'triangle', 'star'], type) === -1) {
          n.setData('width', offsetWidth);
          n.setData('height', offsetHeight);
        } else {
          var dim = offsetWidth > offsetHeight? offsetWidth : offsetHeight;
          n.setData('width', dim);
          n.setData('height', dim);
          n.setData('dim', dim); 
        }
      }
    });
  },
  
  initializeLabel: function(opt) {
    if(!this.label) {
      this.label = document.createElement('div');
      document.body.appendChild(this.label);
    }
    this.setLabelStyles(opt);
  },
  
  setLabelStyles: function(opt) {
    $.extend(this.label.style, {
      'visibility': 'hidden',
      'position': 'absolute',
      'width': 'auto',
      'height': 'auto'
    });
    this.label.className = 'jit-autoadjust-label';
  }
};


/*
 * Class: Layouts.Radial
 * 
 * Implements a Radial Layout.
 * 
 * Implemented By:
 * 
 * <RGraph>, <Hypertree>
 * 
 */
Layouts.Radial = new Class({

  /*
   * Method: compute
   * 
   * Computes nodes' positions.
   * 
   * Parameters:
   * 
   * property - _optional_ A <Graph.Node> position property to store the new
   * positions. Possible values are 'pos', 'end' or 'start'.
   * 
   */
  compute : function(property) {
    var prop = $.splat(property || [ 'current', 'start', 'end' ]);
    NodeDim.compute(this.graph, prop, this.config);
    this.graph.computeLevels(this.root, 0, "ignore");
    var lengthFunc = this.createLevelDistanceFunc(); 
    this.computeAngularWidths(prop);
    this.computePositions(prop, lengthFunc);
  },

  /*
   * computePositions
   * 
   * Performs the main algorithm for computing node positions.
   */
  computePositions : function(property, getLength) {
    var propArray = property;
    var graph = this.graph;
    var root = graph.getNode(this.root);
    var parent = this.parent;
    var config = this.config;

    for ( var i=0, l=propArray.length; i < l; i++) {
      var pi = propArray[i];
      root.setPos($P(0, 0), pi);
      root.setData('span', Math.PI * 2, pi);
    }

    root.angleSpan = {
      begin : 0,
      end : 2 * Math.PI
    };

    graph.eachBFS(this.root, function(elem) {
      var angleSpan = elem.angleSpan.end - elem.angleSpan.begin;
      var angleInit = elem.angleSpan.begin;
      var len = getLength(elem);
      //Calculate the sum of all angular widths
      var totalAngularWidths = 0, subnodes = [], maxDim = {};
      elem.eachSubnode(function(sib) {
        totalAngularWidths += sib._treeAngularWidth;
        //get max dim
        for ( var i=0, l=propArray.length; i < l; i++) {
          var pi = propArray[i], dim = sib.getData('dim', pi);
          maxDim[pi] = (pi in maxDim)? (dim > maxDim[pi]? dim : maxDim[pi]) : dim;
        }
        subnodes.push(sib);
      }, "ignore");
      //Maintain children order
      //Second constraint for <http://bailando.sims.berkeley.edu/papers/infovis01.htm>
      if (parent && parent.id == elem.id && subnodes.length > 0
          && subnodes[0].dist) {
        subnodes.sort(function(a, b) {
          return (a.dist >= b.dist) - (a.dist <= b.dist);
        });
      }
      //Calculate nodes positions.
      for (var k = 0, ls=subnodes.length; k < ls; k++) {
        var child = subnodes[k];
        if (!child._flag) {
          var angleProportion = child._treeAngularWidth / totalAngularWidths * angleSpan;
          var theta = angleInit + angleProportion / 2;

          for ( var i=0, l=propArray.length; i < l; i++) {
            var pi = propArray[i];
            child.setPos($P(theta, len), pi);
            child.setData('span', angleProportion, pi);
            child.setData('dim-quotient', child.getData('dim', pi) / maxDim[pi], pi);
          }

          child.angleSpan = {
            begin : angleInit,
            end : angleInit + angleProportion
          };
          angleInit += angleProportion;
        }
      }
    }, "ignore");
  },

  /*
   * Method: setAngularWidthForNodes
   * 
   * Sets nodes angular widths.
   */
  setAngularWidthForNodes : function(prop) {
    this.graph.eachBFS(this.root, function(elem, i) {
      var diamValue = elem.getData('angularWidth', prop[0]) || 5;
      elem._angularWidth = diamValue / i;
    }, "ignore");
  },

  /*
   * Method: setSubtreesAngularWidth
   * 
   * Sets subtrees angular widths.
   */
  setSubtreesAngularWidth : function() {
    var that = this;
    this.graph.eachNode(function(elem) {
      that.setSubtreeAngularWidth(elem);
    }, "ignore");
  },

  /*
   * Method: setSubtreeAngularWidth
   * 
   * Sets the angular width for a subtree.
   */
  setSubtreeAngularWidth : function(elem) {
    var that = this, nodeAW = elem._angularWidth, sumAW = 0;
    elem.eachSubnode(function(child) {
      that.setSubtreeAngularWidth(child);
      sumAW += child._treeAngularWidth;
    }, "ignore");
    elem._treeAngularWidth = Math.max(nodeAW, sumAW);
  },

  /*
   * Method: computeAngularWidths
   * 
   * Computes nodes and subtrees angular widths.
   */
  computeAngularWidths : function(prop) {
    this.setAngularWidthForNodes(prop);
    this.setSubtreesAngularWidth();
  }

});


/*
 * File: RGraph.js
 *
 */

/*
   Class: RGraph
   
   A radial graph visualization with advanced animations.
   
   Inspired by:
 
   Animated Exploration of Dynamic Graphs with Radial Layout (Ka-Ping Yee, Danyel Fisher, Rachna Dhamija, Marti Hearst) <http://bailando.sims.berkeley.edu/papers/infovis01.htm>
   
   Note:
   
   This visualization was built and engineered from scratch, taking only the paper as inspiration, and only shares some features with the visualization described in the paper.
   
  Implements:
  
  All <Loader> methods
  
   Constructor Options:
   
   Inherits options from
   
   - <Options.Canvas>
   - <Options.Controller>
   - <Options.Node>
   - <Options.Edge>
   - <Options.Label>
   - <Options.Events>
   - <Options.Tips>
   - <Options.NodeStyles>
   - <Options.Navigation>
   
   Additionally, there are other parameters and some default values changed
   
   interpolation - (string) Default's *linear*. Describes the way nodes are interpolated. Possible values are 'linear' and 'polar'.
   levelDistance - (number) Default's *100*. The distance between levels of the tree. 
     
   Instance Properties:

   canvas - Access a <Canvas> instance.
   graph - Access a <Graph> instance.
   op - Access a <RGraph.Op> instance.
   fx - Access a <RGraph.Plot> instance.
   labels - Access a <RGraph.Label> interface implementation.   
*/

$jit.RGraph = new Class( {

  Implements: [
      Loader, Extras, Layouts.Radial
  ],

  initialize: function(controller){
    var $RGraph = $jit.RGraph;

    var config = {
      interpolation: 'linear',
      levelDistance: 100
    };

    this.controller = this.config = $.merge(Options("Canvas", "Node", "Edge",
        "Fx", "Controller", "Tips", "NodeStyles", "Events", "Navigation", "Label"), config, controller);

    var canvasConfig = this.config;
    if(canvasConfig.useCanvas) {
      this.canvas = canvasConfig.useCanvas;
      this.config.labelContainer = this.canvas.id + '-label';
    } else {
      if(canvasConfig.background) {
        canvasConfig.background = $.merge({
          type: 'Circles'
        }, canvasConfig.background);
      }
      this.canvas = new Canvas(this, canvasConfig);
      this.config.labelContainer = (typeof canvasConfig.injectInto == 'string'? canvasConfig.injectInto : canvasConfig.injectInto.id) + '-label';
    }

    this.graphOptions = {
      'klass': Polar,
      'Node': {
        'selected': false,
        'exist': true,
        'drawn': true
      }
    };
    this.graph = new Graph(this.graphOptions, this.config.Node,
        this.config.Edge);
    this.labels = new $RGraph.Label[canvasConfig.Label.type](this);
    this.fx = new $RGraph.Plot(this, $RGraph);
    this.op = new $RGraph.Op(this);
    this.json = null;
    this.root = null;
    this.busy = false;
    this.parent = false;
    // initialize extras
    this.initializeExtras();
  },

  /* 
  
    createLevelDistanceFunc 
  
    Returns the levelDistance function used for calculating a node distance 
    to its origin. This function returns a function that is computed 
    per level and not per node, such that all nodes with the same depth will have the 
    same distance to the origin. The resulting function gets the 
    parent node as parameter and returns a float.

   */
  createLevelDistanceFunc: function(){
    var ld = this.config.levelDistance;
    return function(elem){
      return (elem._depth + 1) * ld;
    };
  },

  /* 
     Method: refresh 
     
     Computes positions and plots the tree.

   */
  refresh: function(){
    
    // START METAMAPS CODE
    // this.compute();
    // END METAMAPS CODE
    // ORIGINAL CODE: this.compute();
    this.plot();
  },

  reposition: function(){
    this.compute('end');
  },

  /*
   Method: plot
  
   Plots the RGraph. This is a shortcut to *fx.plot*.
  */
  plot: function(){
    this.fx.plot();
  },
  /*
   getNodeAndParentAngle
  
   Returns the _parent_ of the given node, also calculating its angle span.
  */
  getNodeAndParentAngle: function(id){
    var theta = false;
    var n = this.graph.getNode(id);
    var ps = n.getParents();
    var p = (ps.length > 0)? ps[0] : false;
    if (p) {
      var posParent = p.pos.getc(), posChild = n.pos.getc();
      var newPos = posParent.add(posChild.scale(-1));
      theta = Math.atan2(newPos.y, newPos.x);
      if (theta < 0)
        theta += 2 * Math.PI;
    }
    return {
      parent: p,
      theta: theta
    };
  },
  /*
   tagChildren
  
   Enumerates the children in order to maintain child ordering (second constraint of the paper).
  */
  tagChildren: function(par, id){
    if (par.angleSpan) {
      var adjs = [];
      par.eachAdjacency(function(elem){
        adjs.push(elem.nodeTo);
      }, "ignore");
      var len = adjs.length;
      for ( var i = 0; i < len && id != adjs[i].id; i++)
        ;
      for ( var j = (i + 1) % len, k = 0; id != adjs[j].id; j = (j + 1) % len) {
        adjs[j].dist = k++;
      }
    }
  },
  /* 
  Method: onClick 
  
  Animates the <RGraph> to center the node specified by *id*.

   Parameters:

   id - A <Graph.Node> id.
   opt - (optional|object) An object containing some extra properties described below
   hideLabels - (boolean) Default's *true*. Hide labels when performing the animation.

   Example:

   (start code js)
     rgraph.onClick('someid');
     //or also...
     rgraph.onClick('someid', {
      hideLabels: false
     });
    (end code)
    
  */
  onClick: function(id, opt){
    if (this.root != id && !this.busy) {
      this.busy = true;
      this.root = id;
      var that = this;
      this.controller.onBeforeCompute(this.graph.getNode(id));
      var obj = this.getNodeAndParentAngle(id);

      // second constraint
      this.tagChildren(obj.parent, id);
      this.parent = obj.parent;
      this.compute('end');

      // first constraint
      var thetaDiff = obj.theta - obj.parent.endPos.theta;
      this.graph.eachNode(function(elem){
        elem.endPos.set(elem.endPos.getp().add($P(thetaDiff, 0)));
      });

      var mode = this.config.interpolation;
      opt = $.merge( {
        onComplete: $.empty
      }, opt || {});

      this.fx.animate($.merge( {
        hideLabels: true,
        modes: [
          mode
        ]
      }, opt, {
        onComplete: function(){
          that.busy = false;
          opt.onComplete();
        }
      }));
    }
  }
});

$jit.RGraph.$extend = true;

(function(RGraph){

  /*
     Class: RGraph.Op
     
     Custom extension of <Graph.Op>.

     Extends:

     All <Graph.Op> methods
     
     See also:
     
     <Graph.Op>

  */
  RGraph.Op = new Class( {

    Implements: Graph.Op

  });

  /*
     Class: RGraph.Plot
    
    Custom extension of <Graph.Plot>.
  
    Extends:
  
    All <Graph.Plot> methods
    
    See also:
    
    <Graph.Plot>
  
  */
  RGraph.Plot = new Class( {

    Implements: Graph.Plot

  });

  /*
    Object: RGraph.Label

    Custom extension of <Graph.Label>. 
    Contains custom <Graph.Label.SVG>, <Graph.Label.HTML> and <Graph.Label.Native> extensions.
  
    Extends:
  
    All <Graph.Label> methods and subclasses.
  
    See also:
  
    <Graph.Label>, <Graph.Label.Native>, <Graph.Label.HTML>, <Graph.Label.SVG>.
  
   */
  RGraph.Label = {};

  /*
     RGraph.Label.Native

     Custom extension of <Graph.Label.Native>.

     Extends:

     All <Graph.Label.Native> methods

     See also:

     <Graph.Label.Native>

  */
  RGraph.Label.Native = new Class( {
    Implements: Graph.Label.Native
  });

  /*
     RGraph.Label.SVG
    
    Custom extension of <Graph.Label.SVG>.
  
    Extends:
  
    All <Graph.Label.SVG> methods
  
    See also:
  
    <Graph.Label.SVG>
  
  */
  RGraph.Label.SVG = new Class( {
    Implements: Graph.Label.SVG,

    initialize: function(viz){
      this.viz = viz;
    },

    /* 
       placeLabel

       Overrides abstract method placeLabel in <Graph.Plot>.

       Parameters:

       tag - A DOM label element.
       node - A <Graph.Node>.
       controller - A configuration/controller object passed to the visualization.
      
     */
    placeLabel: function(tag, node, controller){
      var pos = node.pos.getc(true), 
          canvas = this.viz.canvas,
          ox = canvas.translateOffsetX,
          oy = canvas.translateOffsetY,
          sx = canvas.scaleOffsetX,
          sy = canvas.scaleOffsetY,
          radius = canvas.getSize();
      var labelPos = {
        x: Math.round(pos.x * sx + ox + radius.width / 2),
        y: Math.round(pos.y * sy + oy + radius.height / 2)
      };
      tag.setAttribute('x', labelPos.x);
      tag.setAttribute('y', labelPos.y);

      controller.onPlaceLabel(tag, node);
    }
  });

  /*
     RGraph.Label.HTML

     Custom extension of <Graph.Label.HTML>.

     Extends:

     All <Graph.Label.HTML> methods.

     See also:

     <Graph.Label.HTML>

  */
  RGraph.Label.HTML = new Class( {
    Implements: Graph.Label.HTML,

    initialize: function(viz){
      this.viz = viz;
    },
    /* 
       placeLabel

       Overrides abstract method placeLabel in <Graph.Plot>.

       Parameters:

       tag - A DOM label element.
       node - A <Graph.Node>.
       controller - A configuration/controller object passed to the visualization.
      
     */
    placeLabel: function(tag, node, controller){
      var pos = node.pos.getc(true), 
          canvas = this.viz.canvas,
          ox = canvas.translateOffsetX,
          oy = canvas.translateOffsetY,
          sx = canvas.scaleOffsetX,
          sy = canvas.scaleOffsetY,
          radius = canvas.getSize();
      var labelPos = {
        x: Math.round(pos.x * sx + ox + radius.width / 2),
        y: Math.round(pos.y * sy + oy + radius.height / 2)
      };

      var style = tag.style;
      style.left = labelPos.x + 'px';
      style.top = labelPos.y + 'px';
      style.display = this.fitsInCanvas(labelPos, canvas)? '' : 'none';

      controller.onPlaceLabel(tag, node);
    }
  });

  /*
    Class: RGraph.Plot.NodeTypes

    This class contains a list of <Graph.Node> built-in types. 
    Node types implemented are 'none', 'circle', 'triangle', 'rectangle', 'star', 'ellipse' and 'square'.

    You can add your custom node types, customizing your visualization to the extreme.

    Example:

    (start code js)
      RGraph.Plot.NodeTypes.implement({
        'mySpecialType': {
          'render': function(node, canvas) {
            //print your custom node to canvas
          },
          //optional
          'contains': function(node, pos) {
            //return true if pos is inside the node or false otherwise
          }
        }
      });
    (end code)

  */
  RGraph.Plot.NodeTypes = new Class({
    'none': {
      'render': $.empty,
      'contains': $.lambda(false)
    },
    'circle': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            dim = node.getData('dim');
        this.nodeHelper.circle.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            dim = node.getData('dim');
        return this.nodeHelper.circle.contains(npos, pos, dim);
      }
    },
    'ellipse': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        this.nodeHelper.ellipse.render('fill', pos, width, height, canvas);
        },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        return this.nodeHelper.ellipse.contains(npos, pos, width, height);
      }
    },
    'square': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            dim = node.getData('dim');
        this.nodeHelper.square.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            dim = node.getData('dim');
        return this.nodeHelper.square.contains(npos, pos, dim);
      }
    },
    'rectangle': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        this.nodeHelper.rectangle.render('fill', pos, width, height, canvas);
      },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        return this.nodeHelper.rectangle.contains(npos, pos, width, height);
      }
    },
    'triangle': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            dim = node.getData('dim');
        this.nodeHelper.triangle.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos) {
        var npos = node.pos.getc(true), 
            dim = node.getData('dim');
        return this.nodeHelper.triangle.contains(npos, pos, dim);
      }
    },
    'star': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true),
            dim = node.getData('dim');
        this.nodeHelper.star.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos) {
        var npos = node.pos.getc(true),
            dim = node.getData('dim');
        return this.nodeHelper.star.contains(npos, pos, dim);
      }
    }
  });

  /*
    Class: RGraph.Plot.EdgeTypes

    This class contains a list of <Graph.Adjacence> built-in types. 
    Edge types implemented are 'none', 'line' and 'arrow'.
  
    You can add your custom edge types, customizing your visualization to the extreme.
  
    Example:
  
    (start code js)
      RGraph.Plot.EdgeTypes.implement({
        'mySpecialType': {
          'render': function(adj, canvas) {
            //print your custom edge to canvas
          },
          //optional
          'contains': function(adj, pos) {
            //return true if pos is inside the arc or false otherwise
          }
        }
      });
    (end code)
  
  */
  RGraph.Plot.EdgeTypes = new Class({
    'none': $.empty,
    'line': {
      'render': function(adj, canvas) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true);
        this.edgeHelper.line.render(from, to, canvas);
      },
      'contains': function(adj, pos) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true);
        return this.edgeHelper.line.contains(from, to, pos, this.edge.epsilon);
      }
    },
    'arrow': {
      'render': function(adj, canvas) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true),
            dim = adj.getData('dim'),
            direction = adj.data.$direction,
            inv = (direction && direction.length>1 && direction[0] != adj.nodeFrom.id);
        this.edgeHelper.arrow.render(from, to, dim, inv, canvas);
      },
      'contains': function(adj, pos) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true);
        return this.edgeHelper.arrow.contains(from, to, pos, this.edge.epsilon);
      }
    }
  });

})($jit.RGraph);


/*
 * File: Layouts.ForceDirected.js
 *
*/

/*
 * Class: Layouts.ForceDirected
 * 
 * Implements a Force Directed Layout.
 * 
 * Implemented By:
 * 
 * <ForceDirected>
 * 
 * Credits:
 * 
 * Marcus Cobden <http://marcuscobden.co.uk>
 * 
 */
Layouts.ForceDirected = new Class({

  getOptions: function(random) {
    var s = this.canvas.getSize();
    var w = s.width, h = s.height;
    //count nodes
    var count = 0;
    this.graph.eachNode(function(n) { 
      count++;
    });
    var k2 = w * h / count, k = Math.sqrt(k2);
    var l = this.config.levelDistance;
    
    return {
      width: w,
      height: h,
      tstart: w * 0.1,
      nodef: function(x) { return k2 / (x || 1); },
      edgef: function(x) { return /* x * x / k; */ k * (x - l); }
    };
  },
  
  compute: function(property, incremental) {
    var prop = $.splat(property || ['current', 'start', 'end']);
    var opt = this.getOptions();
    NodeDim.compute(this.graph, prop, this.config);
    this.graph.computeLevels(this.root, 0, "ignore");
    this.graph.eachNode(function(n) {
      $.each(prop, function(p) {
        var pos = n.getPos(p);
        if(pos.equals(Complex.KER)) {
          pos.x = opt.width/5 * (Math.random() - 0.5);
          pos.y = opt.height/5 * (Math.random() - 0.5);
        }
        //initialize disp vector
        n.disp = {};
        $.each(prop, function(p) {
          n.disp[p] = $C(0, 0);
        });
      });
    });
    this.computePositions(prop, opt, incremental);
  },
  
  computePositions: function(property, opt, incremental) {
    var times = this.config.iterations, i = 0, that = this;
    if(incremental) {
      (function iter() {
        for(var total=incremental.iter, j=0; j<total; j++) {
          opt.t = opt.tstart;
          if(times) opt.t *= (1 - i++/(times -1));
          that.computePositionStep(property, opt);
          if(times && i >= times) {
            incremental.onComplete();
            return;
          }
        }
        incremental.onStep(Math.round(i / (times -1) * 100));
        setTimeout(iter, 1);
      })();
    } else {
      for(; i < times; i++) {
        opt.t = opt.tstart * (1 - i/(times -1));
        this.computePositionStep(property, opt);
      }
    }
  },
  
  computePositionStep: function(property, opt) {
    var graph = this.graph;
    var min = Math.min, max = Math.max;
    var dpos = $C(0, 0);
    //calculate repulsive forces
    graph.eachNode(function(v) {
      //initialize disp
      $.each(property, function(p) {
        v.disp[p].x = 0; v.disp[p].y = 0;
      });
      graph.eachNode(function(u) {
        if(u.id != v.id) {
          $.each(property, function(p) {
            var vp = v.getPos(p), up = u.getPos(p);
            dpos.x = vp.x - up.x;
            dpos.y = vp.y - up.y;
            var norm = dpos.norm() || 1;
            v.disp[p].$add(dpos
                .$scale(opt.nodef(norm) / norm));
          });
        }
      });
    });
    //calculate attractive forces
    var T = !!graph.getNode(this.root).visited;
    graph.eachNode(function(node) {
      node.eachAdjacency(function(adj) {
        var nodeTo = adj.nodeTo;
        if(!!nodeTo.visited === T) {
          $.each(property, function(p) {
            var vp = node.getPos(p), up = nodeTo.getPos(p);
            dpos.x = vp.x - up.x;
            dpos.y = vp.y - up.y;
            var norm = dpos.norm() || 1;
            node.disp[p].$add(dpos.$scale(-opt.edgef(norm) / norm));
            nodeTo.disp[p].$add(dpos.$scale(-1));
          });
        }
      });
      node.visited = !T;
    });
    //arrange positions to fit the canvas
    var t = opt.t, w2 = opt.width / 2, h2 = opt.height / 2;
    graph.eachNode(function(u) {
      $.each(property, function(p) {
        var disp = u.disp[p];
        var norm = disp.norm() || 1;
        var p = u.getPos(p);
        p.$add($C(disp.x * min(Math.abs(disp.x), t) / norm, 
            disp.y * min(Math.abs(disp.y), t) / norm));
        p.x = min(w2, max(-w2, p.x));
        p.y = min(h2, max(-h2, p.y));
      });
    });
  }
});

/*
 * File: ForceDirected.js
 */

/*
   Class: ForceDirected
      
   A visualization that lays graphs using a Force-Directed layout algorithm.
   
   Inspired by:
  
   Force-Directed Drawing Algorithms (Stephen G. Kobourov) <http://www.cs.brown.edu/~rt/gdhandbook/chapters/force-directed.pdf>
   
  Implements:
  
  All <Loader> methods
  
   Constructor Options:
   
   Inherits options from
   
   - <Options.Canvas>
   - <Options.Controller>
   - <Options.Node>
   - <Options.Edge>
   - <Options.Label>
   - <Options.Events>
   - <Options.Tips>
   - <Options.NodeStyles>
   - <Options.Navigation>
   
   Additionally, there are two parameters
   
   levelDistance - (number) Default's *50*. The natural length desired for the edges.
   iterations - (number) Default's *50*. The number of iterations for the spring layout simulation. Depending on the browser's speed you could set this to a more 'interesting' number, like *200*. 
     
   Instance Properties:

   canvas - Access a <Canvas> instance.
   graph - Access a <Graph> instance.
   op - Access a <ForceDirected.Op> instance.
   fx - Access a <ForceDirected.Plot> instance.
   labels - Access a <ForceDirected.Label> interface implementation.

*/

$jit.ForceDirected = new Class( {

  Implements: [ Loader, Extras, Layouts.ForceDirected ],

  initialize: function(controller) {
    var $ForceDirected = $jit.ForceDirected;

    var config = {
      iterations: 50,
      levelDistance: 50
    };

    this.controller = this.config = $.merge(Options("Canvas", "Node", "Edge",
        "Fx", "Tips", "NodeStyles", "Events", "Navigation", "Controller", "Label"), config, controller);

    var canvasConfig = this.config;
    if(canvasConfig.useCanvas) {
      this.canvas = canvasConfig.useCanvas;
      this.config.labelContainer = this.canvas.id + '-label';
    } else {
      if(canvasConfig.background) {
        canvasConfig.background = $.merge({
          type: 'Circles'
        }, canvasConfig.background);
      }
      this.canvas = new Canvas(this, canvasConfig);
      this.config.labelContainer = (typeof canvasConfig.injectInto == 'string'? canvasConfig.injectInto : canvasConfig.injectInto.id) + '-label';
    }

    this.graphOptions = {
      'klass': Complex,
      'Node': {
        'selected': false,
        'exist': true,
        'drawn': true
      }
    };
    this.graph = new Graph(this.graphOptions, this.config.Node,
        this.config.Edge);
    this.labels = new $ForceDirected.Label[canvasConfig.Label.type](this);
    this.fx = new $ForceDirected.Plot(this, $ForceDirected);
    this.op = new $ForceDirected.Op(this);
    this.json = null;
    this.busy = false;
    // initialize extras
    this.initializeExtras();
  },

  /* 
    Method: refresh 
    
    Computes positions and plots the tree.
  */
  refresh: function() {
    // START METAMAPS CODE
    // this.compute();
    // END METAMAPS CODE
    // ORIGINAL CODE: this.compute();
    this.plot();
  },

  reposition: function() {
    this.compute('end');
  },

/*
  Method: computeIncremental
  
  Performs the Force Directed algorithm incrementally.
  
  Description:
  
  ForceDirected algorithms can perform many computations and lead to JavaScript taking too much time to complete. 
  This method splits the algorithm into smaller parts allowing the user to track the evolution of the algorithm and 
  avoiding browser messages such as "This script is taking too long to complete".
  
  Parameters:
  
  opt - (object) The object properties are described below
  
  iter - (number) Default's *20*. Split the algorithm into pieces of _iter_ iterations. For example, if the _iterations_ configuration property 
  of your <ForceDirected> class is 100, then you could set _iter_ to 20 to split the main algorithm into 5 smaller pieces.
  
  property - (string) Default's *end*. Whether to update starting, current or ending node positions. Possible values are 'end', 'start', 'current'. 
  You can also set an array of these properties. If you'd like to keep the current node positions but to perform these 
  computations for final animation positions then you can just choose 'end'.
  
  onStep - (function) A callback function called when each "small part" of the algorithm completed. This function gets as first formal 
  parameter a percentage value.
  
  onComplete - A callback function called when the algorithm completed.
  
  Example:
  
  In this example I calculate the end positions and then animate the graph to those positions
  
  (start code js)
  var fd = new $jit.ForceDirected(...);
  fd.computeIncremental({
    iter: 20,
    property: 'end',
    onStep: function(perc) {
      Log.write("loading " + perc + "%");
    },
    onComplete: function() {
      Log.write("done");
      fd.animate();
    }
  });
  (end code)
  
  In this example I calculate all positions and (re)plot the graph
  
  (start code js)
  var fd = new ForceDirected(...);
  fd.computeIncremental({
    iter: 20,
    property: ['end', 'start', 'current'],
    onStep: function(perc) {
      Log.write("loading " + perc + "%");
    },
    onComplete: function() {
      Log.write("done");
      fd.plot();
    }
  });
  (end code)
  
  */
  computeIncremental: function(opt) {
    opt = $.merge( {
      iter: 20,
      property: 'end',
      onStep: $.empty,
      onComplete: $.empty
    }, opt || {});

    this.config.onBeforeCompute(this.graph.getNode(this.root));
    this.compute(opt.property, opt);
  },

  /*
    Method: plot
   
    Plots the ForceDirected graph. This is a shortcut to *fx.plot*.
   */
  plot: function() {
    this.fx.plot();
  },

  /*
     Method: animate
    
     Animates the graph from the current positions to the 'end' node positions.
  */
  animate: function(opt) {
    this.fx.animate($.merge( {
      modes: [ 'linear' ]
    }, opt || {}));
  }
});

$jit.ForceDirected.$extend = true;

(function(ForceDirected) {

  /*
     Class: ForceDirected.Op
     
     Custom extension of <Graph.Op>.

     Extends:

     All <Graph.Op> methods
     
     See also:
     
     <Graph.Op>

  */
  ForceDirected.Op = new Class( {

    Implements: Graph.Op

  });

  /*
    Class: ForceDirected.Plot
    
    Custom extension of <Graph.Plot>.
  
    Extends:
  
    All <Graph.Plot> methods
    
    See also:
    
    <Graph.Plot>
  
  */
  ForceDirected.Plot = new Class( {

    Implements: Graph.Plot

  });

  /*
    Class: ForceDirected.Label
    
    Custom extension of <Graph.Label>. 
    Contains custom <Graph.Label.SVG>, <Graph.Label.HTML> and <Graph.Label.Native> extensions.
  
    Extends:
  
    All <Graph.Label> methods and subclasses.
  
    See also:
  
    <Graph.Label>, <Graph.Label.Native>, <Graph.Label.HTML>, <Graph.Label.SVG>.
  
  */
  ForceDirected.Label = {};

  /*
     ForceDirected.Label.Native
     
     Custom extension of <Graph.Label.Native>.

     Extends:

     All <Graph.Label.Native> methods

     See also:

     <Graph.Label.Native>

  */
  ForceDirected.Label.Native = new Class( {
    Implements: Graph.Label.Native
  });

  /*
    ForceDirected.Label.SVG
    
    Custom extension of <Graph.Label.SVG>.
  
    Extends:
  
    All <Graph.Label.SVG> methods
  
    See also:
  
    <Graph.Label.SVG>
  
  */
  ForceDirected.Label.SVG = new Class( {
    Implements: Graph.Label.SVG,

    initialize: function(viz) {
      this.viz = viz;
    },

    /* 
       placeLabel

       Overrides abstract method placeLabel in <Graph.Label>.

       Parameters:

       tag - A DOM label element.
       node - A <Graph.Node>.
       controller - A configuration/controller object passed to the visualization.
      
     */
    placeLabel: function(tag, node, controller) {
      var pos = node.pos.getc(true), 
          canvas = this.viz.canvas,
          ox = canvas.translateOffsetX,
          oy = canvas.translateOffsetY,
          sx = canvas.scaleOffsetX,
          sy = canvas.scaleOffsetY,
          radius = canvas.getSize();
      var labelPos = {
        x: Math.round(pos.x * sx + ox + radius.width / 2),
        y: Math.round(pos.y * sy + oy + radius.height / 2)
      };
      tag.setAttribute('x', labelPos.x);
      tag.setAttribute('y', labelPos.y);

      controller.onPlaceLabel(tag, node);
    }
  });

  /*
     ForceDirected.Label.HTML
     
     Custom extension of <Graph.Label.HTML>.

     Extends:

     All <Graph.Label.HTML> methods.

     See also:

     <Graph.Label.HTML>

  */
  ForceDirected.Label.HTML = new Class( {
    Implements: Graph.Label.HTML,

    initialize: function(viz) {
      this.viz = viz;
    },
    /* 
       placeLabel

       Overrides abstract method placeLabel in <Graph.Plot>.

       Parameters:

       tag - A DOM label element.
       node - A <Graph.Node>.
       controller - A configuration/controller object passed to the visualization.
      
     */
    placeLabel: function(tag, node, controller) {
      var pos = node.pos.getc(true), 
          canvas = this.viz.canvas,
          ox = canvas.translateOffsetX,
          oy = canvas.translateOffsetY,
          sx = canvas.scaleOffsetX,
          sy = canvas.scaleOffsetY,
          radius = canvas.getSize();
      var labelPos = {
        x: Math.round(pos.x * sx + ox + radius.width / 2),
        y: Math.round(pos.y * sy + oy + radius.height / 2)
      };
      var style = tag.style;
      style.left = labelPos.x + 'px';
      style.top = labelPos.y + 'px';
      style.display = this.fitsInCanvas(labelPos, canvas) ? '' : 'none';

      controller.onPlaceLabel(tag, node);
    }
  });

  /*
    Class: ForceDirected.Plot.NodeTypes

    This class contains a list of <Graph.Node> built-in types. 
    Node types implemented are 'none', 'circle', 'triangle', 'rectangle', 'star', 'ellipse' and 'square'.

    You can add your custom node types, customizing your visualization to the extreme.

    Example:

    (start code js)
      ForceDirected.Plot.NodeTypes.implement({
        'mySpecialType': {
          'render': function(node, canvas) {
            //print your custom node to canvas
          },
          //optional
          'contains': function(node, pos) {
            //return true if pos is inside the node or false otherwise
          }
        }
      });
    (end code)

  */
  ForceDirected.Plot.NodeTypes = new Class({
    'none': {
      'render': $.empty,
      'contains': $.lambda(false)
    },
    'circle': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            dim = node.getData('dim');
        this.nodeHelper.circle.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            dim = node.getData('dim');
        return this.nodeHelper.circle.contains(npos, pos, dim);
      }
    },
    'ellipse': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        this.nodeHelper.ellipse.render('fill', pos, width, height, canvas);
        },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        return this.nodeHelper.ellipse.contains(npos, pos, width, height);
      }
    },
    'square': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            dim = node.getData('dim');
        this.nodeHelper.square.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            dim = node.getData('dim');
        return this.nodeHelper.square.contains(npos, pos, dim);
      }
    },
    'rectangle': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        this.nodeHelper.rectangle.render('fill', pos, width, height, canvas);
      },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        return this.nodeHelper.rectangle.contains(npos, pos, width, height);
      }
    },
    'triangle': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            dim = node.getData('dim');
        this.nodeHelper.triangle.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos) {
        var npos = node.pos.getc(true), 
            dim = node.getData('dim');
        return this.nodeHelper.triangle.contains(npos, pos, dim);
      }
    },
    'star': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true),
            dim = node.getData('dim');
        this.nodeHelper.star.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos) {
        var npos = node.pos.getc(true),
            dim = node.getData('dim');
        return this.nodeHelper.star.contains(npos, pos, dim);
      }
    }
  });

  /*
    Class: ForceDirected.Plot.EdgeTypes
  
    This class contains a list of <Graph.Adjacence> built-in types. 
    Edge types implemented are 'none', 'line' and 'arrow'.
  
    You can add your custom edge types, customizing your visualization to the extreme.
  
    Example:
  
    (start code js)
      ForceDirected.Plot.EdgeTypes.implement({
        'mySpecialType': {
          'render': function(adj, canvas) {
            //print your custom edge to canvas
          },
          //optional
          'contains': function(adj, pos) {
            //return true if pos is inside the arc or false otherwise
          }
        }
      });
    (end code)
  
  */
  ForceDirected.Plot.EdgeTypes = new Class({
    'none': $.empty,
    'line': {
      'render': function(adj, canvas) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true);
        this.edgeHelper.line.render(from, to, canvas);
      },
      'contains': function(adj, pos) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true);
        return this.edgeHelper.line.contains(from, to, pos, this.edge.epsilon);
      }
    },
    'arrow': {
      'render': function(adj, canvas) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true),
            dim = adj.getData('dim'),
            direction = adj.data.$direction,
            inv = (direction && direction.length>1 && direction[0] != adj.nodeFrom.id);
        this.edgeHelper.arrow.render(from, to, dim, inv, canvas);
      },
      'contains': function(adj, pos) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true);
        return this.edgeHelper.arrow.contains(from, to, pos, this.edge.epsilon);
      }
    }
  });

})($jit.ForceDirected);


/*
 * Vector3 class based on three.js http://github.com/mrdoob/three.js, Copyright (c) Mr.doob http://mrdoob.com/, MIT License http://github.com/mrdoob/three.js/blob/master/LICENSE 
 */

var Vector3 = function(x, y, z) {
	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
};

$jit.Vector3 = Vector3;

Vector3.prototype = {
  set: function(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
  },

  setc: function(x, y, z) {
		this.x = x;
		this.y = y;
		this.z = z;
	},
	
	getc: function() {
	  return this;
	},
	
	//TODO(nico): getp

	add: function(v1, v2) {
		this.x = v1.x + v2.x;
		this.y = v1.y + v2.y;
		this.z = v1.z + v2.z;
		return this;
	},

	$add: function(v) {
		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		return this;
	},

	addScalar: function(s) {
		this.x += s;
		this.y += s;
		this.z += s;
		return this;
	},

	sub: function(v1, v2) {
		this.x = v1.x - v2.x;
		this.y = v1.y - v2.y;
		this.z = v1.z - v2.z;
		return this;
	},

	$sub: function(v) {
		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		return this;
	},

	cross: function(v1, v2) {
		this.x = v1.y * v2.z - v1.z * v2.y;
		this.y = v1.z * v2.x - v1.x * v2.z;
		this.z = v1.x * v2.y - v1.y * v2.x;
		return this;
	},

	$cross: function(v) {
		var tx = this.x, ty = this.y, tz = this.z;

		this.x = ty * v.z - tz * v.y;
		this.y = tz * v.x - tx * v.z;
		this.z = tx * v.y - ty * v.x;
		return this;
	},

	$multiply: function(v) {
		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		return this;
	},

	$scale: function(s) {
		this.x *= s;
		this.y *= s;
		this.z *= s;
		return this;
	},

	dot: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z;
	},

	distanceTo: function(v) {
		return Math.sqrt(this.distanceToSquared(v));
	},

	distanceToSquared: function(v) {
		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
		return dx * dx + dy * dy + dz * dz;
	},

	norm: function() {
		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	},

	normSquared: function() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	},

	negate: function() {
		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		return this;
	},

	normalize: function() {
	  var len = this.norm();
		if ( len > 0 ) {
			this.$scale(1 / len);
		} 
		return this;
	},

	isZero: function() {
		var almostZero = 0.0001,
		    abs = Math.abs;
		
		return abs(this.x) < almostZero && abs(this.y) < almostZero && abs(this.z) < almostZero;
	},

	clone: function() {
		return new Vector3(this.x, this.y, this.z);
	}
};

var $V3 = function(a, b, c) { return new Vector3(a, b, c); };

/*
 * Matrix4 class based on three.js http://github.com/mrdoob/three.js, Copyright (c) Mr.doob http://mrdoob.com/, MIT License http://github.com/mrdoob/three.js/blob/master/LICENSE 
 */

var Matrix4 = function() {
	this._x = new Vector3();
	this._y = new Vector3();
	this._z = new Vector3();
};

$jit.Matrix4 = Matrix4;

Matrix4.prototype = {

	n11: 1, n12: 0, n13: 0, n14: 0,
	n21: 0, n22: 1, n23: 0, n24: 0,
	n31: 0, n32: 0, n33: 1, n34: 0,
	n41: 0, n42: 0, n43: 0, n44: 1,

	identity: function() {
		this.n11 = 1; this.n12 = 0; this.n13 = 0; this.n14 = 0;
		this.n21 = 0; this.n22 = 1; this.n23 = 0; this.n24 = 0;
		this.n31 = 0; this.n32 = 0; this.n33 = 1; this.n34 = 0;
		this.n41 = 0; this.n42 = 0; this.n43 = 0; this.n44 = 1;
	},

	lookAt: function(eye, center, up) {
		var x = this._x, y = this._y, z = this._z;

		z.sub(eye, center);
		z.normalize();

		x.cross(up, z);
		x.normalize();

		y.cross(z, x);
		y.normalize();

		this.n11 = x.x; this.n12 = x.y; this.n13 = x.z; this.n14 = - x.dot( eye );
		this.n21 = y.x; this.n22 = y.y; this.n23 = y.z; this.n24 = - y.dot( eye );
		this.n31 = z.x; this.n32 = z.y; this.n33 = z.z; this.n34 = - z.dot( eye );
	},

	transform: function(v) {
		var vx = v.x, vy = v.y, vz = v.z, vw = v.w ? v.w : 1.0;

		v.x = this.n11 * vx + this.n12 * vy + this.n13 * vz + this.n14 * vw;
		v.y = this.n21 * vx + this.n22 * vy + this.n23 * vz + this.n24 * vw;
		v.z = this.n31 * vx + this.n32 * vy + this.n33 * vz + this.n34 * vw;

		vw = this.n41 * vx + this.n42 * vy + this.n43 * vz + this.n44 * vw;

		if(v.w) {
			v.w = vw;
		} else {
			v.x = v.x / vw;
			v.y = v.y / vw;
			v.z = v.z / vw;
		}
	},

	multiply: function(a, b) {
		this.n11 = a.n11 * b.n11 + a.n12 * b.n21 + a.n13 * b.n31 + a.n14 * b.n41;
		this.n12 = a.n11 * b.n12 + a.n12 * b.n22 + a.n13 * b.n32 + a.n14 * b.n42;
		this.n13 = a.n11 * b.n13 + a.n12 * b.n23 + a.n13 * b.n33 + a.n14 * b.n43;
		this.n14 = a.n11 * b.n14 + a.n12 * b.n24 + a.n13 * b.n34 + a.n14 * b.n44;

		this.n21 = a.n21 * b.n11 + a.n22 * b.n21 + a.n23 * b.n31 + a.n24 * b.n41;
		this.n22 = a.n21 * b.n12 + a.n22 * b.n22 + a.n23 * b.n32 + a.n24 * b.n42;
		this.n23 = a.n21 * b.n13 + a.n22 * b.n23 + a.n23 * b.n33 + a.n24 * b.n43;
		this.n24 = a.n21 * b.n14 + a.n22 * b.n24 + a.n23 * b.n34 + a.n24 * b.n44;

		this.n31 = a.n31 * b.n11 + a.n32 * b.n21 + a.n33 * b.n31 + a.n34 * b.n41;
		this.n32 = a.n31 * b.n12 + a.n32 * b.n22 + a.n33 * b.n32 + a.n34 * b.n42;
		this.n33 = a.n31 * b.n13 + a.n32 * b.n23 + a.n33 * b.n33 + a.n34 * b.n43;
		this.n34 = a.n31 * b.n14 + a.n32 * b.n24 + a.n33 * b.n34 + a.n34 * b.n44;

		this.n41 = a.n41 * b.n11 + a.n42 * b.n21 + a.n43 * b.n31 + a.n44 * b.n41;
		this.n42 = a.n41 * b.n12 + a.n42 * b.n22 + a.n43 * b.n32 + a.n44 * b.n42;
		this.n43 = a.n41 * b.n13 + a.n42 * b.n23 + a.n43 * b.n33 + a.n44 * b.n43;
		this.n44 = a.n41 * b.n14 + a.n42 * b.n24 + a.n43 * b.n34 + a.n44 * b.n44;
	},

	$multiply: function(m) {
		var n11 = this.n11, n12 = this.n12, n13 = this.n13, n14 = this.n14,
    		n21 = this.n21, n22 = this.n22, n23 = this.n23, n24 = this.n24,
    		n31 = this.n31, n32 = this.n32, n33 = this.n33, n34 = this.n34,
    		n41 = this.n41, n42 = this.n42, n43 = this.n43, n44 = this.n44;

		this.n11 = n11 * m.n11 + n12 * m.n21 + n13 * m.n31 + n14 * m.n41;
		this.n12 = n11 * m.n12 + n12 * m.n22 + n13 * m.n32 + n14 * m.n42;
		this.n13 = n11 * m.n13 + n12 * m.n23 + n13 * m.n33 + n14 * m.n43;
		this.n14 = n11 * m.n14 + n12 * m.n24 + n13 * m.n34 + n14 * m.n44;

		this.n21 = n21 * m.n11 + n22 * m.n21 + n23 * m.n31 + n24 * m.n41;
		this.n22 = n21 * m.n12 + n22 * m.n22 + n23 * m.n32 + n24 * m.n42;
		this.n23 = n21 * m.n13 + n22 * m.n23 + n23 * m.n33 + n24 * m.n43;
		this.n24 = n21 * m.n14 + n22 * m.n24 + n23 * m.n34 + n24 * m.n44;

		this.n31 = n31 * m.n11 + n32 * m.n21 + n33 * m.n31 + n34 * m.n41;
		this.n32 = n31 * m.n12 + n32 * m.n22 + n33 * m.n32 + n34 * m.n42;
		this.n33 = n31 * m.n13 + n32 * m.n23 + n33 * m.n33 + n34 * m.n43;
		this.n34 = n31 * m.n14 + n32 * m.n24 + n33 * m.n34 + n34 * m.n44;

		this.n41 = n41 * m.n11 + n42 * m.n21 + n43 * m.n31 + n44 * m.n41;
		this.n42 = n41 * m.n12 + n42 * m.n22 + n43 * m.n32 + n44 * m.n42;
		this.n43 = n41 * m.n13 + n42 * m.n23 + n43 * m.n33 + n44 * m.n43;
		this.n44 = n41 * m.n14 + n42 * m.n24 + n43 * m.n34 + n44 * m.n44;
	},

	$scale: function(s) {
		this.n11 *= s; this.n12 *= s; this.n13 *= s; this.n14 *= s;
		this.n21 *= s; this.n22 *= s; this.n23 *= s; this.n24 *= s;
		this.n31 *= s; this.n32 *= s; this.n33 *= s; this.n34 *= s;
		this.n41 *= s; this.n42 *= s; this.n43 *= s; this.n44 *= s;
		return this;
	},
	
	$add: function(m) {
	  this.n11 += m.n11;
	  this.n12 += m.n12;
	  this.n13 += m.n13;
	  this.n14 += m.n14;
	  this.n21 += m.n21;
	  this.n22 += m.n22;
	  this.n23 += m.n23;
	  this.n24 += m.n24;
	  this.n31 += m.n31;
	  this.n32 += m.n32;
	  this.n33 += m.n33;
	  this.n34 += m.n34;
	  this.n41 += m.n41;
	  this.n42 += m.n42;
	  this.n43 += m.n43;
	  this.n44 += m.n44;
	  return this;
	},

	determinant: function() {
		return (
			this.n14 * this.n23 * this.n32 * this.n41-
			this.n13 * this.n24 * this.n32 * this.n41-
			this.n14 * this.n22 * this.n33 * this.n41+
			this.n12 * this.n24 * this.n33 * this.n41+

			this.n13 * this.n22 * this.n34 * this.n41-
			this.n12 * this.n23 * this.n34 * this.n41-
			this.n14 * this.n23 * this.n31 * this.n42+
			this.n13 * this.n24 * this.n31 * this.n42+

			this.n14 * this.n21 * this.n33 * this.n42-
			this.n11 * this.n24 * this.n33 * this.n42-
			this.n13 * this.n21 * this.n34 * this.n42+
			this.n11 * this.n23 * this.n34 * this.n42+

			this.n14 * this.n22 * this.n31 * this.n43-
			this.n12 * this.n24 * this.n31 * this.n43-
			this.n14 * this.n21 * this.n32 * this.n43+
			this.n11 * this.n24 * this.n32 * this.n43+

			this.n12 * this.n21 * this.n34 * this.n43-
			this.n11 * this.n22 * this.n34 * this.n43-
			this.n13 * this.n22 * this.n31 * this.n44+
			this.n12 * this.n23 * this.n31 * this.n44+

			this.n13 * this.n21 * this.n32 * this.n44-
			this.n11 * this.n23 * this.n32 * this.n44-
			this.n12 * this.n21 * this.n33 * this.n44+
			this.n11 * this.n22 * this.n33 * this.n44 );
	},

  $transpose: function() {
	  function swap(obj, p1, p2) {
	    var aux = obj[p1];
	    obj[p1] = obj[p2];
	    obj[p2] = aux;
	  }
	  
	  swap(this, 'n21', 'n12');
	  swap(this, 'n31', 'n13');
	  swap(this, 'n32', 'n23');
	  swap(this, 'n41', 'n14');
	  swap(this, 'n42', 'n24');
	  swap(this, 'n43', 'n34');
	  return this;
  },
  
	clone: function() {
		var m = new Matrix4();
		m.n11 = this.n11; m.n12 = this.n12; m.n13 = this.n13; m.n14 = this.n14;
		m.n21 = this.n21; m.n22 = this.n22; m.n23 = this.n23; m.n24 = this.n24;
		m.n31 = this.n31; m.n32 = this.n32; m.n33 = this.n33; m.n34 = this.n34;
		m.n41 = this.n41; m.n42 = this.n42; m.n43 = this.n43; m.n44 = this.n44;
		return m;
	},
	
	flatten: function() {
	  return [this.n11, this.n21, this.n31, this.n41,
	      this.n12, this.n22, this.n32, this.n42,
	      this.n13, this.n23, this.n33, this.n43,
	      this.n14, this.n24, this.n34, this.n44];
	}
};

Matrix4.translationMatrix = function(x, y, z) {
	var m = new Matrix4();

	m.n14 = x;
	m.n24 = y;
	m.n34 = z;

	return m;
};

Matrix4.scaleMatrix = function(x, y, z) {
	var m = new Matrix4();

	m.n11 = x;
	m.n22 = y;
	m.n33 = z;

	return m;
};

Matrix4.rotationXMatrix = function(theta) {
	var rot = new Matrix4();

	rot.n22 = rot.n33 = Math.cos( theta );
	rot.n32 = Math.sin( theta );
	rot.n23 = - rot.n32;

	return rot;
};

Matrix4.rotationYMatrix = function(theta) {
	var rot = new Matrix4();

	rot.n11 = rot.n33 = Math.cos( theta );
	rot.n13 = Math.sin( theta );
	rot.n31 = - rot.n13;

	return rot;
};

Matrix4.rotationZMatrix = function(theta) {
	var rot = new Matrix4();

	rot.n11 = rot.n22 = Math.cos( theta );
	rot.n21 = Math.sin( theta );
	rot.n12 = - rot.n21;

	return rot;
};

Matrix4.makeInvert = function(m1) {
	var m2 = new Matrix4();

	m2.n11 = m1.n23*m1.n34*m1.n42 - m1.n24*m1.n33*m1.n42 + m1.n24*m1.n32*m1.n43 - m1.n22*m1.n34*m1.n43 - m1.n23*m1.n32*m1.n44 + m1.n22*m1.n33*m1.n44;
	m2.n12 = m1.n14*m1.n33*m1.n42 - m1.n13*m1.n34*m1.n42 - m1.n14*m1.n32*m1.n43 + m1.n12*m1.n34*m1.n43 + m1.n13*m1.n32*m1.n44 - m1.n12*m1.n33*m1.n44;
	m2.n13 = m1.n13*m1.n24*m1.n42 - m1.n14*m1.n23*m1.n42 + m1.n14*m1.n22*m1.n43 - m1.n12*m1.n24*m1.n43 - m1.n13*m1.n22*m1.n44 + m1.n12*m1.n23*m1.n44;
	m2.n14 = m1.n14*m1.n23*m1.n32 - m1.n13*m1.n24*m1.n32 - m1.n14*m1.n22*m1.n33 + m1.n12*m1.n24*m1.n33 + m1.n13*m1.n22*m1.n34 - m1.n12*m1.n23*m1.n34;
	m2.n21 = m1.n24*m1.n33*m1.n41 - m1.n23*m1.n34*m1.n41 - m1.n24*m1.n31*m1.n43 + m1.n21*m1.n34*m1.n43 + m1.n23*m1.n31*m1.n44 - m1.n21*m1.n33*m1.n44;
	m2.n22 = m1.n13*m1.n34*m1.n41 - m1.n14*m1.n33*m1.n41 + m1.n14*m1.n31*m1.n43 - m1.n11*m1.n34*m1.n43 - m1.n13*m1.n31*m1.n44 + m1.n11*m1.n33*m1.n44;
	m2.n23 = m1.n14*m1.n23*m1.n41 - m1.n13*m1.n24*m1.n41 - m1.n14*m1.n21*m1.n43 + m1.n11*m1.n24*m1.n43 + m1.n13*m1.n21*m1.n44 - m1.n11*m1.n23*m1.n44;
	m2.n24 = m1.n13*m1.n24*m1.n31 - m1.n14*m1.n23*m1.n31 + m1.n14*m1.n21*m1.n33 - m1.n11*m1.n24*m1.n33 - m1.n13*m1.n21*m1.n34 + m1.n11*m1.n23*m1.n34;
	m2.n31 = m1.n22*m1.n34*m1.n41 - m1.n24*m1.n32*m1.n41 + m1.n24*m1.n31*m1.n42 - m1.n21*m1.n34*m1.n42 - m1.n22*m1.n31*m1.n44 + m1.n21*m1.n32*m1.n44;
	m2.n32 = m1.n14*m1.n32*m1.n41 - m1.n12*m1.n34*m1.n41 - m1.n14*m1.n31*m1.n42 + m1.n11*m1.n34*m1.n42 + m1.n12*m1.n31*m1.n44 - m1.n11*m1.n32*m1.n44;
	m2.n33 = m1.n13*m1.n24*m1.n41 - m1.n14*m1.n22*m1.n41 + m1.n14*m1.n21*m1.n42 - m1.n11*m1.n24*m1.n42 - m1.n12*m1.n21*m1.n44 + m1.n11*m1.n22*m1.n44;
	m2.n34 = m1.n14*m1.n22*m1.n31 - m1.n12*m1.n24*m1.n31 - m1.n14*m1.n21*m1.n32 + m1.n11*m1.n24*m1.n32 + m1.n12*m1.n21*m1.n34 - m1.n11*m1.n22*m1.n34;
	m2.n41 = m1.n23*m1.n32*m1.n41 - m1.n22*m1.n33*m1.n41 - m1.n23*m1.n31*m1.n42 + m1.n21*m1.n33*m1.n42 + m1.n22*m1.n31*m1.n43 - m1.n21*m1.n32*m1.n43;
	m2.n42 = m1.n12*m1.n33*m1.n41 - m1.n13*m1.n32*m1.n41 + m1.n13*m1.n31*m1.n42 - m1.n11*m1.n33*m1.n42 - m1.n12*m1.n31*m1.n43 + m1.n11*m1.n32*m1.n43;
	m2.n43 = m1.n13*m1.n22*m1.n41 - m1.n12*m1.n23*m1.n41 - m1.n13*m1.n21*m1.n42 + m1.n11*m1.n23*m1.n42 + m1.n12*m1.n21*m1.n43 - m1.n11*m1.n22*m1.n43;
	m2.n44 = m1.n12*m1.n23*m1.n31 - m1.n13*m1.n22*m1.n31 + m1.n13*m1.n21*m1.n32 - m1.n11*m1.n23*m1.n32 - m1.n12*m1.n21*m1.n33 + m1.n11*m1.n22*m1.n33;
	m2.$scale(1 / m1.determinant());

	return m2;
};

Matrix4.makeFrustum = function( left, right, bottom, top, near, far ) {
	var m, x, y, a, b, c, d;

	m = new Matrix4();
	x = 2 * near / ( right - left );
	y = 2 * near / ( top - bottom );
	a = ( right + left ) / ( right - left );
	b = ( top + bottom ) / ( top - bottom );
	c = - ( far + near ) / ( far - near );
	d = - 2 * far * near / ( far - near );

	m.n11 = x;  m.n12 = 0;  m.n13 = a;   m.n14 = 0;
	m.n21 = 0;  m.n22 = y;  m.n23 = b;   m.n24 = 0;
	m.n31 = 0;  m.n32 = 0;  m.n33 = c;   m.n34 = d;
	m.n41 = 0;  m.n42 = 0;  m.n43 = - 1; m.n44 = 0;

	return m;
};

Matrix4.makePerspective = function( fov, aspect, near, far ) {
	var ymax, ymin, xmin, xmax;

	ymax = near * Math.tan( fov * Math.PI / 360 );
	ymin = - ymax;
	xmin = ymin * aspect;
	xmax = ymax * aspect;

	return Matrix4.makeFrustum( xmin, xmax, ymin, ymax, near, far );
};

Matrix4.makeOrtho = function( left, right, top, bottom, near, far ) {
	var m, x, y, z, w, h, p;

	m = new Matrix4();
	w = right - left;
	h = bottom - top;
	p = far - near;
	x = ( right + left ) / w;
	y = ( bottom + top ) / h;
	z = ( far + near ) / p;

	m.n11 = 2 / w; m.n12 = 0;     m.n13 = 0;      m.n14 = -x;
	m.n21 = 0;     m.n22 = 2 / h; m.n23 = 0;      m.n24 = -y;
	m.n31 = 0;     m.n32 = 0;     m.n33 = -2 / p; m.n34 = -z;
	m.n41 = 0;     m.n42 = 0;     m.n43 = 0;      m.n44 = 1;

	return m;
};


/*
 * Camera class based on three.js http://github.com/mrdoob/three.js, Copyright (c) Mr.doob http://mrdoob.com/, MIT License http://github.com/mrdoob/three.js/blob/master/LICENSE 
 */

var Camera = function (fov, aspect, near, far) {
	this.projectionMatrix = Matrix4.makePerspective(fov, aspect, near, far);
};

Camera.prototype = {
  position: new Vector3,
  target: {
    position: new Vector3
  },
  up: new Vector3(0, 1, 0),
  matrix: new Matrix4,
  
  updateMatrix: function() {
    this.matrix.lookAt(this.position, this.target.position, this.up);
  }
};


Canvas.Base['3D'] = new Class({
  Implements: Canvas.Base['2D'],
  
  program: null,
  camera: null,
  
  initialize: function(viz) {
    this.viz = viz;
    this.opt = viz.config;
    this.size = false;
    this.createCanvas();
    this.initWebGL();
    this.initCamera();
  },
  
  initWebGL: function() {
    //initialize context
    var gl = this.getCtx();
    //get viewport size
    var size = this.getSize();
    //compile and get shaders
    var fragmentShader = this.getShader(Canvas.Base['3D'].FragmentShader, gl.FRAGMENT_SHADER);
    var vertexShader = this.getShader(Canvas.Base['3D'].VertexShader, gl.VERTEX_SHADER);
    //create program and link shaders
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw "Could not link shaders";
    }
    gl.useProgram(program);
    //bind name to variable location in shaders
    $.extend(program, {
      'viewMatrix': gl.getUniformLocation(program, 'viewMatrix'),
      'projectionMatrix': gl.getUniformLocation(program, 'projectionMatrix'),
      'normalMatrix': gl.getUniformLocation(program, 'normalMatrix'),
      'color': gl.getUniformLocation(program, 'color'),
      
      'enableLighting': gl.getUniformLocation(program, 'enableLighting'),
      'ambientColor': gl.getUniformLocation(program, 'ambientColor'),
      'directionalColor': gl.getUniformLocation(program, 'directionalColor'),
      'lightingDirection': gl.getUniformLocation(program, 'lightingDirection'),
      
      'position': gl.getAttribLocation(program, 'position'),
      'normal': gl.getAttribLocation(program, 'normal'),
    });
    gl.enableVertexAttribArray(program.position);
    gl.enableVertexAttribArray(program.normal);
    this.program = program;
    //set general rendering options
    gl.clearColor(0, 0, 0, 0);
    gl.clearDepth(1);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    
    gl.viewport(0, 0, size.width, size.height);
  },
  
  initCamera: function() {
    var size = this.getSize();
    var camera = new Camera(75, size.width / size.height, 1, 1000);
    camera.position.z = 500;
    this.camera = camera;
  },
  
  getShader: function(src, type) {
    var gl = this.ctx;
    var shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      var info = gl.getShaderInfoLog(shader);
      throw "Could not compile shader src: " + info;
    }
    return shader;
  },

  getCtx: function() {
    if(!this.ctx) 
      return this.ctx = this.canvas.getContext('experimental-webgl');
    return this.ctx;
  },
  
  resize: function(width, height) {
    var size = this.getSize(),
        canvas = this.canvas,
        styles = canvas.style,
        gl = this.getCtx();
    this.size = false;
    canvas.width = width;
    canvas.height = height;
    styles.width = width + "px";
    styles.height = height + "px";
    gl.viewport(0, 0, width, height);

    this.translateOffsetX =
      this.translateOffsetY = 0;
    this.scaleOffsetX = 
      this.scaleOffsetY = 1;
    this.clear();
    this.viz.resize(width, height, this);
  },

  translateToCenter: $.empty,
  scale: $.empty,
  
  translate: function(x, y, z, disablePlot) {
    var sx = this.scaleOffsetX,
        sy = this.scaleOffsetY;
    this.translateOffsetX += x*sx;
    this.translateOffsetY += y*sy;
    var pos = this.camera.position;
    pos.x += x;
    pos.y += y;
    pos.z += z;
    !disablePlot && this.plot();
  },

  clear: function(){
    var gl = this.getCtx();
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    //TODO(nico) is this OK? I mean, to put this line here.
    this.camera.updateMatrix();
  },
  
  plot: function() {
    this.clear();
    this.viz.plot(this);
  }
});

//Shaders code
Canvas.Base['3D'].FragmentShader = [
  "#ifdef GL_ES",
  "precision highp float;",
  "#endif",
  
  "varying vec4 vcolor;",
  "varying vec3 lightWeighting;",
  
  "void main(){",
  
    "gl_FragColor = vec4(vcolor.rgb * lightWeighting, vcolor.a);",
  
  "}"
].join("\n");

Canvas.Base['3D'].VertexShader = [
  "attribute vec3 position;",
  "attribute vec3 normal;",
  "uniform vec4 color;",
  
  "uniform mat4 viewMatrix;",
  "uniform mat4 projectionMatrix;",
  "uniform mat4 normalMatrix;",

  "uniform bool enableLighting;",
  "uniform vec3 ambientColor;",
  "uniform vec3 directionalColor;",
  "uniform vec3 lightingDirection;",
  
  "varying vec4 vcolor;",
  "varying vec3 lightWeighting;",
  
  "void main(void) {",
  
    "if(!enableLighting) {",
      "lightWeighting = vec3(1.0, 1.0, 1.0);",
    "} else {",
      "vec4 transformedNormal = normalMatrix * vec4(normal, 1.0);",
      "float directionalLightWeighting = max(dot(transformedNormal.xyz, lightingDirection), 0.0);",
      "lightWeighting = ambientColor + directionalColor * directionalLightWeighting;",
    "}",
    
    "vcolor = color;",
    "gl_Position = projectionMatrix * viewMatrix * vec4( position, 1.0 );",
  
  "}"
].join("\n");

/*
 * Some of the geometries where inspired by three.js http://github.com/mrdoob/three.js, Copyright (c) Mr.doob http://mrdoob.com/, MIT License http://github.com/mrdoob/three.js/blob/master/LICENSE 
 */

var O3D = {};

$jit.O3D = O3D;

O3D.base = new Class({
  //array of { x, y, z } of float
  vertices: [],
  //array of { a, b, c, d? } of int
  faces: [],
  //updated on plotNode/plotEdge
  position: new Vector3,
  rotation: new Vector3,
  scale: new Vector3(1, 1, 1),
  //intrinsic coordinates
  matrix: new Matrix4,
  
  update: function(elem) {
    if(elem.nodeFrom && elem.nodeTo) {
      this.updateEdge(elem);
    } else {
      this.updateNode(elem);
    }
  },
  
  updateNode: $.empty,
  
  updateEdge: function(elem) {
    this.updateNode(elem);
  },

  updateMatrix: function() {
    var pos = this.position,
        rot = this.rotation,
        scale = this.scale,
        matrix = this.matrix;
    
    matrix.identity();
  
    matrix.$multiply( Matrix4.translationMatrix( pos.x, pos.y, pos.z ) );
    matrix.$multiply( Matrix4.rotationXMatrix( rot.x ) );
    matrix.$multiply( Matrix4.rotationYMatrix( rot.y ) );
    matrix.$multiply( Matrix4.rotationZMatrix( rot.z ) );
    matrix.$multiply( Matrix4.scaleMatrix( scale.x, scale.y, scale.z ) );
  },
  //compute faces normals
  computeNormals: function () {
    for (var f=0, vs=this.vertices, fs=this.faces, len=fs.length; f < len; f++) {
      var va = vs[fs[f].a],
          vb = vs[fs[f].b],
          vc = vs[fs[f].c],
          cb = new Vector3,
          ab = new Vector3;
      
      cb.sub(vc, vb);
      ab.sub(va, vb);
      cb.$cross(ab);

      if (!cb.isZero()) cb.normalize();
      
      fs[f].normal = cb;
    }
  }
});

//IsoCube
function IsoCube() {
  var vs = this.vertices,
      f4 = this.faces,
      vsp = function(x, y, z) { vs.push({ x: x, y: y, z: z }); },
      f4p = function(a, b, c, d) { f4.push({ a: a, b: b, c: c, d: d }); };
  
  vsp( 1,  1, -1);
  vsp( 1, -1, -1);
  vsp(-1, -1, -1);
  vsp(-1,  1, -1);
  vsp( 1,  1,  1);
  vsp( 1, -1,  1);
  vsp(-1, -1,  1);
  vsp(-1,  1,  1);
  
  f4p(0, 1, 2, 3);
  f4p(4, 7, 6, 5);
  f4p(0, 4, 5, 1);
  f4p(1, 5, 6, 2);
  f4p(2, 6, 7, 3);
  f4p(4, 0, 3, 7);
}

//Cube
O3D.cube = new Class({
  Implements: O3D.base,
  
  initialize: function() {
    IsoCube.call(this);
    this.computeNormals();
  },
  
  updateNode: function(obj) {
    var dim = obj.getData('dim'),
        pos = obj.pos;
    
    this.position.setc(pos.x, pos.y, pos.z);
    this.scale.setc(dim, dim, dim);
    this.updateMatrix();
  }
});

O3D.sphere = new Class({
  Implements: O3D.base,
  
  radius: 1,
  segments_width: 10,
  segments_height: 10,
  
  initialize: function() {
    var radius = this.radius,
        segments_width = this.segments_width,
        segments_height = this.segments_height,
        gridX = segments_width || 8,
        gridY = segments_height || 6,
        cos = Math.cos,
        sin = Math.sin,
        max = Math.max,
        pi = Math.PI;
  
    var iHor = max(3, gridX),
        iVer = max(2, gridY),
        aVtc = [];
  
    for(var j=0; j < (iVer + 1) ; j++) {
      var fRad1 = j / iVer,
          fZ = radius * cos(fRad1 * pi),
          fRds = radius * sin(fRad1 * pi),
          aRow = [],
          oVtx = 0;

      for(var i=0; i<iHor; i++) {
        var fRad2 = 2 * i / iHor,
            fX = fRds * Math.sin(fRad2 * pi),
            fY = fRds * Math.cos(fRad2 * pi);
        if (!(( j == 0 || j == iVer) && i > 0)) {
          oVtx = this.vertices.push({ x: fY, y: fZ, z: fX}) - 1;
        }
        aRow.push(oVtx);
      }
      aVtc.push(aRow);
    }
  
    var iVerNum = aVtc.length;
    for (var j=0; j<iVerNum; j++) {
      var iHorNum = aVtc[j].length;
      if (j > 0) {
        for (var i = 0; i<iHorNum; i++ ) {
          var bEnd = i == ( iHorNum - 1 );
          var aP1 = aVtc[j][ bEnd ? 0 : i + 1 ];
          var aP2 = aVtc[j][ ( bEnd ? iHorNum - 1 : i ) ];
          var aP3 = aVtc[j -1][ ( bEnd ? iHorNum - 1 : i ) ];
          var aP4 = aVtc[j -1][ bEnd ? 0 : i + 1 ];
  
          if(j < ( aVtc.length - 1)) {
            this.faces.push({ a: aP1, b: aP2, c: aP3 });
          }
          if(j > 1) {
            this.faces.push({ a: aP1, b: aP3, c: aP4 });
          }
        }
      }
    }
    this.computeNormals();
  },
  
  updateNode: function(obj) {
    var dim = obj.getData('dim'),
        pos = obj.pos;
    
    this.position.setc(pos.x, pos.y, pos.z);
    this.scale.setc(dim, dim, dim);
    this.updateMatrix();
  }

});


O3D.tube = new Class({
  Implements: O3D.base,
  
  numSegs: 10,
  dim: 1,
  initialize: function() {
    var vs = this.vertices,
        f4 = this.faces,
        vsp = function(x, y, z) { vs.push({ x: x, y: y, z: z }); },
        f4p = function(a, b, c, d) { f4.push({ a: a, b: b, c: c, d: d }); };

    var scope = this,
        sin = Math.sin,
        cos = Math.cos,
        pi = Math.PI,
        pi2 = pi * 2,
        numSegs = this.numSegs,
        topRad = this.dim,
        botRad = this.dim;
  
    // Top circle vertices
    for (var i = 0; i < numSegs; i++) {
      vsp(sin(pi2 * i / numSegs) * topRad, cos(pi2 * i / numSegs) * topRad, -0.5);
    }
    // Bottom circle vertices
    for (var i = 0; i < numSegs; i++) {
      vsp(sin(pi2 * i / numSegs) * botRad, cos(pi2 * i / numSegs) * botRad, 0.5);
    }
    // Body 
    for (var i = 0; i < numSegs; i++) {
      f4p(i, (i + 1) % numSegs, numSegs + (i + 1) % numSegs, i + numSegs);
    }
    this.computeNormals();
  },
  
  updateEdge: function(obj) {
    var lineWidth = obj.getData('lineWidth'),
        nodeFrom = obj.nodeFrom,
        nodeTo = obj.nodeTo,
        nodeFromPos = nodeFrom.pos,
        nodeToPos = nodeTo.pos,
        dist = nodeFromPos.distanceTo(nodeToPos),
        middle = new Vector3,
        currentDir = new Vector3(0, 0, 1),
        dvec = new Vector3;
    
    middle.add(nodeFromPos, nodeToPos).$scale(0.5);
    dvec.sub(nodeToPos, nodeFromPos).normalize();
    
    var c = dvec.dot(currentDir),
        xc = dvec.dot(new Vector3(1, 0, 0)),
        yc = dvec.dot(new Vector3(0, 1, 0)),
        t = 1 - c,
        rotAngle = Math.acos(c),
        s = Math.sin(rotAngle),
        rotAxis = currentDir.$cross(dvec).normalize(),
        x = rotAxis.x,
        y = rotAxis.y,
        z = rotAxis.z;
    
    var rot = new Matrix4();
    rot.n11 = t * x * x + c;
    rot.n12 = t * x * y - s * z;
    rot.n13 = t * x * z + s * y;
    rot.n21 = t * x * y + s * z;
    rot.n22 = t * y * y + c;
    rot.n23 = t * y * z - s * x;
    rot.n31 = t * x * z - s * y;
    rot.n32 = t * y * z + s * x;
    rot.n33 = t * z * z + c;
    this.rotationMatrix = rot;
    this.scale.setc(lineWidth, lineWidth, dist);
    this.position.setc(middle.x, middle.y, middle.z);
    this.updateMatrix();
  },
  
  updateMatrix: function() {
    var pos = this.position,
        scale = this.scale,
        matrix = this.matrix;
    
    matrix.identity();
  
    matrix.$multiply( Matrix4.translationMatrix( pos.x, pos.y, pos.z ) );
    matrix.$multiply( this.rotationMatrix );
    matrix.$multiply( Matrix4.scaleMatrix( scale.x, scale.y, scale.z ) );
  }

}); 


/*
 * File: Layouts.ForceDirected3D.js
 *
*/

/*
 * Class: Layouts.ForceDirected3D
 * 
 * Implements a Force Directed Layout.
 * 
 * Implemented By:
 * 
 * <ForceDirected3D>
 * 
 */
Layouts.ForceDirected3D = new Class({

  getOptions: function() {
    var s = this.canvas.getSize();
    var w = s.width, h = s.height;
    //count nodes
    var count = 0;
    this.graph.eachNode(function(n) { 
      count++;
    });
    var k2 = w * h / count, k = Math.sqrt(k2);
    var l = this.config.levelDistance;
    
    return {
      width: w,
      height: h,
      tstart: w * 0.1,
      nodef: function(x) { return k2 / (x || 1); },
      edgef: function(x) { return /* x * x / k; */ k * (x - l); }
    };
  },
  
  compute: function(property, incremental) {
    var prop = $.splat(property || ['current', 'start', 'end']);
    var opt = this.getOptions();
    NodeDim.compute(this.graph, prop, this.config);
    this.graph.computeLevels(this.root, 0, "ignore");
    this.graph.eachNode(function(n) {
      $.each(prop, function(p) {
        var pos = n.getPos(p);
        if(pos.isZero()) {
          pos.x = opt.width/5 * (Math.random() - 0.5);
          pos.y = opt.height/5 * (Math.random() - 0.5);
          pos.z = 200 * (Math.random() - 0.5);
        }
        //initialize disp vector
        n.disp = {};
        $.each(prop, function(p) {
          n.disp[p] = $V3(0, 0, 0);
        });
      });
    });
    this.computePositions(prop, opt, incremental);
  },
  
  computePositions: function(property, opt, incremental) {
    var times = this.config.iterations, i = 0, that = this;
    if(incremental) {
      (function iter() {
        for(var total=incremental.iter, j=0; j<total; j++) {
          opt.t = opt.tstart * (1 - i++/(times -1));
          that.computePositionStep(property, opt);
          if(i >= times) {
            incremental.onComplete();
            return;
          }
        }
        incremental.onStep(Math.round(i / (times -1) * 100));
        setTimeout(iter, 1);
      })();
    } else {
      for(; i < times; i++) {
        opt.t = opt.tstart * (1 - i/(times -1));
        this.computePositionStep(property, opt);
      }
    }
  },
  
  computePositionStep: function(property, opt) {
    var graph = this.graph;
    var min = Math.min, max = Math.max;
    var dpos = $V3(0, 0, 0);
    //calculate repulsive forces
    graph.eachNode(function(v) {
      //initialize disp
      $.each(property, function(p) {
        v.disp[p].x = 0; 
        v.disp[p].y = 0;
        v.disp[p].z = 0;
      });
      graph.eachNode(function(u) {
        if(u.id != v.id) {
          $.each(property, function(p) {
            var vp = v.getPos(p), up = u.getPos(p);
            dpos.x = vp.x - up.x;
            dpos.y = vp.y - up.y;
            dpos.z = vp.z - up.z;
            var norm = dpos.norm() || 1;
            v.disp[p].$add(dpos
                .$scale(opt.nodef(norm) / norm));
          });
        }
      });
    });
    //calculate attractive forces
    var T = !!graph.getNode(this.root).visited;
    graph.eachNode(function(node) {
      node.eachAdjacency(function(adj) {
        var nodeTo = adj.nodeTo;
        if(!!nodeTo.visited === T) {
          $.each(property, function(p) {
            var vp = node.getPos(p), up = nodeTo.getPos(p);
            dpos.x = vp.x - up.x;
            dpos.y = vp.y - up.y;
            dpos.z = vp.z - up.z;
            var norm = dpos.norm() || 1;
            node.disp[p].$add(dpos.$scale(-opt.edgef(norm) / norm));
            nodeTo.disp[p].$add(dpos.$scale(-1));
          });
        }
      });
      node.visited = !T;
    });
    //arrange positions to fit the canvas
    var t = opt.t, w2 = opt.width / 2, h2 = opt.height / 2;
    graph.eachNode(function(u) {
      $.each(property, function(p) {
        var disp = u.disp[p];
        var norm = disp.norm() || 1;
        var p = u.getPos(p);
        p.$add($V3(disp.x * min(Math.abs(disp.x), t) / norm, 
                   disp.y * min(Math.abs(disp.y), t) / norm,
                   disp.z * min(Math.abs(disp.z), t) / norm));
        p.x = min(w2, max(-w2, p.x));
        p.y = min(h2, max(-h2, p.y));
        p.z = min(h2, max(-h2, p.z));
      });
    });
  }
});

$jit.ForceDirected3D = new Class( {

  Implements: [ Loader, Extras, Layouts.ForceDirected3D ],

  initialize: function(controller) {
    var $ForceDirected3D = $jit.ForceDirected3D;

    var config = {
      iterations: 50,
      levelDistance: 50
    };

    this.controller = this.config = $.merge(Options("Canvas", "Node", "Edge",
        "Fx", "Tips", "NodeStyles", "Events", "Navigation", "Controller", "Label"), config, controller);

    var canvasConfig = this.config;
    if(canvasConfig.useCanvas) {
      this.canvas = canvasConfig.useCanvas;
      this.config.labelContainer = this.canvas.id + '-label';
    } else {
      if(canvasConfig.background) {
        canvasConfig.background = $.merge({
          type: 'Circles'
        }, canvasConfig.background);
      }
      this.canvas = new Canvas(this, canvasConfig);
      this.config.labelContainer = (typeof canvasConfig.injectInto == 'string'? canvasConfig.injectInto : canvasConfig.injectInto.id) + '-label';
    }

    this.graphOptions = {
      'klass': Vector3,
      'Node': {
        'selected': false,
        'exist': true,
        'drawn': true
      }
    };
    this.graph = new Graph(this.graphOptions, this.config.Node,
        this.config.Edge);
    this.labels = new $ForceDirected3D.Label[canvasConfig.Label.type](this);
    this.fx = new $ForceDirected3D.Plot(this, $ForceDirected3D);
    this.op = new $ForceDirected3D.Op(this);
    this.json = null;
    this.busy = false;
    // initialize extras
    this.initializeExtras();
  },

  /* 
    refresh 
    
    Computes positions and plots the tree.
  */
  refresh: function() {
    this.compute();
    this.plot();
  },

  reposition: function() {
    this.compute('end');
  },

/*
  computeIncremental
  
  Performs the Force Directed algorithm incrementally.
  
  Description:
  
  ForceDirected3D algorithms can perform many computations and lead to JavaScript taking too much time to complete. 
  This method splits the algorithm into smaller parts allowing the user to track the evolution of the algorithm and 
  avoiding browser messages such as "This script is taking too long to complete".
  
  Parameters:
  
  opt - (object) The object properties are described below
  
  iter - (number) Default's *20*. Split the algorithm into pieces of _iter_ iterations. For example, if the _iterations_ configuration property 
  of your <ForceDirected3D> class is 100, then you could set _iter_ to 20 to split the main algorithm into 5 smaller pieces.
  
  property - (string) Default's *end*. Whether to update starting, current or ending node positions. Possible values are 'end', 'start', 'current'. 
  You can also set an array of these properties. If you'd like to keep the current node positions but to perform these 
  computations for final animation positions then you can just choose 'end'.
  
  onStep - (function) A callback function called when each "small part" of the algorithm completed. This function gets as first formal 
  parameter a percentage value.
  
  onComplete - A callback function called when the algorithm completed.
  
  Example:
  
  In this example I calculate the end positions and then animate the graph to those positions
  
  (start code js)
  var fd = new $jit.ForceDirected3D(...);
  fd.computeIncremental({
    iter: 20,
    property: 'end',
    onStep: function(perc) {
      Log.write("loading " + perc + "%");
    },
    onComplete: function() {
      Log.write("done");
      fd.animate();
    }
  });
  (end code)
  
  In this example I calculate all positions and (re)plot the graph
  
  (start code js)
  var fd = new ForceDirected3D(...);
  fd.computeIncremental({
    iter: 20,
    property: ['end', 'start', 'current'],
    onStep: function(perc) {
      Log.write("loading " + perc + "%");
    },
    onComplete: function() {
      Log.write("done");
      fd.plot();
    }
  });
  (end code)
  
  */
  computeIncremental: function(opt) {
    opt = $.merge( {
      iter: 20,
      property: 'end',
      onStep: $.empty,
      onComplete: $.empty
    }, opt || {});

    this.config.onBeforeCompute(this.graph.getNode(this.root));
    this.compute(opt.property, opt);
  },

  /*
    plot
   
    Plots the ForceDirected3D graph. This is a shortcut to *fx.plot*.
   */
  plot: function() {
    this.fx.plot();
  },

  /*
     animate
    
     Animates the graph from the current positions to the 'end' node positions.
  */
  animate: function(opt) {
    this.fx.animate($.merge( {
      modes: [ 'linear' ]
    }, opt || {}));
  }
});

$jit.ForceDirected3D.$extend = true;

(function(ForceDirected3D) {

  /*
     ForceDirected3D.Op
     
     Custom extension of <Graph.Op>.

     Extends:

     All <Graph.Op> methods
     
     See also:
     
     <Graph.Op>

  */
  ForceDirected3D.Op = new Class( {

    Implements: Graph.Op

  });

  /*
    ForceDirected3D.Plot
    
    Custom extension of <Graph.Plot>.
  
    Extends:
  
    All <Graph.Plot> methods
    
    See also:
    
    <Graph.Plot>
  
  */
  ForceDirected3D.Plot = new Class( {

    Implements: Graph.Plot3D

  });

  /*
    ForceDirected3D.Label
    
    Custom extension of <Graph.Label>. 
    Contains custom <Graph.Label.SVG>, <Graph.Label.HTML> and <Graph.Label.Native> extensions.
  
    Extends:
  
    All <Graph.Label> methods and subclasses.
  
    See also:
  
    <Graph.Label>, <Graph.Label.Native>, <Graph.Label.HTML>, <Graph.Label.SVG>.
  
  */
  ForceDirected3D.Label = {};

  /*
     ForceDirected3D.Label.Native
     
     Custom extension of <Graph.Label.Native>.

     Extends:

     All <Graph.Label.Native> methods

     See also:

     <Graph.Label.Native>

  */
  ForceDirected3D.Label.Native = new Class( {
    Implements: Graph.Label.Native
  });

  /*
    ForceDirected3D.Label.SVG
    
    Custom extension of <Graph.Label.SVG>.
  
    Extends:
  
    All <Graph.Label.SVG> methods
  
    See also:
  
    <Graph.Label.SVG>
  
  */
  ForceDirected3D.Label.SVG = new Class( {
    Implements: Graph.Label.SVG,

    initialize: function(viz) {
      this.viz = viz;
    },

    /* 
       placeLabel

       Overrides abstract method placeLabel in <Graph.Label>.

       Parameters:

       tag - A DOM label element.
       node - A <Graph.Node>.
       controller - A configuration/controller object passed to the visualization.
      
     */
    placeLabel: function(tag, node, controller) {
      var pos = node.pos.getc(true), 
          canvas = this.viz.canvas,
          ox = canvas.translateOffsetX,
          oy = canvas.translateOffsetY,
          sx = canvas.scaleOffsetX,
          sy = canvas.scaleOffsetY,
          radius = canvas.getSize();
      var labelPos = {
        x: Math.round(pos.x * sx + ox + radius.width / 2),
        y: Math.round(pos.y * sy + oy + radius.height / 2)
      };
      tag.setAttribute('x', labelPos.x);
      tag.setAttribute('y', labelPos.y);

      controller.onPlaceLabel(tag, node);
    }
  });

  /*
     ForceDirected3D.Label.HTML
     
     Custom extension of <Graph.Label.HTML>.

     Extends:

     All <Graph.Label.HTML> methods.

     See also:

     <Graph.Label.HTML>

  */
  ForceDirected3D.Label.HTML = new Class( {
    Implements: Graph.Label.HTML,

    initialize: function(viz) {
      this.viz = viz;
    },
    /* 
       placeLabel

       Overrides abstract method placeLabel in <Graph.Plot>.

       Parameters:

       tag - A DOM label element.
       node - A <Graph.Node>.
       controller - A configuration/controller object passed to the visualization.
      
     */
    placeLabel: function(tag, node, controller) {
      var pos = node.pos.getc(true), 
          canvas = this.viz.canvas,
          ox = canvas.translateOffsetX,
          oy = canvas.translateOffsetY,
          sx = canvas.scaleOffsetX,
          sy = canvas.scaleOffsetY,
          radius = canvas.getSize();
      var labelPos = {
        x: Math.round(pos.x * sx + ox + radius.width / 2),
        y: Math.round(pos.y * sy + oy + radius.height / 2)
      };
      var style = tag.style;
      style.left = labelPos.x + 'px';
      style.top = labelPos.y + 'px';
      style.display = this.fitsInCanvas(labelPos, canvas) ? '' : 'none';

      controller.onPlaceLabel(tag, node);
    }
  });

  /*
    ForceDirected3D.Plot.NodeTypes

    This class contains a list of <Graph.Node> built-in types. 
    Node types implemented are 'none', 'circle', 'triangle', 'rectangle', 'star', 'ellipse' and 'square'.

    You can add your custom node types, customizing your visualization to the extreme.

    Example:

    (start code js)
      ForceDirected3D.Plot.NodeTypes.implement({
        'mySpecialType': {
          'render': function(node, canvas) {
            //print your custom node to canvas
          },
          //optional
          'contains': function(node, pos) {
            //return true if pos is inside the node or false otherwise
          }
        }
      });
    (end code)

  */
  ForceDirected3D.Plot.NodeTypes = new Class({
    'none': {
      'render': $.empty,
      'contains': $.lambda(false)
    },
    'circle': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            dim = node.getData('dim');
        this.nodeHelper.circle.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            dim = node.getData('dim');
        return this.nodeHelper.circle.contains(npos, pos, dim);
      }
    },
    'ellipse': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        this.nodeHelper.ellipse.render('fill', pos, width, height, canvas);
        },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        return this.nodeHelper.ellipse.contains(npos, pos, width, height);
      }
    },
    'square': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            dim = node.getData('dim');
        this.nodeHelper.square.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            dim = node.getData('dim');
        return this.nodeHelper.square.contains(npos, pos, dim);
      }
    },
    'rectangle': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        this.nodeHelper.rectangle.render('fill', pos, width, height, canvas);
      },
      'contains': function(node, pos){
        var npos = node.pos.getc(true), 
            width = node.getData('width'), 
            height = node.getData('height');
        return this.nodeHelper.rectangle.contains(npos, pos, width, height);
      }
    },
    'triangle': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true), 
            dim = node.getData('dim');
        this.nodeHelper.triangle.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos) {
        var npos = node.pos.getc(true), 
            dim = node.getData('dim');
        return this.nodeHelper.triangle.contains(npos, pos, dim);
      }
    },
    'star': {
      'render': function(node, canvas){
        var pos = node.pos.getc(true),
            dim = node.getData('dim');
        this.nodeHelper.star.render('fill', pos, dim, canvas);
      },
      'contains': function(node, pos) {
        var npos = node.pos.getc(true),
            dim = node.getData('dim');
        return this.nodeHelper.star.contains(npos, pos, dim);
      }
    }
  });

  /*
    ForceDirected3D.Plot.EdgeTypes
  
    This class contains a list of <Graph.Adjacence> built-in types. 
    Edge types implemented are 'none', 'line' and 'arrow'.
  
    You can add your custom edge types, customizing your visualization to the extreme.
  
    Example:
  
    (start code js)
      ForceDirected3D.Plot.EdgeTypes.implement({
        'mySpecialType': {
          'render': function(adj, canvas) {
            //print your custom edge to canvas
          },
          //optional
          'contains': function(adj, pos) {
            //return true if pos is inside the arc or false otherwise
          }
        }
      });
    (end code)
  
  */
  ForceDirected3D.Plot.EdgeTypes = new Class({
    'none': $.empty,
    'line': {
      'render': function(adj, canvas) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true);
        this.edgeHelper.line.render(from, to, canvas);
      },
      'contains': function(adj, pos) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true);
        return this.edgeHelper.line.contains(from, to, pos, this.edge.epsilon);
      }
    },
    'arrow': {
      'render': function(adj, canvas) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true),
            dim = adj.getData('dim'),
            direction = adj.data.$direction,
            inv = (direction && direction.length>1 && direction[0] != adj.nodeFrom.id);
        this.edgeHelper.arrow.render(from, to, dim, inv, canvas);
      },
      'contains': function(adj, pos) {
        var from = adj.nodeFrom.pos.getc(true),
            to = adj.nodeTo.pos.getc(true);
        return this.edgeHelper.arrow.contains(from, to, pos, this.edge.epsilon);
      }
    }
  });

})($jit.ForceDirected3D);




 })();

if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.Utility = (function() {
	
	// helper function to determine how many lines are needed
  // Line Splitter Function
  // copyright Stephen Chapman, 19th April 2006
  // you may copy this code but please keep the copyright notice as well
  var splitLine = function (st, n) {
      var b = '';
      var s = st ? st : '';
      while (s.length > n) {
          var c = s.substring(0, n);
          var d = c.lastIndexOf(' ');
          var e = c.lastIndexOf('\n');
          if (e != -1) d = e;
          if (d == -1) d = n;
          b += c.substring(0, d) + '\n';
          s = s.substring(d + 1);
      }
      return b + s;
  };

  var nowDateFormatted = function () {
      var date = new Date(Date.now());
      var month = (date.getMonth() + 1) < 10 ? '0' + (date.getMonth() + 1) : (date.getMonth() + 1);
      var day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
      var year = date.getFullYear();

      return month + '/' + day + '/' + year;
  };

  var decodeEntities = function (desc) {
      var str, temp = document.createElement('p');
      temp.innerHTML = desc; //browser handles the topics
      str = temp.textContent || temp.innerText;
      temp = null; //delete the element;
      return str;
  }; //decodeEntities

  var getDistance = function (p1, p2) {
      return Math.sqrt(Math.pow((p2.x - p1.x), 2) + Math.pow((p2.y - p1.y), 2));
  };

  var coordsToPixels = function (coords, mapView) {
    return  {
      x: coords.x + (mapView.$parent.width() / 2) + mapView.translateX,
      y: coords.y + (mapView.$parent.height() / 2) + mapView.translateY
    };
  };

  var pixelsToCoords = function (pixels, mapView) {
    return {
        x: pixels.x - (mapView.$parent.width() / 2) - mapView.translateX,
        y: pixels.y - (mapView.$parent.height() / 2) - mapView.translateY,
    };
  };

  var getPastelColor = function () {
      var r = (Math.round(Math.random()* 127) + 127).toString(16);
      var g = (Math.round(Math.random()* 127) + 127).toString(16);
      var b = (Math.round(Math.random()* 127) + 127).toString(16);
      return Mapmaker.Utility.colorLuminance('#' + r + g + b, -0.4);
  };

  // darkens a hex value by 'lum' percentage
  var colorLuminance = function (hex, lum) {

      // validate hex string
      hex = String(hex).replace(/[^0-9a-f]/gi, '');
      if (hex.length < 6) {
          hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
      }
      lum = lum || 0;

      // convert to decimal and change luminosity
      var rgb = "#", c, i;
      for (i = 0; i < 3; i++) {
          c = parseInt(hex.substr(i*2,2), 16);
          c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
          rgb += ("00"+c).substr(c.length);
      }

      return rgb;
  };

  var generateOptionsList = function (data) {
      var newlist = "";
      for (var i = 0; i < data.length; i++) {
          newlist = newlist + '<option value="' + data[i]['id'] + '">' + data[i]['1'][1] + '</option>';
      }
      return newlist;
  };

  var checkURLisImage = function (url) {
      // when the page reloads the following regular expression will be screwed up
      // please replace it with this one before you save: /*backslashhere*.(jpeg|jpg|gif|png)$/ 
      return (url.match(/\.(jpeg|jpg|gif|png)$/) != null);
  };

  var checkURLisYoutubeVideo = function (url) {
      return (url.match(/^http:\/\/(?:www\.)?youtube.com\/watch\?(?=[^?]*v=\w+)(?:[^\s?]+)?$/) != null);
  };

	var clone = function(sourceObj) {
		return JSON.parse(JSON.stringify(sourceObj));
	};

	var extendArrayIf = function(destArray, sourceArray) {
		var i;
		for (i = 0; i < sourceArray.length; i += 1) {
			if (Mapmaker.Utility.isObject(sourceArray[i])) {
				if (destArray[i] === undefined) {
					destArray[i] = {};
				}
				extendIf(destArray[i], sourceArray[i]);
			} else if (Mapmaker.Utility.isArray(sourceArray[i])) {
				if (destArray[i] === undefined) {
					destArray[i] = [];
				}
				extendArrayIf(destArray[i], sourceArray[i]);
			} else if (destArray[i] === undefined) {
				destArray[i] = sourceArray[i];
			}
		}
	};

	var extendIf = function(destObj, sourceObj) {
		var key;
		for (key in sourceObj) {
			if (sourceObj.hasOwnProperty(key)) {
				if (Mapmaker.Utility.isObject(sourceObj[key])) {
					if (destObj[key] === undefined) {
						destObj[key] = {};
					}
					Mapmaker.Utility.extendIf(destObj[key], sourceObj[key]);
				} else if (Mapmaker.Utility.isArray(sourceObj[key])) {
					if (destObj[key] === undefined) {
						destObj[key] = [];
					}
					//Test again, incase key existed but is not an Array
					//We'll loop through, and only extend undefined array values,
					//basically source[i] where i > dest.length
					if (Mapmaker.Utility.isArray(destObj[key])) {
						extendArrayIf(destObj[key], sourceObj[key]);
					}
				} else if (destObj[key] === undefined) {
					destObj[key] = sourceObj[key];
				}
			}
		}
	};

	var isArray = function(value) {
		if ("isArray" in Array) {
			return Array.isArray(value);
		} else {
			return Object.prototype.toString.call(value) === "[object Array]";
		}
	};

	var isObject = function(value) {
		return (typeof value === "object" && value !== null &&
			!Mapmaker.Utility.isArray(value));
	};

	return {
		clone: clone,
		extendIf: extendIf,
		extendArrayIf: extendArrayIf,
		isArray: isArray,
		isObject: isObject,
		splitLine: splitLine,
		nowDateFormatted: nowDateFormatted,
		decodeEntities: decodeEntities,
		getDistance: getDistance,
		coordsToPixels: coordsToPixels,
		pixelsToCoords: pixelsToCoords,
		getPastelColor: getPastelColor,
		colorLuminance: colorLuminance,
		generateOptionsList: generateOptionsList,
		checkURLisImage: checkURLisImage,
		checkURLisYoutubeVideo: checkURLisYoutubeVideo
	};
	
}());

Mapmaker.Mixins = (function() { 
	
	var Mixins = {};

	Mixins.Visibility = {
		toggle: function() {
			if (this.isOpen) {
				this.hide();
			} else this.show();
		},
		show: function() {
			this.$el.fadeIn("fast");
			this.isOpen = true;
		},
		hide: function() {
			this.$el.fadeOut("fast");
			this.isOpen = false;
		},
		isOpen: true
	};

	return Mixins;
}());
if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.MapInfoBoxView = (function($) {

	var mapInfoBoxView = function() {
		this.events = {
			"dblclick"                : "open",
			"click .icon.doc"         : "select",
			"contextmenu .icon.doc"   : "showMenu",
			"click .mapCountIcon"     : "toggle",
			"click .title"            : "hide",
			"mouseover .title .date"  : "showTooltip"
		};

		this.className = "mapInfoBoxView";

		var html = document.getElementById("mapInfoBoxTemplate").innerHTML;
		this.template = Hogan.compile(html);
	};

	_.extend(mapInfoBoxView.prototype, Mapmaker.Mixins.Visibility);

	mapInfoBoxView.prototype.initialize = function(options) {
		_.extend(this, _.pick(options, "mapView"));

		this.mapView.$parent.append(this.render().el);
	};

	mapInfoBoxView.prototype.render = function() {
		this.$el.html(this.template.render(this.model.attributes));
		return this;
	};

	return Backbone.View.extend(new mapInfoBoxView());
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.MapInfoBoxView.events = {
	
};



Mapmaker.InfoBox = {
    isOpen: false,
    changing: false,
    selectingPermission: false,
    changePermissionText: "<div class='tooltips'>As the creator, you can change the permission of this map, but the permissions of the topics and synapses on it must be changed independently.</div>",
    nameHTML: '<span class="best_in_place best_in_place_name" id="best_in_place_map_{{id}}_name" data-url="/maps/{{id}}" data-object="map" data-attribute="name" data-type="textarea" data-activator="#mapInfoName">{{name}}</span>',
    descHTML: '<span class="best_in_place best_in_place_desc" id="best_in_place_map_{{id}}_desc" data-url="/maps/{{id}}" data-object="map" data-attribute="desc" data-nil="Click to add description..." data-type="textarea" data-activator="#mapInfoDesc">{{desc}}</span>',
    init: function () {
        var self = Mapmaker.Map.InfoBox;

        $('.mapInfoIcon').click(self.toggleBox);
        $('.mapInfoBox').click(function(event){ 
            event.stopPropagation();
        });
        $('body').click(self.close);

        self.attachEventListeners();

        self.generateBoxHTML = Hogan.compile($('#mapInfoBoxTemplate').html());
    },
    toggleBox: function (event) {
        var self = Mapmaker.Map.InfoBox;

        if (self.isOpen) self.close();
        else self.open();

        event.stopPropagation();
    },
    open: function () {
        var self = Mapmaker.Map.InfoBox;
        $('.mapInfoIcon div').addClass('hide');
        if (!self.isOpen && !self.changing) {
            self.changing = true;
            $('.mapInfoBox').fadeIn(200, function () {
                self.changing = false;
                self.isOpen = true;
            });
        }
    },
    close: function () {
        var self = Mapmaker.Map.InfoBox;

        $('.mapInfoIcon div').removeClass('hide');
        if (!self.changing) {
            self.changing = true;
            $('.mapInfoBox').fadeOut(200, function () {
                self.changing = false;
                self.isOpen = false;
                self.hidePermissionSelect();
                $('.mapContributors .tip').hide();
            });
        }
    },
    load: function () {
        var self = Mapmaker.Map.InfoBox;

        var map = Mapmaker.Active.Map;

        var obj = map.pick("permission","contributor_count","topic_count","synapse_count","created_at","updated_at");

        var isCreator = map.authorizePermissionChange(Mapmaker.Active.Mapper);
        var canEdit = map.authorizeToEdit(Mapmaker.Active.Mapper);
        var shareable = map.get('permission') !== 'private';

        obj["name"] = canEdit ? Hogan.compile(self.nameHTML).render({id: map.id, name: map.get("name")}) : map.get("name");
        obj["desc"] = canEdit ? Hogan.compile(self.descHTML).render({id: map.id, desc: map.get("desc")}) : map.get("desc");
        obj["map_creator_tip"] = isCreator ? self.changePermissionText : "";
        obj["contributors_class"] = Mapmaker.Mappers.length > 1 ? "multiple" : "";
        obj["contributors_class"] += Mapmaker.Mappers.length === 2 ? " mTwo" : "";
        obj["contributor_image"] = Mapmaker.Mappers.length > 0 ? Mapmaker.Mappers.models[0].get("image") : "/assets/user.png";
        obj["contributor_list"] = self.createContributorList();
        obj["user_name"] = isCreator ? "You" : map.get("user_name");

        var classes = isCreator ? "yourMap" : "";
        classes += canEdit ? " canEdit" : "";
        classes += shareable ? " shareable" : "";
        $(".mapInfoBox").removeClass("shareable yourMap canEdit")
            .addClass(classes)
            .html(self.generateBoxHTML.render(obj));

        self.attachEventListeners();
    },
    attachEventListeners: function () {
        var self = Mapmaker.Map.InfoBox;

        $('.mapInfoBox.canEdit .best_in_place').best_in_place();

        // because anyone who can edit the map can change the map title
        var bipName = $('.mapInfoBox .best_in_place_name');
        bipName.unbind("best_in_place:activate").bind("best_in_place:activate", function () {
            var $el = bipName.find('textarea');
            var el = $el[0];

            $el.attr('maxlength', '140');

            $('.mapInfoName').append('<div class="nameCounter forMap"></div>');

            var callback = function (data) {
                $('.nameCounter.forMap').html(data.all + '/140');
            };
            Countable.live(el, callback);
        });
        bipName.unbind("best_in_place:deactivate").bind("best_in_place:deactivate", function () {
            $('.nameCounter.forMap').remove();
        });

        $('.mapInfoName .best_in_place_name').unbind("ajax:success").bind("ajax:success", function () {
            var name = $(this).html();
            Mapmaker.Active.Map.set('name', name);
            Mapmaker.Active.Map.trigger('saved');
        });

        $('.mapInfoDesc .best_in_place_desc').unbind("ajax:success").bind("ajax:success", function () {
            var desc = $(this).html();
            Mapmaker.Active.Map.set('desc', desc);
            Mapmaker.Active.Map.trigger('saved');
        });

        $('.yourMap .mapPermission').unbind().click(self.onPermissionClick);
        // .yourMap in the unbind/bind is just a namespace for the events
        // not a reference to the class .yourMap on the .mapInfoBox
        $('.mapInfoBox.yourMap').unbind('.yourMap').bind('click.yourMap', self.hidePermissionSelect);

        $('.yourMap .mapInfoDelete').unbind().click(self.deleteActiveMap);

        $('.mapContributors span, #mapContribs').unbind().click(function(event){
            $('.mapContributors .tip').toggle();
            event.stopPropagation();
        });
        $('.mapContributors .tip').unbind().click(function(event){
            event.stopPropagation();
        });
        $('.mapContributors .tip li a').click(Mapmaker.Router.intercept);

        $('.mapInfoBox').unbind('.hideTip').bind('click.hideTip', function(){
            $('.mapContributors .tip').hide();
        });
    },
    updateNameDescPerm: function(name, desc, perm) {
        $('.mapInfoName .best_in_place_name').html(name);
        $('.mapInfoDesc .best_in_place_desc').html(desc);
        $('.mapInfoBox .mapPermission').removeClass('commons public private').addClass(perm);
    },
    createContributorList: function () {
        var self = Mapmaker.Map.InfoBox;

        var string = ""; 
        console.log("hello!!")
        string += "<ul>";

        Mapmaker.Mappers.each(function(m){
            string += '<li><a href="/explore/mapper/' + m.get("id") + '">' + '<img class="rtUserImage" width="25" height="25" src="' + m.get("image") + '" />' + m.get("name") + '</a></li>';
        });
        
        string += "</ul>";
        console.log(string);
        return string;
    },
    updateNumbers: function () {
        var self = Mapmaker.Map.InfoBox;
        var mapper = Mapmaker.Active.Mapper;

        var contributors_class = "";
        if (Mapmaker.Mappers.length === 2) contributors_class = "multiple mTwo";
        else if (Mapmaker.Mappers.length > 2) contributors_class = "multiple";

        var contributors_image = "/assets/user.png";
        if (Mapmaker.Mappers.length > 0) {
            // get the first contributor and use their image
            contributors_image = Mapmaker.Mappers.models[0].get("image");
        }
        $('.mapContributors img').attr('src', contributors_image).removeClass('multiple mTwo').addClass(contributors_class);
        $('.mapContributors span').text(Mapmaker.Mappers.length)
        $('.mapContributors .tip').html(self.createContributorList());
        $('.mapTopics').text(Mapmaker.Topics.length);
        $('.mapSynapses').text(Mapmaker.Synapses.length);

        $('.mapEditedAt').html('<span>Last edited: </span>' + Mapmaker.Util.nowDateFormatted());
    },
    onPermissionClick: function (event) {
        var self = Mapmaker.Map.InfoBox;

        if (!self.selectingPermission) {
            self.selectingPermission = true;
            $(this).addClass('minimize'); // this line flips the drop down arrow to a pull up arrow
            if ($(this).hasClass('commons')) {
                $(this).append('<ul class="permissionSelect"><li class="public"></li><li class="private"></li></ul>');
            } else if ($(this).hasClass('public')) {
                $(this).append('<ul class="permissionSelect"><li class="commons"></li><li class="private"></li></ul>');
            } else if ($(this).hasClass('private')) {
                $(this).append('<ul class="permissionSelect"><li class="commons"></li><li class="public"></li></ul>');
            }
            $('.mapPermission .permissionSelect li').click(self.selectPermission);
            event.stopPropagation();
        }
    },
    hidePermissionSelect: function () {
        var self = Mapmaker.Map.InfoBox;

        self.selectingPermission = false;
        $('.mapPermission').removeClass('minimize'); // this line flips the pull up arrow to a drop down arrow
        $('.mapPermission .permissionSelect').remove();
    },
    selectPermission: function (event) {
        var self = Mapmaker.Map.InfoBox;

        self.selectingPermission = false;
        var permission = $(this).attr('class');
        var permBefore = Mapmaker.Active.Map.get('permission');
        Mapmaker.Active.Map.save({
            permission: permission
        });
        Mapmaker.Active.Map.updateMapWrapper();
        if (permBefore !== 'commons' && permission === 'commons') {
            Mapmaker.Realtime.setupSocket();
            Mapmaker.Realtime.turnOn();
        }
        else if (permBefore === 'commons' && permission === 'public') {
            Mapmaker.Realtime.turnOff(true); // true is to 'silence' 
            // the notification that would otherwise be sent
        }
        shareable = permission === 'private' ? '' : 'shareable';
        $('.mapPermission').removeClass('commons public private minimize').addClass(permission);
        $('.mapPermission .permissionSelect').remove();
        $('.mapInfoBox').removeClass('shareable').addClass(shareable);
        event.stopPropagation();
    },
    deleteActiveMap: function () {
        var confirmString = 'Are you sure you want to delete this map? ';
        confirmString += 'This action is irreversible. It will not delete the topics and synapses on the map.';

        var doIt = confirm(confirmString);
        var map = Mapmaker.Active.Map;
        var mapper = Mapmaker.Active.Mapper;
        var authorized = map.authorizePermissionChange(mapper);

        if (doIt && authorized) {
            Mapmaker.Map.InfoBox.close();
            Mapmaker.Maps.Active.remove(map);
            Mapmaker.Maps.Featured.remove(map);
            Mapmaker.Maps.Mine.remove(map);
            map.destroy();
            Mapmaker.Router.home();
            Mapmaker.GlobalUI.notifyUser('Map eliminated!');
        }
        else if (!authorized) {
            alert('Hey now. We can\'t just go around willy nilly deleting other people\'s maps now can we? Run off and find something constructive to do, eh?');
        }
    }
};

Mapmaker.MetacodeSetSwitchView = (function($) {

	var metacodeSetSwitchView = function() {
		this.events = {
			"dblclick"                : "open",
			"click .icon.doc"         : "select",
			"contextmenu .icon.doc"   : "showMenu",
			"click .mapCountIcon"     : "toggle",
			"click .title"            : "hide",
			"mouseover .title .date"  : "showTooltip"
		};

		this.className = "metacodeSetSwitchView";

		var html = document.getElementById("metacodeSetSwitchTemplate").innerHTML;
		this.template = Hogan.compile(html);
	};

	_.extend(metacodeSetSwitchView.prototype, Mapmaker.Mixins.Visibility);

	metacodeSetSwitchView.prototype.initialize = function(options) {
		_.extend(this, _.pick(options, "mapView"));

		this.mapView.$parent.append(this.render().el);
	};

	metacodeSetSwitchView.prototype.render = function() {
		this.$el.html();
		return this;
	};

	return Backbone.View.extend(new metacodeSetSwitchView());
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.MetacodeSetSwitchView.events = {
	switch: "Mapmaker:MetacodeSetSwitchView:switch"
};



Mapmaker.FilterView = (function($) {

	var filterView = function() {
		this.events = {
			"dblclick"                : "open",
			"click .icon.doc"         : "select",
			"contextmenu .icon.doc"   : "showMenu",
			"click .mapCountIcon"     : "toggle",
			"click .title"            : "hide",
			"mouseover .title .date"  : "showTooltip"
		};

		this.className = "filterView";

		var html = document.getElementById("filterTemplate").innerHTML;
		this.template = Hogan.compile(html);
	};

	_.extend(filterView.prototype, Mapmaker.Mixins.Visibility);

	filterView.prototype.initialize = function(options) {
		_.extend(this, _.pick(options, "mapView"));

		this.mapView.$parent.append(this.render().el);
	};

	filterView.prototype.render = function() {
		this.$el.html();
		return this;
	};

	return Backbone.View.extend(new filterView());
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.FilterView.events = {
	change: "Mapmaker:FilterView:change"
};


Mapmaker.Filter = {
    filters: {
        name: "",
        metacodes: [],
        mappers: [],
        synapses: []
    },
    visible: {
        metacodes: [],
        mappers: [],
        synapses: []
    },
    isOpen: false,
    changing: false,
    init: function () {
        var self = Mapmaker.Filter;

        $('.sidebarFilterIcon').click(self.toggleBox);

        $('.sidebarFilterBox .showAllMetacodes').click(self.filterNoMetacodes);
        $('.sidebarFilterBox .showAllSynapses').click(self.filterNoSynapses);
        $('.sidebarFilterBox .showAllMappers').click(self.filterNoMappers);
        $('.sidebarFilterBox .hideAllMetacodes').click(self.filterAllMetacodes);
        $('.sidebarFilterBox .hideAllSynapses').click(self.filterAllSynapses);
        $('.sidebarFilterBox .hideAllMappers').click(self.filterAllMappers);

        self.bindLiClicks();
	    self.getFilterData();
    },
    toggleBox: function (event) {
        var self = Mapmaker.Filter;

        if (self.isOpen) self.close();
        else self.open();

        event.stopPropagation();
    },
    open: function () {
        var self = Mapmaker.Filter;

        Mapmaker.GlobalUI.Account.close();
        Mapmaker.Realtime.close();
        $('.sidebarFilterIcon div').addClass('hide');


        if (!self.isOpen && !self.changing) {
            self.changing = true;

            var height = $(document).height() - 108;
            $('.sidebarFilterBox').css('max-height', height + 'px').fadeIn(200, function () {
                self.changing = false;
                self.isOpen = true;
            });
        }
    },
    close: function () {
        var self = Mapmaker.Filter;
        $('.sidebarFilterIcon div').removeClass('hide');


        if (!self.changing) {
            self.changing = true;

            $('.sidebarFilterBox').fadeOut(200, function () {
                self.changing = false;
                self.isOpen = false;
            });
        }
    },
    reset: function () {
        var self = Mapmaker.Filter;

        self.filters.metacodes = [];
        self.filters.mappers = [];
        self.filters.synapses = [];
        self.visible.metacodes = [];
        self.visible.mappers = [];
        self.visible.synapses = [];

        $('#filter_by_metacode ul').empty(); 
        $('#filter_by_mapper ul').empty();
        $('#filter_by_synapse ul').empty();

        $('.filterBox .showAll').addClass('active');
    },
    /*  
    Most of this data essentially depends on the ruby function which are happening for filter inside view filterBox
    But what these function do is load this data into three accessible array within java : metacodes, mappers and synapses
    */
    getFilterData: function () {
        var self = Mapmaker.Filter;

        var metacode, mapper, synapse;

        $('#filter_by_metacode li').each(function() {
            metacode = $( this ).attr('data-id');
            self.filters.metacodes.push(metacode);
            self.visible.metacodes.push(metacode);
        }); 

        $('#filter_by_mapper li').each(function()  {
            mapper = ($( this ).attr('data-id'));
            self.filters.mappers.push(mapper);
            self.visible.mappers.push(mapper);
        });

        $('#filter_by_synapse li').each(function()  {
            synapse = ($( this ).attr('data-id'));  
            self.filters.synapses.push(synapse);
            self.visible.synapses.push(synapse);
        });
    },
    bindLiClicks: function () {
        var self = Mapmaker.Filter;
        $('#filter_by_metacode ul li').unbind().click(self.toggleMetacode);
        $('#filter_by_mapper ul li').unbind().click(self.toggleMapper);
        $('#filter_by_synapse ul li').unbind().click(self.toggleSynapse);
    },
    // an abstraction function for checkMetacodes, checkMappers, checkSynapses to reduce
    // code redundancy
    /*
    @param 
    */
    updateFilters: function (collection, propertyToCheck, correlatedModel, filtersToUse, listToModify) {
        var self = Mapmaker.Filter;
        
        var newList = [];
        var removed = [];
        var added = [];
        
        // the first option enables us to accept
        // ['Topics', 'Synapses'] as 'collection'
        if (typeof collection === "object") {
            Mapmaker[collection[0]].each(function(model) {
                var prop = model.get(propertyToCheck) ? model.get(propertyToCheck).toString() : false;
                if (prop && newList.indexOf(prop) === -1) {
                    newList.push(prop);
                }
            });
            Mapmaker[collection[1]].each(function(model) {
                var prop = model.get(propertyToCheck) ? model.get(propertyToCheck).toString() : false;
                if (prop && newList.indexOf(prop) === -1) {
                    newList.push(prop);
                }
            });
        }
        else if (typeof collection === "string") {
            Mapmaker[collection].each(function(model) {
                var prop = model.get(propertyToCheck) ? model.get(propertyToCheck).toString() : false;
                if (prop && newList.indexOf(prop) === -1) {
                    newList.push(prop);
                }
            });
        }
        
        removed = _.difference(self.filters[filtersToUse], newList);
        added = _.difference(newList, self.filters[filtersToUse]);
        
        // remove the list items for things no longer present on the map
        _.each(removed, function(identifier) {
            $('#filter_by_' + listToModify + ' li[data-id="' + identifier + '"]').fadeOut('fast',function(){
                $(this).remove();
            });
            index = self.visible[filtersToUse].indexOf(identifier);
            self.visible[filtersToUse].splice(index, 1);
        });
        
        var model, li, jQueryLi;
        function sortAlpha(a,b){
            return a.childNodes[1].innerHTML.toLowerCase() > b.childNodes[1].innerHTML.toLowerCase() ? 1 : -1;  
        }
        // for each new filter to be added, create a list item for it and fade it in
        _.each(added, function (identifier) {
            model = Mapmaker[correlatedModel].get(identifier) || 
                Mapmaker[correlatedModel].find(function (model) {
                    return model.get(propertyToCheck) === identifier;
                });
            li = model.prepareLiForFilter();
            jQueryLi = $(li).hide();
            $('li', '#filter_by_' + listToModify + ' ul').add(jQueryLi.fadeIn("fast"))
                .sort(sortAlpha).appendTo('#filter_by_' + listToModify + ' ul');
            self.visible[filtersToUse].push(identifier);
        });

        // update the list of filters with the new list we just generated
        self.filters[filtersToUse] = newList;

        // make sure clicks on list items still trigger the right events
        self.bindLiClicks();
    },
    checkMetacodes: function () {
        var self = Mapmaker.Filter;
        self.updateFilters('Topics', 'metacode_id', 'Metacodes', 'metacodes', 'metacode');
    },
    checkMappers: function () {
        var self = Mapmaker.Filter;
        var onMap = Mapmaker.Active.Map ? true : false;
        if (onMap) {
            self.updateFilters('Mappings', 'user_id', 'Mappers', 'mappers', 'mapper');
        }
        else {
            // on topic view
            self.updateFilters(['Topics', 'Synapses'], 'user_id', 'Creators', 'mappers', 'mapper');
        }
    },
    checkSynapses: function () {
        var self = Mapmaker.Filter;
        self.updateFilters('Synapses', 'desc', 'Synapses', 'synapses', 'synapse');
    },
    filterAllMetacodes: function (e) {
        var self = Mapmaker.Filter;
        $('#filter_by_metacode ul li').addClass('toggledOff');
        $('.showAllMetacodes').removeClass('active');
        $('.hideAllMetacodes').addClass('active');
        self.visible.metacodes = [];
        self.passFilters();
    },
    filterNoMetacodes: function (e) {
        var self = Mapmaker.Filter;
        $('#filter_by_metacode ul li').removeClass('toggledOff');
        $('.showAllMetacodes').addClass('active');
        $('.hideAllMetacodes').removeClass('active');
        self.visible.metacodes = self.filters.metacodes.slice();
        self.passFilters();
    },
    filterAllMappers: function (e) {
        var self = Mapmaker.Filter;
        $('#filter_by_mapper ul li').addClass('toggledOff');
        $('.showAllMappers').removeClass('active');
        $('.hideAllMappers').addClass('active');
        self.visible.mappers = [];
        self.passFilters();       
    },
    filterNoMappers: function (e) {
        var self = Mapmaker.Filter;
        $('#filter_by_mapper ul li').removeClass('toggledOff');
        $('.showAllMappers').addClass('active');
        $('.hideAllMappers').removeClass('active');
        self.visible.mappers = self.filters.mappers.slice();
        self.passFilters();
    },
    filterAllSynapses: function (e) {
        var self = Mapmaker.Filter;
        $('#filter_by_synapse ul li').addClass('toggledOff');
        $('.showAllSynapses').removeClass('active');
        $('.hideAllSynapses').addClass('active');
        self.visible.synapses = [];
        self.passFilters();
    },
    filterNoSynapses: function (e) {
        var self = Mapmaker.Filter;
        $('#filter_by_synapse ul li').removeClass('toggledOff');
        $('.showAllSynapses').addClass('active');
        $('.hideAllSynapses').removeClass('active');
        self.visible.synapses = self.filters.synapses.slice();
        self.passFilters();
    },
    // an abstraction function for toggleMetacode, toggleMapper, toggleSynapse
    // to reduce code redundancy
    // gets called in the context of a list item in a filter box
    toggleLi: function (whichToFilter) {
        var self = Mapmaker.Filter, index;
        var id = $(this).attr("data-id");
        if (self.visible[whichToFilter].indexOf(id) == -1) {
            self.visible[whichToFilter].push(id);
            $(this).removeClass('toggledOff');
        }
        else {
            index = self.visible[whichToFilter].indexOf(id);
            self.visible[whichToFilter].splice(index, 1);
            $(this).addClass('toggledOff');
        }
        self.passFilters();
    },
    toggleMetacode: function () {
        var self = Mapmaker.Filter;
        self.toggleLi.call(this, 'metacodes');

        if (self.visible.metacodes.length === self.filters.metacodes.length) {
            $('.showAllMetacodes').addClass('active');
            $('.hideAllMetacodes').removeClass('active');
        }
        else if (self.visible.metacodes.length === 0) {
            $('.showAllMetacodes').removeClass('active');
            $('.hideAllMetacodes').addClass('active');
        }
        else {
            $('.showAllMetacodes').removeClass('active');
            $('.hideAllMetacodes').removeClass('active');
        }
    },
    toggleMapper: function () {
        var self = Mapmaker.Filter;
        self.toggleLi.call(this, 'mappers');

        if (self.visible.mappers.length === self.filters.mappers.length) {
            $('.showAllMappers').addClass('active');
            $('.hideAllMappers').removeClass('active');
        }
        else if (self.visible.mappers.length === 0) {
            $('.showAllMappers').removeClass('active');
            $('.hideAllMappers').addClass('active');
        }
        else {
            $('.showAllMappers').removeClass('active');
            $('.hideAllMappers').removeClass('active');
        }
    },
    toggleSynapse: function () {
        var self = Mapmaker.Filter;
        self.toggleLi.call(this, 'synapses');

        if (self.visible.synapses.length === self.filters.synapses.length) {
            $('.showAllSynapses').addClass('active');
            $('.hideAllSynapses').removeClass('active');
        }
        else if (self.visible.synapses.length === 0) {
            $('.showAllSynapses').removeClass('active');
            $('.hideAllSynapses').addClass('active');
        }
        else {
            $('.showAllSynapses').removeClass('active');
            $('.hideAllSynapses').removeClass('active');
        }
    },
    passFilters: function () {        
        var self = Mapmaker.Filter;
        var visible = self.visible;

        var passesMetacode, passesMapper, passesSynapse;
        var onMap;

        if (Mapmaker.Active.Map) {
            onMap = true;
        }
        else if (Mapmaker.Active.Topic) {
            onMap = false;
        }

        var opacityForFilter = onMap ? 0 : 0.4;

        Mapmaker.Topics.each(function(topic) {
            var n = topic.get('node');
            var metacode_id = topic.get("metacode_id").toString();

            if (visible.metacodes.indexOf(metacode_id) == -1) passesMetacode = false;
            else passesMetacode = true;

            if (onMap) {
                // when on a map, 
                // we filter by mapper according to the person who added the 
                // topic or synapse to the map
                var user_id = topic.getMapping().get("user_id").toString();
                if (visible.mappers.indexOf(user_id) == -1) passesMapper = false;
                else passesMapper = true;
            }
            else {
                // when on a topic view, 
                // we filter by mapper according to the person who created the 
                // topic or synapse
                var user_id = topic.get("user_id").toString();
                if (visible.mappers.indexOf(user_id) == -1) passesMapper = false;
                else passesMapper = true;
            }

            if (passesMetacode && passesMapper) {
                if (n) {
                    n.setData('alpha', 1, 'end');
                }
                else console.log(topic);
            }
            else {
                if (n) {
                    Mapmaker.Control.deselectNode(n, true);
                    n.setData('alpha', opacityForFilter, 'end');
                    n.eachAdjacency(function(e){
                        Mapmaker.Control.deselectEdge(e, true);
                    });
                }
                else console.log(topic);
            }
        });

        // flag all the edges back to 'untouched'
        Mapmaker.Synapses.each(function(synapse) {
           var e = synapse.get('edge');
           e.setData('touched', false);
        });
        Mapmaker.Synapses.each(function(synapse) {
           var e = synapse.get('edge');
           var desc;
           var user_id = synapse.get("user_id").toString();

           if (e && !e.getData('touched')) {

                var synapses = e.getData('synapses');

                // if any of the synapses represent by the edge are still unfiltered
                // leave the edge visible
                passesSynapse = false;
                for (var i = 0; i < synapses.length; i++) {
                    desc = synapses[i].get("desc");
                    if (visible.synapses.indexOf(desc) > -1) passesSynapse = true;
                }

                // if the synapse description being displayed is now being
                // filtered, set the displayIndex to the first unfiltered synapse if there is one
                var displayIndex = e.getData("displayIndex") ? e.getData("displayIndex") : 0;
                var displayedSynapse = synapses[displayIndex];
                desc = displayedSynapse.get("desc");
                if (passesSynapse && visible.synapses.indexOf(desc) == -1) {
                    // iterate and find an unfiltered one
                    for (var i = 0; i < synapses.length; i++) {
                        desc = synapses[i].get("desc");
                        if (visible.synapses.indexOf(desc) > -1) {
                            e.setData('displayIndex', i);
                            break;
                        }
                    }
                }

                if (onMap) {
                    // when on a map, 
                    // we filter by mapper according to the person who added the 
                    // topic or synapse to the map
                    user_id = synapse.getMapping().get("user_id").toString();
                }
                if (visible.mappers.indexOf(user_id) == -1) passesMapper = false;
                else passesMapper = true;

                var color = Mapmaker.Settings.colors.synapses.normal;
                if (passesSynapse && passesMapper) {
                    e.setData('alpha', 1, 'end');
                    e.setData('color', color, 'end');
                }
                else {
                    Mapmaker.Control.deselectEdge(e, true);
                    e.setData('alpha', opacityForFilter, 'end');
                }

                e.setData('touched', true);
            }
            else if (!e) console.log(synapse);
        });
            
        // run the animation
        Mapmaker.Visualize.mGraph.fx.animate({  
          modes: ['node-property:alpha',  
                'edge-property:alpha'],  
          duration: 200  
        });
    }
};

Mapmaker.JuntoView = (function($) {

	var juntoView = function() {
		this.events = {
			"dblclick"                : "open",
			"click .icon.doc"         : "select",
			"contextmenu .icon.doc"   : "showMenu",
			"click .mapCountIcon"     : "toggle",
			"click .title"            : "hide",
			"mouseover .title .date"  : "showTooltip"
		};

		this.className = "juntoView";

		var html = document.getElementById("juntoTemplate").innerHTML;
		this.template = Hogan.compile(html);
	};

	_.extend(juntoView.prototype, Mapmaker.Mixins.Visibility);

	juntoView.prototype.initialize = function(options) {
		_.extend(this, _.pick(options, "mapView"));

		this.mapView.$parent.append(this.render().el);
	};

	juntoView.prototype.render = function() {
		this.$el.html();
		return this;
	};

	return Backbone.View.extend(new juntoView());
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.JuntoView.events = {
	turnOn: "Mapmaker:JuntoView:turnOn",
	turnOff: "Mapmaker:JuntoView:turnOff"
};

Mapmaker.NewTopicView = (function($) {

	var Private = {
		
	};

	var newTopicView = function() {
		this.events = {
			"keyup [data-mm-topic-name]" : "setName",
		};

		this.className = "newTopicView";

		var html = document.getElementById("newTopicTemplate").innerHTML;
		this.template = Hogan.compile(html);
	};

	_.extend(newTopicView.prototype, Mapmaker.Mixins.Visibility);

	newTopicView.prototype.initialize = function (options) {
		_.extend(this, _.pick(options, "mapView"));

		this.name = '';
    this.newId = 1;
    this.metacode = null;
    this.x = null;
    this.y = null;
	};

	newTopicView.prototype.render = function () {
		this.$el.html(this.template.render());

    // TODO: add in initialize typeahead here

		return this;
	};

	newTopicView.prototype.setName = function (e) {
		this.name = this.$("[data-mm-topic-name]").val();
	};

	newTopicView.prototype.initializeCarousel = function (metacodes) {
		var
			self = this,
      string = '';

		this.$('[data-mm-metacode-title]').empty();

		// metacodes must be a MetacodeCollection
		metacodes.each(function(metacode){
       string += '<img class="cloudcarousel" width="40" height="40" src="' + metacode.get('icon') + '" data-id="' + metacode.id + '" title="' + metacode.get('name') + '" alt="' + metacode.get('name') + '"/>';
    });

		this.$('[data-mm-topic-metacode-image]')
			.empty()
			.append(string)
			.CloudCarousel({
        titleBox: this.$('[data-mm-metacode-title]'),
        yRadius: 40,
        xRadius: 190,
        xPos: 170,
        yPos: 40,
        speed: 0.3,
        mouseWheel: true,
        bringToFront: true,
        tabbingEl: this.$el,
        callback: function (id) {
        	self.metacode = id;
        }
    });
	};

	return Backbone.View.extend(new newTopicView());
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.NewTopicView.events = {
  switchSet: 'Mapmaker:NewTopicView:switchSet',
	create: 'Mapmaker:NewTopicView:create'
};

Mapmaker.NewSynapseView = (function($) {

	var newSynapseView = function() {
		this.events = {
			"dblclick"                : "open",
			"click .icon.doc"         : "select",
			"contextmenu .icon.doc"   : "showMenu",
			"click .mapCountIcon"     : "toggle",
			"click .title"            : "hide",
			"mouseover .title .date"  : "showTooltip"
		};

		this.className = "newSynapseView";

		var html = document.getElementById("newSynapseTemplate").innerHTML;
		this.template = Hogan.compile(html);
	};

	_.extend(newSynapseView.prototype, Mapmaker.Mixins.Visibility);

	newSynapseView.prototype.initialize = function(options) {
		_.extend(this, _.pick(options, "mapView"));

		this.mapView.$parent.append(this.render().el);
	};

	newSynapseView.prototype.render = function() {
		this.$el.html();
		return this;
	};

	return Backbone.View.extend(new newSynapseView());
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.NewSynapseView.events = {
	create: "Mapmaker:NewSynapseView:create"
};

Mapmaker.Metacode = (function() {

	return Backbone.Model.extend({
		initialize: function() {
			var image = new Image();
			image.crossOrigin = "Anonymous";
			image.src = this.get("icon");
			this.set("image", image);
		},
		prepareLiForFilter: function() {
			var li = "";
			li += "<li data-id=\"" + this.id.toString() + "\">";      
			li += "<img src=\"" + this.get("icon") + "\" data-id=\"" + this.id.toString() + "\"";
			li += " alt=\"" + this.get("name") + "\" />";      
			li += "<p>" + this.get("name").toLowerCase() + "</p></li>";
			return li;
		}
	}); // Backbone.Model.extend

}());

Mapmaker.Mapping = (function() {

	return Backbone.Model.extend({
		urlRoot: "/mappings",
		blacklist: ["created_at", "updated_at", "map", "topic"],
		toJSON: function(options) {
			return _.omit(this.attributes, this.blacklist);
		},
		initialize: function() {

		},
		getMap: function() {
			return Mapmaker.Map.get(this.get("map_id"));
		},
		getTopic: function() {
			var topic_id = this.get("topic_id");

			//hack: 'map' is currently a global
			var topicCollection = map.get("topics");

			return topicCollection.get(topic_id);
		},
		getSynapse: function() {
			var synapse_id = this.get("synapse_id");

			//hack: 'map' is currently a global
			var synapseCollection = map.get("synapses");

			return synapseCollection.get(synapse_id);
		}
	}); // Backbone.Model.extend

}());

Mapmaker.MappingView = (function($) {

	var mappingView = function(view, mapping) {

		this.view = view;
		this.mapping = mapping;
	};

	mappingView.prototype.show = function() {

	};

	mappingView.prototype.hide = function() {

	};

	mappingView.prototype.destroy = function() {

	};

	return mappingView;
}(jQuery));

Mapmaker.Topic = (function() {

	return Backbone.Model.extend({
		urlRoot: "/topics",
		blacklist: ["node", "created_at", "updated_at", "user_name", "user_image", "map_count",
			"synapse_count"],
		toJSON: function(options) {
			return _.omit(this.attributes, this.blacklist);
		},
		save: function(key, val, options) {

			var attrs;

			// Handle both `"key", value` and `{key: value}` -style arguments.
			if (key === null || typeof key === "object") {
				attrs = key;
				options = val;
			} else {
				(attrs = {})[key] = val;
			}

			var newOptions = options || {};
			var s = newOptions.success;

			var permBefore = this.get("permission");

			newOptions.success = function(model, response, opt) {
				if (s) s(model, response, opt);
				model.trigger("saved");

				if (permBefore === "private" && model.get("permission") !== "private") {
					model.trigger("noLongerPrivate");
				} else if (permBefore !== "private" && model.get("permission") === "private") {
					model.trigger("nowPrivate");
				}
			};
			return Backbone.Model.prototype.save.call(this, attrs, newOptions);
		},
		initialize: function() {
			if (this.isNew()) {
				this.set({
					"user_id": null,
					"desc": "",
					"link": "",
					"permission": "commons"
				});
			}

			this.on("nowPrivate", function() {
				var removeTopicData = {
					topicid: this.id
				};

				$(document).trigger(Mapmaker.JIT.events.removeTopic, [removeTopicData]);
			});
			this.on("noLongerPrivate", function() {
				var newTopicData = {
					mappingid: this.getMapping().id,
					topicid: this.id
				};

				$(document).trigger(Mapmaker.JIT.events.newTopic, [newTopicData]);
			});

			//this.on("change:metacode_id", Mapmaker.Filter.checkMetacodes, this);

		},
		authorizeToEdit: function(mapper) {
			if (mapper && (this.get("permission") === "commons" || this.get("user_id") === mapper.get(
				"id"))) return true;
			else return false;
		},
		authorizePermissionChange: function(mapper) {
			if (mapper && this.get("user_id") === mapper.get("id")) return true;
			else return false;
		},
		getDate: function() {

		},
		getMetacode: function() {
			return Mapmaker.Metacodes.get(this.get("metacode_id"));
		},
		getMapping: function() {

			if (!Mapmaker.Active.Map) return false;

			return Mapmaker.Mappings.findWhere({
				map_id: Mapmaker.Active.Map.id,
				topic_id: this.isNew() ? this.cid : this.id
			});
		}
	}); // Backbone.Model.extend

}());

if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.TopicMappingView = (function($, famous) {
	var Engine = famous.core.Engine;
	var Surface = famous.core.Surface;
	var ImageSurface = famous.surfaces.ImageSurface;
	var Modifier = famous.core.Modifier;
	var StateModifier = famous.modifiers.StateModifier;
	var Transform = famous.core.Transform;
	var Particle = famous.physics.bodies.Particle;
	var Repulsion = famous.physics.forces.Repulsion;

	var Handlers = {
		mousedown: function(event) {
			this.mouseIsDown = true;
			this.hasMoved = false;

			this.topicParticle.sleep();

			$(document).trigger(Mapmaker.TopicMappingView.events.mousedown);
		},
		mouseup: function(event) {
			this.topicParticle.wake();
			Private.cancelClick.call(this);
			$(document).trigger(Mapmaker.TopicMappingView.events.mouseup, [this]);

			var storedTime = this.lastClick;
	        var now = Date.now();
	        this.lastClick = now;

			if (now - storedTime < this.view.config.DOUBLE_CLICK_TOLERANCE) {
				$(document).trigger(Mapmaker.TopicMappingView.events.doubleClick, [this]);
			}
		},
		mousemove: function(event) {
			var m = this.mapping;
			var newX, newY;

			if (this.mouseIsDown) {
				if (!this.hasMoved) this.hasMoved = true;

				newX = this.topicParticle.getTransform()[12] + event.movementX;
				newY = this.topicParticle.getTransform()[13] + event.movementY;
				// modify the mapping, the saved state
				m.set("xloc", newX);
				m.set("yloc", newY);

				//this.anchorParticle.setPosition([newX, newY, 0]);
				this.topicParticle.setPosition([newX, newY, 0]);
				//this.anchorParticle.setVelocity([0, 0, 0]);
				this.topicParticle.setVelocity([0, 0, 0]);

				// when changing this topics location, trigger event with location data
				// so that mapView can move synapses attached to it
			}
		}
	};

	var Private = {
		cancelClick: function() {
			this.mouseIsDown = false;

			if (this.hasMoved) {
				// save the mapping
			}

			$(document).trigger(Mapmaker.TopicMappingView.events.dragEnd);
		},
		createImageSurface: function() {
			var self = this;
			var topic = this.mapping.getTopic();

			var updateMetacodeImage = function() {
				var metacode = self.view.metacodes.get(topic.get("metacode_id"));
				var metacodeUrl = metacode.get("icon");
				self.imageSurface.setContent(metacodeUrl);
			};
			// add listener
			topic.on("change:metacode_id", updateMetacodeImage);

			this.imageSurface = new ImageSurface({
				classes: ["noselect"],
				size: [50, 50]
			});
			updateMetacodeImage();
			this.modNode.add(this.imageSurface);

			// attach events
			var mousedownHandler = function(event) {
				event.preventDefault();
				Handlers.mousedown.call(self, event);
			};
			this.imageSurface.on("mousedown", mousedownHandler);

			var mouseupHandler = function(event) {
				Handlers.mouseup.call(self, event);
			};
			this.imageSurface.on("mouseup", mouseupHandler);

			var mousemoveHandler = function(event) {
				Handlers.mousemove.call(self, event);
			};
			//this.imageSurface.on("mousemove", mousemoveHandler);
		},
		createNameSurface: function() {
			var self = this;
			var topic = this.mapping.getTopic();

			var updateName = function() {
				self.nameSurface.setContent(topic.get("name"));
			};
			// add listener
			topic.on("change:name", updateName);

			this.nameSurface = new Surface({
				content: topic.get("name"),
				classes: ["noselect"],
				size: [true, true],
				properties: {
					marginTop: "35px",
					borderRadius: "5px",
					backgroundColor: "#FFF"
				}
			});
			this.modNode.add(this.nameSurface);

			// attach events
			var mousedownHandler = function(event) {
				Handlers.mousedown.call(self, event);
			};
			this.nameSurface.on("mousedown", mousedownHandler);

			var mouseupHandler = function(event) {
				Handlers.mouseup.call(self, event);
			};
			this.nameSurface.on("mouseup", mouseupHandler);

			var mousemoveHandler = function(event) {
				Handlers.mousemove.call(self, event);
			};
			//this.nameSurface.on("mousemove", mousemoveHandler);
		},
		attachPhysics: function () {
			var self = this;
			var m = this.mapping;
			var pos = [m.get("xloc"), m.get("yloc"), 0];

			// this one is going to stay rooted at the mapping
			this.anchorParticle = new Particle({
			  position: pos
			});
			this.view.pe.addBody(this.anchorParticle);

			// this one is going to dance and move around
			this.topicParticle = new Particle({
			  position: pos
			});
			this.view.pe.addBody(this.topicParticle);

			//var gravity = new Repulsion({
			//  strength: -3
			//});
			//this.view.pe.attach(gravity, this.topicParticle, this.anchorParticle);
			// create a new force and add it to the physics engine
      //var repel = new Repulsion({ strength: 0.5, radii: {max: 1, min: 0}});
      // for 'attach' variables to pass are (Force, Targets, Source)
      //this.view.pe.attach(repel, undefined, this.topicParticle);

			this.mod = new Modifier({
				transform: function () {
			    return self.topicParticle.getTransform();
			  }
			});

			this.modNode = this.view.originModNode.add(this.mod);
		}
	};

	var topicView = function(view, mapping) {
		var self = this;
		Mapmaker.MappingView.call(this, view, mapping);
		this.topic = mapping.getTopic();

		Private.attachPhysics.call(this);
		Private.createImageSurface.call(this);
		Private.createNameSurface.call(this);

		var cancelHandler = function(event) {
			Private.cancelClick.call(self, event);
		};
		Engine.on("mouseup", cancelHandler);

		var mousemoveHandler = function(event) {
			Handlers.mousemove.call(self, event);
		};
		Engine.on("mousemove", mousemoveHandler);

		this.mouseIsDown = false;
		this.lastClick = null;
		this.hasMoved = false;
	};

	topicView.prototype = new Mapmaker.MappingView();
	topicView.prototype.constructor = topicView;

	return topicView;
}(jQuery, famous));

/**
 * @class
 * @static
 */
Mapmaker.TopicMappingView.events = {
	mousedown: "Mapmaker:TopicMappingView:mousedown",
	mouseup: "Mapmaker:TopicMappingView:mouseup",
	doubleClick: "Mapmaker:TopicMappingView:doubleClick",
	dragEnd: "Mapmaker:TopicMappingView:dragEnd",
};

/* 
TODO: 
handle auth using bitwise operators
add in-place editing
use .draggable outside of this module

*/
Mapmaker.TopicCardView = (function($) {

  // functions called in no specific context with the intent of returning something
  var Returns = {
    buildObjectForTemplate: function (topic) {
        var
          nodeValues = {},
          authorized = true, //TODO: switch to topic.authorizeToEdit();
          desc_nil = 'Click to add description...',
          inmapsAr = topic.get("inmaps"),
          inmapsLinks = topic.get("inmapsLinks"),
          url;

        if (!authorized) {
            
        } else {
            
        }

        nodeValues.attachmentsHidden = '';
        if (topic.get('link') && topic.get('link')!== '') {
            nodeValues.embeds = '<a href="' + topic.get('link') + '" class="embedlyLink" target="_blank" data-card-chrome="0" data-card-description="0">';
            nodeValues.embeds += topic.get('link');
            nodeValues.embeds += '</a><div class="embedlyLinkLoader"></div>';
            nodeValues.attachmentsHidden = 'hidden';
            nodeValues.hasAttachment = "hasAttachment";
        }
        else {
            nodeValues.embeds = '';
            nodeValues.hasAttachment = '';
        }

        if (authorized) {
            nodeValues.attachments = '<div class="addLink"><div class="addLinkIcon"></div>';
            nodeValues.attachments += '<div class="addLinkInput"><input placeholder="Enter or paste a link"></input>';
            nodeValues.attachments += '<div class="addLinkReset"></div></div></div>';
        } else {
            nodeValues.attachmentsHidden = 'hidden';
            nodeValues.attachments = '';
        }

        
        nodeValues.inmaps ='';
        if (inmapsAr.length < 6) {
            for (i = 0; i < inmapsAr.length; i++) {
                url = "/maps/" + inmapsLinks[i];
                nodeValues.inmaps += '<li><a href="' + url + '">'  + inmapsAr[i]+ '</a></li>';
            }
        }
        else {
            for (i = 0; i < 5; i++){
                var url = "/maps/" + inmapsLinks[i];
                nodeValues.inmaps += '<li><a href="' + url + '">' + inmapsAr[i] + '</a></li>';
            }
            extra = inmapsAr.length - 5;
            nodeValues.inmaps += '<li><span class="showMore">See ' + extra + ' more...</span></li>'
            for (i = 5; i < inmapsAr.length; i++){
                url = "/maps/" + inmapsLinks[i];
                nodeValues.inmaps += '<li class="hideExtra extraText"><a href="' + url + '">' + inmapsAr[i]+ '</a></li>';
            }
        }
        nodeValues.permission = topic.get("permission");
        nodeValues.mk_permission = topic.get("permission").substring(0, 2);
        nodeValues.map_count = topic.get("map_count").toString();
        nodeValues.synapse_count = topic.get("synapse_count").toString();
        nodeValues.id = topic.isNew() ? topic.cid : topic.id;
        nodeValues.metacode = 'Action'; // topic.getMetacode().get("name");
        nodeValues.metacode_class = 'mbg' + topic.get('metacode_id');
        nodeValues.imgsrc = '/img/bp_action.png'; // topic.getMetacode().get("icon");
        nodeValues.name = topic.get("name");
        nodeValues.userid = topic.get("user_id");
        nodeValues.username = topic.get("user_name");
        nodeValues.date = topic.getDate();
        // the code for this is stored in /views/main/_metacodeOptions.html.erb
        nodeValues.metacode_select = $('#metacodeOptions').html();
        nodeValues.desc_nil = desc_nil;
        nodeValues.desc = (topic.get("desc") == "" && authorized) ? desc_nil : topic.get("desc");
        return nodeValues;
    },
    validateLink: function (link) {

      // TODO: write this
      return true;
    }
  };


  // functions called with TopicCardView as it's 'this' context
  var Private = {
    metacodeLiClick: function () {
      /*var metacodeId = parseInt($(this).attr('data-id'));
      var metacode = Mapmaker.Metacodes.get(metacodeId);
      $('.CardOnGraph').find('.metacodeTitle').html(metacode.get('name'))
          .append('<div class="expandMetacodeSelect"></div>')
          .attr('class', 'metacodeTitle mbg' + metacode.id);
      $('.CardOnGraph').find('.metacodeImage').css('background-image', 'url(' + metacode.get('icon') + ')');
      topic.save({
          metacode_id: metacode.id
      });
      Mapmaker.Visualize.mGraph.plot();
      $('.metacodeSelect').hide().removeClass('onRightEdge onBottomEdge');
      $('.metacodeTitle').hide();
      $('.showcard .icon').css('z-index', '1');*/
    },
    onLinkKeyup: function (e) {
      var
        url = '';

      // enter key
      if (e.which === 13) {
        url = this.$('.addLinkInput input').val();
        if (url.slice(0, 4) !== 'http') {
          url = 'http://' + url;
        }
        this.model.set('link', url);
      }
    },
    linkChange: function () {
      var
        link = this.model.get('link');
        
      if (!Returns.validateLink(link)) Private.invalidLink.call(this);
      else if (link === '' || !link) Private.removeLink.call(this);
      else Private.addLink.call(this);
    },
    invalidLink: function () {
      $(document).trigger(Mapmaker.TopicCardView.events.invalidLink);
      Private.removeLink.call(this);
    },
    removeLink: function () {
      this.$('.embeds').empty().removeClass('nonEmbedlyLink');
      this.$('.addLinkInput input').val("");
      this.$('.attachments').show();
      this.$('.CardOnGraph').removeClass('hasAttachment');
    },
    addLink: function () {
      var 
        link = this.$('.addLinkInput input').val(),
        embedlyEl = $('<a/>', {
          class: 'embedlyLink',
          'data-card-chrome': '0',
          'data-card-description': '0',
          href: link
        }).html(link);
      this.$('.attachments').hide();
      this.$('.embeds').append(embedlyEl);
      Private.embedify.call(this);
    },
    embedify: function () {
      /*this.$('.embeds').append('<div id="embedlyLinkLoader"></div>');
      var loader = new CanvasLoader('embedlyLinkLoader');
      loader.setColor('#4fb5c0'); // default is '#000000'
      loader.setDiameter(28); // default is 40
      loader.setDensity(41); // default is 40
      loader.setRange(0.9); // default is 1.3
      loader.show(); // Hidden by default*/
      var e = embedly('card', this.$('.embedlyLink')[0]);
      /*if (!e) {
          self.handleInvalidLink();
      }*/
    },
    embedlyCardRendered: function (iframe) {

        //$('#embedlyLinkLoader').hide();

        // means that the embedly call returned 404 not found
        if (this.$('.embedlyLink')[0]) {
            this.$('.embedlyLink').css('display', 'block').fadeIn('fast');
            this.$('.embeds').addClass('nonEmbedlyLink');
        }

        this.$('.CardOnGraph').addClass('hasAttachment');

        // TODO: replace true with authorizedToEdit
        if (true) {
            this.$('.embeds').append('<div class="linkremove"></div>');
        }
    }
  };





	var topicCardView = function() {
		this.events = {
			'mouseenter .metacodeImage'  : 'showMetacodeTitle',
      'mouseleave .linkItem.icon'  : 'hideMetacodeTitle',
      'keyup .addLinkInput input'  :  Private.onLinkKeyup,
      'click .addLinkReset'        : 'resetLinkInput',
      'click .linkremove'          : 'removeLink'
		};

		this.className = 'topicCardView';

		var html = document.getElementById('topicCardTemplate').innerHTML;
		this.template = Hogan.compile(html);
	};

	_.extend(topicCardView.prototype, Mapmaker.Mixins.Visibility);

	topicCardView.prototype.initialize = function(options) {
		_.extend(this, _.pick(options, 'mapView'));

    this.selectingMetacode = false;

		this.mapView.$parent.append(this.render().el);
	};

	topicCardView.prototype.render = function() {
    var
      obj = Returns.buildObjectForTemplate(this.model),
      link = this.model.get('link');

		this.$el.html(this.template.render(obj));

    // embedly 
    embedly('on', 'card.rendered', Private.embedlyCardRendered.bind(this));
    if (link && link !== '') Private.embedify.call(this);

    // listen for change events on this.model here
    this.model.on('change:link', Private.linkChange.bind(this));

		return this;
	};

  topicCardView.prototype.removeLink = function () {
      this.model.set('link', null);
      /*this.model.save({
          link: null
      });*/
  };

  topicCardView.prototype.showMetacodeTitle = function () {
    this.$('.icon').css('z-index', '4');
    this.$('.metacodeTitle').show();
  };

  topicCardView.prototype.hideMetacodeTitle = function () {
    if (!this.selectingMetacode) {
        this.$('.metacodeTitle').hide();
        this.$('.icon').css('z-index', '1');
    }
  };

  topicCardView.prototype.resetLinkInput = function () {
    this.$('.addLinkInput input').val("");
    this.$('.addLinkInput input').focus();
  };

	return Backbone.View.extend(new topicCardView());
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.TopicCardView.events = {
	invalidLink: 'Mapmaker:TopicCardView:invalidLink'
};





Mapmaker.TopicCard = {
    bindShowCardListeners: function (topic) {
        var self = Mapmaker.TopicCard;
        var showCard = document.getElementById('showcard');

        var authorized = self.authorizedToEdit;

        // get mapper image
        var setMapperImage = function (mapper) {
            $('.contributorIcon').attr('src', mapper.get('image'));
        };
        Mapmaker.Mapper.get(topic.get('user_id'), setMapperImage);

        var openMetacodeSelect = function (event) {
            var windowWidth;
            var showcardLeft;
            var TOPICCARD_WIDTH = 300;
            var METACODESELECT_WIDTH = 404;
            var distanceFromEdge;

            var MAX_METACODELIST_HEIGHT = 270;
            var windowHeight;
            var showcardTop;
            var topicTitleHeight;
            var distanceFromBottom;

            if (!selectingMetacode) {
                selectingMetacode = true;

                // this is to make sure the metacode 
                // select is accessible onscreen, when opened
                // while topic card is close to the right 
                // edge of the screen
                windowWidth = $(window).width();
                showcardLeft = parseInt($('.showcard').css('left'));
                distanceFromEdge = windowWidth - (showcardLeft + TOPICCARD_WIDTH);
                if (distanceFromEdge < METACODESELECT_WIDTH) {
                    $('.metacodeSelect').addClass('onRightEdge');
                }

                // this is to make sure the metacode 
                // select is accessible onscreen, when opened
                // while topic card is close to the bottom
                // edge of the screen
                windowHeight = $(window).height();
                showcardTop = parseInt($('.showcard').css('top'));
                topicTitleHeight = $('.showcard .title').height() + parseInt($('.showcard .title').css('padding-top')) + parseInt($('.showcard .title').css('padding-bottom'));
                heightOfSetList = $('.showcard .metacodeSelect').height();
                distanceFromBottom = windowHeight - (showcardTop + topicTitleHeight);
                if (distanceFromBottom < MAX_METACODELIST_HEIGHT) {
                    $('.metacodeSelect').addClass('onBottomEdge');
                }

                $('.metacodeSelect').show();
                event.stopPropagation();
            }
        };

        var hideMetacodeSelect = function () {
            selectingMetacode = false;
            $('.metacodeSelect').hide().removeClass('onRightEdge onBottomEdge');
            $('.metacodeTitle').hide();
            $('.showcard .icon').css('z-index', '1');
        };

        if (authorized) {
            $('.showcard .metacodeTitle').click(openMetacodeSelect);
            $('.showcard').click(hideMetacodeSelect);
            $('.metacodeSelect > ul > li').click(function (event){
                event.stopPropagation();
            });
            $('.metacodeSelect li li').click(metacodeLiClick);

            var bipName = $(showCard).find('.best_in_place_name');
            bipName.bind("best_in_place:activate", function () {
                var $el = bipName.find('textarea');
                var el = $el[0];

                $el.attr('maxlength', '140');

                $('.showcard .title').append('<div class="nameCounter forTopic"></div>');

                var callback = function (data) {
                    $('.nameCounter.forTopic').html(data.all + '/140');
                };
                Countable.live(el, callback);
            });
            bipName.bind("best_in_place:deactivate", function () {
                $('.nameCounter.forTopic').remove();
            });

            //bind best_in_place ajax callbacks
            bipName.bind("ajax:success", function () {
                var name = Mapmaker.Util.decodeEntities($(this).html());
                topic.set("name", name);
                topic.trigger('saved');
            });

            $(showCard).find('.best_in_place_desc').bind("ajax:success", function () {
                this.innerHTML = this.innerHTML.replace(/\r/g, '');
                var desc = $(this).html() === $(this).data('nil') ? "" : $(this).html();
                topic.set("desc", desc);
                topic.trigger('saved');
            });
        }


        var permissionLiClick = function (event) {
            selectingPermission = false;
            var permission = $(this).attr('class');
            topic.save({
                permission: permission
            });
            $('.showcard .mapPerm').removeClass('co pu pr minimize').addClass(permission.substring(0, 2));
            $('.showcard .permissionSelect').remove();
            event.stopPropagation();
        };

        var openPermissionSelect = function (event) {
            if (!selectingPermission) {
                selectingPermission = true;
                $(this).addClass('minimize'); // this line flips the drop down arrow to a pull up arrow
                if ($(this).hasClass('co')) {
                    $(this).append('<ul class="permissionSelect"><li class="public"></li><li class="private"></li></ul>');
                } else if ($(this).hasClass('pu')) {
                    $(this).append('<ul class="permissionSelect"><li class="commons"></li><li class="private"></li></ul>');
                } else if ($(this).hasClass('pr')) {
                    $(this).append('<ul class="permissionSelect"><li class="commons"></li><li class="public"></li></ul>');
                }
                $('.showcard .permissionSelect li').click(permissionLiClick);
                event.stopPropagation();
            }
        };

        var hidePermissionSelect = function () {
            selectingPermission = false;
            $('.showcard .yourTopic .mapPerm').removeClass('minimize'); // this line flips the pull up arrow to a drop down arrow
            $('.showcard .permissionSelect').remove();
        };
        // ability to change permission
        var selectingPermission = false;
        if (topic.authorizePermissionChange(Mapmaker.Active.Mapper)) {
            $('.showcard .yourTopic .mapPerm').click(openPermissionSelect);
            $('.showcard').click(hidePermissionSelect);
        }

        $('.links .mapCount').unbind().click(function(event){
            $('.mapCount .tip').toggle();
            $('.showcard .hoverTip').toggleClass('hide');
            event.stopPropagation();
        });
        $('.mapCount .tip').unbind().click(function(event){
            event.stopPropagation();
        });
        $('.showcard').unbind('.hideTip').bind('click.hideTip', function(){
            $('.mapCount .tip').hide();
            $('.showcard .hoverTip').removeClass('hide');
        });

        $('.mapCount .tip li a').click(Mapmaker.Router.intercept);

        var originalText = $('.showMore').html();
        $('.mapCount .tip .showMore').unbind().toggle(
            function(event){
                $('.extraText').toggleClass("hideExtra");
                $('.showMore').html('Show less...');
            },
            function(event){
                $('.extraText').toggleClass("hideExtra");
                $('.showMore').html(originalText);
            });

        $('.mapCount .tip showMore').unbind().click(function(event){
            event.stopPropagation();
        });
    },
    populateShowCard: function (topic) {
        var self = Mapmaker.TopicCard;

        var showCard = document.getElementById('showcard');

        $(showCard).find('.permission').remove();

        var topicForTemplate = self.buildObject(topic);
        var html = self.generateShowcardHTML.render(topicForTemplate);

        if (topic.authorizeToEdit(Mapmaker.Active.Mapper)) {
            var perm = document.createElement('div');

            var string = 'permission canEdit';
            if (topic.authorizePermissionChange(Mapmaker.Active.Mapper)) string += ' yourTopic';
            perm.className = string;
            perm.innerHTML = html;
            showCard.appendChild(perm);
        } else {
            var perm = document.createElement('div');
            perm.className = 'permission cannotEdit';
            perm.innerHTML = html;
            showCard.appendChild(perm);
        }

        Mapmaker.TopicCard.bindShowCardListeners(topic);
    }
};

Mapmaker.Synapse = (function() {

	return Backbone.Model.extend({
		urlRoot: "/synapses",
		blacklist: ["edge", "created_at", "updated_at"],
		toJSON: function(options) {
			return _.omit(this.attributes, this.blacklist);
		},
		save: function(key, val, options) {

			var attrs;

			// Handle both `"key", value` and `{key: value}` -style arguments.
			if (key === null || typeof key === "object") {
				attrs = key;
				options = val;
			} else {
				(attrs = {})[key] = val;
			}

			var newOptions = options || {};
			var s = newOptions.success;

			var permBefore = this.get("permission");

			newOptions.success = function(model, response, opt) {
				if (s) s(model, response, opt);
				model.trigger("saved");

				if (permBefore === "private" && model.get("permission") !== "private") {
					model.trigger("noLongerPrivate");
				} else if (permBefore !== "private" && model.get("permission") === "private") {
					model.trigger("nowPrivate");
				}
			};
			return Backbone.Model.prototype.save.call(this, attrs, newOptions);
		},
		initialize: function() {
			if (this.isNew()) {
				this.set({
					"user_id": null,
					"permission": "commons",
					"category": "from-to"
				});
			}

			this.on("noLongerPrivate", function() {
				var newSynapseData = {
					mappingid: this.getMapping().id,
					synapseid: this.id
				};

				$(document).trigger(Mapmaker.JIT.events.newSynapse, [newSynapseData]);
			});
			this.on("nowPrivate", function() {
				$(document).trigger(Mapmaker.JIT.events.removeSynapse, [{
					synapseid: this.id
            }]);
			});

			//this.on("change:desc", Mapmaker.Filter.checkSynapses, this);
		},
		prepareLiForFilter: function() {
			var li = "";
			li += "<li data-id=\"" + this.get("desc") + "\">";      
			li += "<img src=\"/assets/synapse16.png\"";
			li += " alt=\"synapse icon\" />";      
			li += "<p>" + this.get("desc") + "</p></li>";
			return li;
		},
		authorizeToEdit: function(mapper) {
			if (mapper && (this.get("permission") === "commons" || this.get("user_id") === mapper.get(
				"id"))) return true;
			else return false;
		},
		authorizePermissionChange: function(mapper) {
			if (mapper && this.get("user_id") === mapper.get("id")) return true;
			else return false;
		},
		getTopicMapping1: function() {
			var topic_id = this.get("node1_id");

			//hack: "map" is currently a global
			var mappingCollection = map.get("topicMappings");

			return mappingCollection.findWhere({
				topic_id: topic_id
			});
		},
		getTopicMapping2: function() {
			var topic_id = this.get("node2_id");

			//hack: "map" is currently a global
			var mappingCollection = map.get("topicMappings");

			return mappingCollection.findWhere({
				topic_id: topic_id
			});
		},
		getTopic1: function() {
			var topic_id = this.get("node1_id");

			//hack: "map" is currently a global
			var topicCollection = map.get("topics");

			return topicCollection.get(topic_id);
		},
		getTopic2: function() {
			var topic_id = this.get("node2_id");

			//hack: "map" is currently a global
			var topicCollection = map.get("topics");

			return topicCollection.get(topic_id);
		},
		getDirection: function() {
			return [
                this.getTopic1().get("node").id,
                this.getTopic2().get("node").id
            ];
		},
		getMapping: function() {

			if (!Mapmaker.Active.Map) return false;

			return Mapmaker.Mappings.findWhere({
				map_id: Mapmaker.Active.Map.id,
				synapse_id: this.isNew() ? this.cid : this.id
			});
		}
	}); // Backbone.Model.extend

}());

Mapmaker.SynapseMappingView = (function($, famous) {
	var Engine = famous.core.Engine;
	var Surface = famous.core.Surface;
	var Modifier = famous.core.Modifier;
	var StateModifier = famous.modifiers.StateModifier;
	var Transform = famous.core.Transform;
	var Spring = famous.physics.forces.Spring;

	var Handlers = {
		mousedown: function(event) {
			this.mouseIsDown = true;

			$(document).trigger(Mapmaker.SynapseMappingView.events.mousedown);
		},
		mouseup: function(event) {
			this.mouseIsDown = false;

			$(document).trigger(Mapmaker.SynapseMappingView.events.mouseup);
		}
	};

	var Private = {
		calculateLength: function(a, b) {
			var xSquared = Math.pow((a[0] - b[0]), 2);
			var ySquared = Math.pow((a[1] - b[1]), 2);

			this.length = Math.sqrt(xSquared + ySquared);
		},
		cancelClick: function() {
			this.mouseIsDown = false;

			$(document).trigger(Mapmaker.SynapseMappingView.events.mouseup);
		},
		createLineSurface: function() {
			var self = this;

			// add listener for the synapse direction changing,
			// call .setContent on the surface

			this.lineSurface = new Surface({
				content: "",
				classes: ["noselect"],
				size: [1, 1],
				properties: {
					backgroundColor: "#000"
				}
			});
			this.modNode.add(this.lineSurface);

			// attach events
			var mousedownHandler = function(event) {
				Handlers.mousedown.call(self, event);
			};
			this.lineSurface.on("mousedown", mousedownHandler);

			var mouseupHandler = function(event) {
				Handlers.mouseup.call(self, event);
			};
			this.lineSurface.on("mouseup", mouseupHandler);
		},
		addSpring: function() {
			var spring = new Spring({
				period: 5000,
				dampingRatio: 0.9,
				length: 5
			});
			var topic1View = this.view.topics[this.topicMapping1.cid];
			var topic2View = this.view.topics[this.topicMapping2.cid];
      // for 'attach' variables to pass are (Force, Targets, Source)
      //this.view.pe.attach(spring, topic2View.topicParticle, topic1View.topicParticle);
		}
	};

	var synapseView = function(view, mapping) {
		var self = this;
		Mapmaker.MappingView.call(this, view, mapping);
		this.synapse = mapping.getSynapse();
		this.topicMapping1 = this.synapse.getTopicMapping1();
		this.topicMapping2 = this.synapse.getTopicMapping2();

		this.topicMapping1.on("change:xloc, change:yloc", function() {
			self.updateDisplay.call(self);
		});
		this.topicMapping2.on("change:xloc, change:yloc", function() {
			self.updateDisplay.call(self);
		});

		this.length = 0;

		this.mod = new StateModifier({
			transform: Transform.translate(0, 0, 0)
		});
		this.modNode = view.originModNode.add(this.mod);

		Private.createLineSurface.call(this);
		Private.addSpring.call(this);

		var cancelHandler = function(event) {
			Private.cancelClick.call(self);
		};
		Engine.on("mouseup", cancelHandler);

		this.mouseIsDown = false;

		self.updateDisplay.call(this);
	};

	synapseView.prototype = new Mapmaker.MappingView();
	synapseView.prototype.constructor = synapseView;

	synapseView.prototype.updateDisplay = function() {
		var topic1View = this.view.topics[this.topicMapping1.cid];
		var topic2View = this.view.topics[this.topicMapping2.cid];

		if (!(topic1View || topic2View)) return;

		var t1 = topic1View.topicParticle.getTransform();
		var t2 = topic2View.topicParticle.getTransform();
		var pointA = [t1[12], t1[13]];
		var pointB = [t2[12], t2[13]];

		// scale
		Private.calculateLength.call(this, pointA, pointB);
		this.lineSurface.setSize([this.length, 1]);

		// rotate
		var deltaX = pointA[0] - pointB[0];
		var deltaY = pointA[1] - pointB[1];
		var radians = Math.atan2(deltaY, deltaX);
		var r = Transform.rotateZ(radians);

		// translate (to the center point of the line between pointA and pointB)
		var centerX = pointA[0] + (pointB[0] - pointA[0]) / 2;
		var centerY = pointA[1] + (pointB[1] - pointA[1]) / 2;
		var t = Transform.translate(centerX, centerY, 0);

		var finalTransform = Transform.multiply(t, r);
		this.mod.setTransform(finalTransform);
	};


	return synapseView;
}(jQuery, famous));

/**
 * @class
 * @static
 */
Mapmaker.SynapseMappingView.events = {
	mousedown: "Mapmaker:SynapseMappingView:mousedown",
	mouseup: "Mapmaker:SynapseMappingView:mouseup"
};

Mapmaker.SynapseCardView = (function($) {

	var synapseCardView = function() {
		this.events = {
			"dblclick"                : "open",
			"click .icon.doc"         : "select",
			"contextmenu .icon.doc"   : "showMenu",
			"click .mapCountIcon"     : "toggle",
			"click .title"            : "hide",
			"mouseover .title .date"  : "showTooltip"
		};

		this.className = "synapseCardView";

		var html = document.getElementById("synapseCardTemplate").innerHTML;
		this.template = Hogan.compile(html);
	};

	_.extend(synapseCardView.prototype, Mapmaker.Mixins.Visibility);

	synapseCardView.prototype.initialize = function(options) {
		_.extend(this, _.pick(options, "mapView"));

		this.mapView.$parent.append(this.render().el);
	};

	synapseCardView.prototype.render = function() {
		this.$el.html(this.template.render(this.model.attributes));
		return this;
	};

	return Backbone.View.extend(new synapseCardView());
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.SynapseCardView.events = {
	
};



Mapmaker.SynapseCard = {
    openSynapseCard: null,
    showCard: function (edge, e) {
        var self = Mapmaker.SynapseCard;

        //reset so we don't interfere with other edges, but first, save its x and y 
        var myX = $('#edit_synapse').css('left');
        var myY = $('#edit_synapse').css('top');
        $('#edit_synapse').remove();

        //so label is missing while editing
        Mapmaker.Control.deselectEdge(edge);

        var index = edge.getData("displayIndex") ? edge.getData("displayIndex") : 0;
        var synapse = edge.getData('synapses')[index]; // for now, just get the first synapse

        //create the wrapper around the form elements, including permissions
        //classes to make best_in_place happy
        var edit_div = document.createElement('div');
        edit_div.innerHTML = '<div id="editSynUpperBar"></div><div id="editSynLowerBar"></div>';
        edit_div.setAttribute('id', 'edit_synapse');
        if (synapse.authorizeToEdit(Mapmaker.Active.Mapper)) {
            edit_div.className = 'permission canEdit';
            edit_div.className += synapse.authorizePermissionChange(Mapmaker.Active.Mapper) ? ' yourEdge' : '';
        } else {
            edit_div.className = 'permission cannotEdit';
        }
        $('#wrapper').append(edit_div);

        self.populateShowCard(edge, synapse);

        //drop it in the right spot, activate it
        $('#edit_synapse').css('position', 'absolute');
        if (e) {
            $('#edit_synapse').css('left', e.clientX);
            $('#edit_synapse').css('top', e.clientY);
        } else {
            $('#edit_synapse').css('left', myX);
            $('#edit_synapse').css('top', myY);
        }
        //$('#edit_synapse_name').click(); //required in case name is empty
        //$('#edit_synapse_name input').focus();
        $('#edit_synapse').show();

        self.openSynapseCard = edge;
    },

    hideCard: function () {
        $('#edit_synapse').remove();
        Mapmaker.SynapseCard.openSynapseCard = null;
    },

    populateShowCard: function (edge, synapse) {
        var self = Mapmaker.SynapseCard;

        self.add_synapse_count(edge);
        self.add_desc_form(synapse);
        self.add_drop_down(edge, synapse);
        self.add_user_info(synapse);
        self.add_perms_form(synapse);
        self.add_direction_form(synapse);
    },
    add_synapse_count: function (edge) {
        var count = edge.getData("synapses").length;

        $('#editSynUpperBar').append('<div id="synapseCardCount">' + count + '</div>')
    },
    add_desc_form: function (synapse) {
        var data_nil = 'Click to add description.';

        // TODO make it so that this would work even in sandbox mode,
        // currently with Best_in_place it won't

        //desc editing form
        $('#editSynUpperBar').append('<div id="edit_synapse_desc"></div>');
        $('#edit_synapse_desc').attr('class', 'best_in_place best_in_place_desc');
        $('#edit_synapse_desc').attr('data-object', 'synapse');
        $('#edit_synapse_desc').attr('data-attribute', 'desc');
        $('#edit_synapse_desc').attr('data-type', 'textarea');
        $('#edit_synapse_desc').attr('data-nil', data_nil);
        $('#edit_synapse_desc').attr('data-url', '/synapses/' + synapse.id);
        $('#edit_synapse_desc').html(synapse.get("desc"));

        //if edge data is blank or just whitespace, populate it with data_nil
        if ($('#edit_synapse_desc').html().trim() == '') {
            if (synapse.authorizeToEdit(Mapmaker.Active.Mapper)) {
                $('#edit_synapse_desc').html(data_nil);
            }
            else {
                $('#edit_synapse_desc').html("(no description)");
            }
        }

        $('#edit_synapse_desc').bind("ajax:success", function () {
            var desc = $(this).html();
            if (desc == data_nil) {
                synapse.set("desc", '');
            } else {
                synapse.set("desc", desc);
            }
            synapse.trigger('saved');
            Mapmaker.Control.selectEdge(synapse.get('edge'));
            Mapmaker.Visualize.mGraph.plot();
        });
    },
    add_drop_down: function (edge, synapse) {
        var list, i, synapses, l, desc;

        synapses = edge.getData("synapses");
        l = synapses.length;

        if (l > 1) {
            // append the element that you click to show dropdown select
            $('#editSynUpperBar').append('<div id="dropdownSynapses"></div>');
            $('#dropdownSynapses').click(function(e){
                e.preventDefault();
                e.stopPropagation(); // stop it from immediately closing it again
                $('#switchSynapseList').toggle();
            });
            // hide the dropdown again if you click anywhere else on the synapse card
            $('#edit_synapse').click(function(){
                $('#switchSynapseList').hide();
            });

            // generate the list of other synapses
            list = '<ul id="switchSynapseList">';
            for (i = 0; i < l; i++) {
                if (synapses[i] !== synapse) { // don't add the current one to the list
                    desc = synapses[i].get('desc');
                    desc = desc === "" || desc === null ? "(no description)" : desc;
                    list += '<li data-synapse-index="' + i + '">' + desc + '</li>';
                }
            }
            list += '</ul>'
            // add the list of the other synapses
            $('#editSynLowerBar').append(list);

            // attach click listeners to list items that
            // will cause it to switch the displayed synapse 
            // when you click it
            $('#switchSynapseList li').click(function(e){
                e.stopPropagation();
                var index = parseInt($(this).attr('data-synapse-index'));
                edge.setData('displayIndex', index);
                Mapmaker.Visualize.mGraph.plot();
                Mapmaker.SynapseCard.showCard(edge, false);
            });
        }
    },
    add_user_info: function (synapse) {
        var u = '<div id="edgeUser" class="hoverForTip">';
        u += '<a href="/explore/mapper/' + synapse.get("user_id") + '"> <img src="" width="24" height="24" /></a>'
        u += '<div class="tip">' + synapse.get("user_name") + '</div></div>';
        $('#editSynLowerBar').append(u);

        // get mapper image
        var setMapperImage = function (mapper) {
            $('#edgeUser img').attr('src', mapper.get('image'));
        };
        Mapmaker.Mapper.get(synapse.get('user_id'), setMapperImage);
    },

    add_perms_form: function (synapse) {
        //permissions - if owner, also allow permission editing
        $('#editSynLowerBar').append('<div class="mapPerm ' + synapse.get("permission").substring(0, 2) + '"></div>');

        // ability to change permission
        var selectingPermission = false;
        var permissionLiClick = function (event) {
            selectingPermission = false;
            var permission = $(this).attr('class');
            synapse.save({
                permission: permission
            });
            $('#edit_synapse .mapPerm').removeClass('co pu pr minimize').addClass(permission.substring(0, 2));
            $('#edit_synapse .permissionSelect').remove();
            event.stopPropagation();
        };

        var openPermissionSelect = function (event) {
            if (!selectingPermission) {
                selectingPermission = true;
                $(this).addClass('minimize'); // this line flips the drop down arrow to a pull up arrow
                if ($(this).hasClass('co')) {
                    $(this).append('<ul class="permissionSelect"><li class="public"></li><li class="private"></li></ul>');
                } else if ($(this).hasClass('pu')) {
                    $(this).append('<ul class="permissionSelect"><li class="commons"></li><li class="private"></li></ul>');
                } else if ($(this).hasClass('pr')) {
                    $(this).append('<ul class="permissionSelect"><li class="commons"></li><li class="public"></li></ul>');
                }
                $('#edit_synapse .permissionSelect li').click(permissionLiClick);
                event.stopPropagation();
            }
        };

        var hidePermissionSelect = function () {
            selectingPermission = false;
            $('#edit_synapse.yourEdge .mapPerm').removeClass('minimize'); // this line flips the pull up arrow to a drop down arrow
            $('#edit_synapse .permissionSelect').remove();
        };

        if (synapse.authorizePermissionChange(Mapmaker.Active.Mapper)) {
            $('#edit_synapse.yourEdge .mapPerm').click(openPermissionSelect);
            $('#edit_synapse').click(hidePermissionSelect);
        }
    }, //add_perms_form

    add_direction_form: function (synapse) {
        //directionality checkboxes
        $('#editSynLowerBar').append('<div id="edit_synapse_left"></div>');
        $('#editSynLowerBar').append('<div id="edit_synapse_right"></div>');

        var edge = synapse.get('edge');

        //determine which node is to the left and the right
        //if directly in a line, top is left
        if (edge.nodeFrom.pos.x < edge.nodeTo.pos.x ||
            edge.nodeFrom.pos.x == edge.nodeTo.pos.x &&
            edge.nodeFrom.pos.y < edge.nodeTo.pos.y) {
            var left = edge.nodeTo.getData("topic");
            var right = edge.nodeFrom.getData("topic");
        } else {
            var left = edge.nodeFrom.getData("topic");
            var right = edge.nodeTo.getData("topic");
        }

        /*
         * One node is actually on the left onscreen. Call it left, & the other right.
         * If category is from-to, and that node is first, check the 'right' checkbox.
         * Else check the 'left' checkbox since the arrow is incoming.
         */

        var directionCat = synapse.get('category'); //both, none, from-to
        if (directionCat == 'from-to') {
            var from_to = [synapse.get("node1_id"), synapse.get("node2_id")];
            if (from_to[0] == left.id) {
                //check left checkbox
                $('#edit_synapse_left').addClass('checked');
            } else {
                //check right checkbox
                $('#edit_synapse_right').addClass('checked');
            }
        } else if (directionCat == 'both') {
            //check both checkboxes
            $('#edit_synapse_left').addClass('checked');
            $('#edit_synapse_right').addClass('checked');
        }

        if (synapse.authorizeToEdit(Mapmaker.Active.Mapper)) {
            $('#edit_synapse_left, #edit_synapse_right').click(function () {
                
                $(this).toggleClass('checked');

                var leftChecked = $('#edit_synapse_left').is('.checked');
                var rightChecked = $('#edit_synapse_right').is('.checked');

                var dir = synapse.getDirection();
                var dirCat = 'none';
                if (leftChecked && rightChecked) {
                    dirCat = 'both';
                } else if (!leftChecked && rightChecked) {
                    dirCat = 'from-to';
                    dir = [right.id, left.id];
                } else if (leftChecked && !rightChecked) {
                    dirCat = 'from-to';
                    dir = [left.id, right.id];
                }

                synapse.save({
                    category: dirCat,
                    node1_id: dir[0],
                    node2_id: dir[1]
                });
                Mapmaker.Visualize.mGraph.plot();
            });
        } // if
    } //add_direction_form
};

if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.VideoView = (function($) {

    var Private = {
        cancelClick: function() {
            this.mouseIsDown = false;

            if (this.hasMoved) {
                
            }

            $(document).trigger(Mapmaker.VideoView.events.dragEnd);
        }
    };

    var Handlers = {
        mousedown: function(event) {
            this.mouseIsDown = true;
            this.hasMoved = false;
            this.mouseDownOffset = {
                x: event.offsetX,
                y: event.offsetY
            };

            $(document).trigger(Mapmaker.VideoView.events.mousedown);
        },
        mouseup: function(event) {
            $(document).trigger(Mapmaker.VideoView.events.mouseup, [this]);

            var storedTime = this.lastClick;
            var now = Date.now();
            this.lastClick = now;

            if (now - storedTime < this.view.config.DOUBLE_CLICK_TOLERANCE) {
                $(document).trigger(Mapmaker.VideoView.events.doubleClick, [this]);
            }
        },
        mousemove: function(event) {
            var
              offset = this.view.$parent.offset();

            if (this.mouseIsDown) {
                if (!this.hasMoved) this.hasMoved = true;
                this.$container.css({
                    top: event.pageY - offset.top - this.mouseDownOffset.y,
                    left: event.pageX - offset.left - this.mouseDownOffset.x
                });
            }
        },
        audioControlClick: function() {
            if (this.audioStatus) {
                this.$audioControl.css({
                    'text-decoration': 'line-through'
                });
                // mute it
            } else {
                this.$audioControl.css({
                    'text-decoration': 'none'
                });
                // unmute it
            }
            this.audioStatus = !this.audioStatus;
        },
        videoControlClick: function() {
            if (this.videoStatus) {
                this.$videoControl.css({
                    'text-decoration': 'line-through'
                });
                // change the video feed to an avatar
            } else {
                this.$videoControl.css({
                    'text-decoration': 'none'
                });
                // change the avatar to the video feed
            }
            this.videoStatus = !this.videoStatus;
        }
    };

    var videoView = function(video, view, id, isMyself) {
        var self = this;
        this.view = view; // mapView
        this.video = video;
        this.id = id;

        this.mouseIsDown = false;
        this.mouseDownOffset = { x: 0, y: 0 };
        this.lastClick = null;
        this.hasMoved = false;

        this.audioStatus = true;
        this.videoStatus = true;

        this.$container = $('<div></div>');
        this.$container.addClass('collaborator-video' + (isMyself ? ' my-video' : ''));
        this.$container.attr('id', 'container_' + id);
        this.$container.append(this.video);

        this.$container.on('mousedown', function (event) {
            Handlers.mousedown.call(self, event);
        });
        this.view.$parent.on('mouseup.video' + this.id, function (event) {
            Handlers.mouseup.call(self, event);
            Private.cancelClick.call(self);
        });
        this.view.$parent.on('mousemove.video' + this.id, function (event) {
            Handlers.mousemove.call(self, event);
        });

        this.$audioControl = $('<div class="video-audio">a</div>');
        this.$videoControl = $('<div class="video-video">v</div>');

        this.$audioControl.on('click', function () {
            Handlers.audioControlClick.call(self);
        });

        this.$videoControl.on('click', function () {
            Handlers.videoControlClick.call(self);
        });

        this.$container.append(this.$audioControl);
        this.$container.append(this.$videoControl);

        // suppress contextmenu
        this.video.oncontextmenu = function () { return false; };
    };

    videoView.prototype.remove = function () {
        this.$container.off();
        this.view.$parent.off('.video' + this.id);
        this.$container.remove();
    }

    return videoView;
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.VideoView.events = {
    mousedown: "Mapmaker:VideoView:mousedown",
    mouseup: "Mapmaker:VideoView:mouseup",
    doubleClick: "Mapmaker:VideoView:doubleClick",
    dragEnd: "Mapmaker:VideoView:dragEnd",
};
if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.ChatView = (function($) {

    var Private = {
        addMessage: function(message) {
            var m = _.clone(message.attributes);
            m.timestamp = new Date(m.timestamp);
            m.timestamp = m.timestamp.getDate() + '/' + (m.timestamp.getMonth() + 1);
            var html = this.messageTemplate.render(m);
            this.$messages.append(html);
        },
        initialMessages: function() {
            var messages = this.messages.models;
            for (var i = 0; i < messages.length; i++) {
                Private.addMessage.call(this, messages[i]);
            }
        },
        handleInputMessage: function() {
            var message = {
                message: this.$messageInput.val(),
                timestamp: Date.now(),
                user: this.mapper.get('name')
            };
            this.add(message);
            this.$messageInput.val('');
            $(document).trigger(Mapmaker.ChatView.events.message, [message]);
        }
    };

    var Handlers = {
        buttonClick: function() {
            if (this.isOpen) this.close();
            else this.open();
            this.isOpen = !this.isOpen;
        },
        keyUp: function(event) {
            switch(event.which) {
                case 13: // enter
                  Private.handleInputMessage.call(this);
                  break;
            }
        }
    };

    var chatView = function(view, messages, mapper) {
        var self = this;
        this.view = view; // mapView
        this.mapper = mapper;
        this.messages = messages; // backbone collection
        // add the event listener so that when
        // the realtime module adds messages to the collection
        // from other mappers, it will update the UI
        this.messages.on('add', function (message) {
            Private.addMessage.call(self, message);
        });

        this.isOpen = true;

        var html = document.getElementById("messageTemplate").innerHTML;
        this.messageTemplate = Hogan.compile(html);
        
        this.$button = $('<div class="chat-button"></div>');
        this.$messageInput = $('<textarea placeholder="Send a message..." class="chat-input"></textarea>');
        this.$messages = $('<div class="chat-messages"></div>');

        this.$button.on('click', function () {
            Handlers.buttonClick.call(self);
        });
        this.$messageInput.on('keyup', function (event) {
            Handlers.keyUp.call(self, event);
        });

        this.$container = $('<div class="chat-box"></div>');
        this.$container.append(this.$messageInput);
        this.$container.append(this.$button);
        this.$container.append(this.$messages);

        this.view.$parent.append(this.$container);

        Private.initialMessages.call(this);
    };

    chatView.prototype.add = function (message) {
        this.messages.add(message);
    }

    chatView.prototype.open = function () {
        this.$container.css({
            right: '0'
        });
    }

    chatView.prototype.close = function () {
        this.$container.css({
            right: '-300px'
        });
    }

    chatView.prototype.remove = function () {
        this.$button.off();
        this.$container.remove();
    }

    return chatView;
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.ChatView.events = {
    message: 'Mapmaker:ChatView:message'
};
Mapmaker.Map = (function() {

	return Backbone.Model.extend({
		urlRoot: "/maps",
		blacklist: ["created_at", "updated_at", "user_name", "contributor_count", "topic_count",
			"synapse_count", "topics", "synapses", "synapseMappings", "topicMappings", "mappers", "messages"],
		toJSON: function(options) {
			return _.omit(this.attributes, this.blacklist);
		},
		save: function(key, val, options) {

			var attrs;

			// Handle both `"key", value` and `{key: value}` -style arguments.
			if (key == null || typeof key === "object") {
				attrs = key;
				options = val;
			} else {
				(attrs = {})[key] = val;
			}

			var newOptions = options || {};
			var s = newOptions.success;

			newOptions.success = function(model, response, opt) {
				if (s) s(model, response, opt);
				model.trigger("saved");
			};
			return Backbone.Model.prototype.save.call(this, attrs, newOptions);
		},
		initialize: function() {
			//this.on("changeByOther", this.updateView);
			this.on("saved", this.savedEvent);

			/*
        this.set("topics", new Mapmaker.TopicCollection([
            {
                id: 1,
                name: "collaboration",
                metacode_id: 1234
            },
            {
                id: 2,
                name: "interpretation",
                metacode_id: 1234
            }
        ]));

        this.set("synapses", new Mapmaker.SynapseCollection());
        
        this.set("topicMappings", new Mapmaker.MappingCollection([
            {
                id: 1,
                topic_id: 1,
                category: "topic",
                xloc: XLOC,
                yloc: YLOC
            },
            {
                id: 2,
                topic_id: 2,
                category: "topic",
                xloc: XLOC2,
                yloc: YLOC2
            }
        ]));

        this.set("synapseMappings", new Mapmaker.MappingCollection());

        */
		},
		savedEvent: function() {
			//Mapmaker.Realtime.sendMapChange(this);
		},
		authorizeToEdit: function(mapper) {
			if (mapper && (this.get("permission") === "commons" || this.get("user_id") === mapper.get(
				"id"))) return true;
			else return false;
		},
		authorizePermissionChange: function(mapper) {
			if (mapper && this.get("user_id") === mapper.get("id")) return true;
			else return false;
		}
	}); // Backbone.Model.extend

}());
/**
 * @class
 * @static
 */
Mapmaker.Map.events = {
	/**
	 * @event
	 */
	mapChanged: "Mapmaker:Map:mapChanged"
};

if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.MapView = (function($, famous) {

	// import famous
	var Engine = famous.core.Engine;
  var PhysicsEngine = famous.physics.PhysicsEngine;
	var Surface = famous.core.Surface;
	var StateModifier = famous.modifiers.StateModifier;
	var Transform = famous.core.Transform;
	var Easing = famous.transitions.Easing;


	/**
	 * Default configuration object. Not actually accessible
	 * @member Mapmaker.MapView
	 * @protected
	 */
	var defaultConfig = {
		paths: {
			metacodes: "/json/metacodes/metacodes.json"
		},
		DOUBLE_CLICK_TOLERANCE: 300,
		embed: false, // indicates that the app is on a page that is optimized for embedding in iFrames on other web pages
    sandbox: false, // puts the app into a mode (when true) where it only creates data locally, and isn't writing it to the database
    colors: {
        background: '#344A58',
        synapses: {
            normal: '#888888',
            hover: '#888888',
            selected: '#FFFFFF'
        },
        topics: {
            selected: '#FFFFFF'
        },
        labels: {
            background: '#18202E',
            text: '#DDD'
        }
    }
	};


	var Private = {
		addModules: function () {

			this.Create = new Mapmaker.Create(this);
			this.Control = new Mapmaker.Control(this);
			this.Realtime = new Mapmaker.Realtime(this);
			this.Visualize = new Mapmaker.Visualize(this);
			this.JIT = new Mapmaker.JIT(this);

      this.$parent.append(this.Realtime.myVideo.$container);
		},
		createViews: function () {
			//
			this.infoBox = new Mapmaker.MapInfoBoxView({
				model: this.currentMap,
				mapView: this
			});

			//
			this.filter = new Mapmaker.FilterView({
				mapView: this
			});

			//
			this.junto = new Mapmaker.JuntoView({
				mapView: this
			});

			//
			this.newTopic = new Mapmaker.NewTopicView({
				mapView: this
			});
      this.$parent.append(this.newTopic.render().el);

			//
			this.newSynapse = new Mapmaker.NewSynapseView({
				mapView: this
			});
		},
		createGraphContainer: function() {
			// create the main context
			this.$graphContainer = $(document.createElement("div"));
			this.$graphContainer
				.attr("id", "graphContainer")
				.css({
					"overflow": "hidden",
					"position": "absolute",
					"top": "0"
				})
				.width(this.$parent.width())
				.height(this.$parent.height())
				.appendTo(this.$parent);

			this.mainContext = Engine.createContext(this.$graphContainer[0]);

			this.translateX = this.translateY = 0;
			this.translateModifier = new StateModifier({
				transform: Transform.translate(this.translateX, this.translateY, 0)
			});
			this.translateModNode = this.mainContext.add(this.translateModifier);

			var originModifier = new StateModifier({
				origin: [0.5, 0.5],
				align: [0.5, 0.5]
			});
			this.originModNode = this.translateModNode.add(originModifier);

      this.pe = new PhysicsEngine();
		},
		subscribeEvents: function() {
			var self = this;

			$(document).on('keydown', function (e) {
            
            switch (e.which) {
            case 13: // if enter key is pressed
                self.JIT.enterKeyHandler();
                e.preventDefault();
                break;
            case 27: // if esc key is pressed
                self.JIT.escKeyHandler();
                break;
            case 65: //if a or A is pressed
                if (e.ctrlKey){
                    self.Control.deselectAllNodes();
                    self.Control.deselectAllEdges();

                    e.preventDefault();
                    self.Visualize.mGraph.graph.eachNode(function (n) {
                        self.Control.selectNode(n,e);
                    });

                    self.Visualize.mGraph.plot();
                }
                
                break;
            case 69: //if e or E is pressed
                if (e.ctrlKey){
                    e.preventDefault();
                    if (Mapmaker.Active.Map) {
                        Mapmaker.JIT.zoomExtents(null, Mapmaker.Visualize.mGraph.canvas);
                    }
                }
                break;
            case 77: //if m or M is pressed
                if (e.ctrlKey){
                    e.preventDefault();
                    self.Control.removeSelectedNodes();
                    self.Control.removeSelectedEdges();
                }
                break;
            case 68: //if d or D is pressed
                if (e.ctrlKey){
                    e.preventDefault();
                    self.Control.deleteSelected();
                }
                break;
            case 72: //if h or H is pressed
                if (e.ctrlKey){
                    e.preventDefault();
                    self.Control.hideSelectedNodes();
                    self.Control.hideSelectedEdges();
                }
                break;
            case 67: // c
            	self.newTopic.toggle();
            	break;
            default:
                //alert(e.which);
                break;
            }
        });

        $(window).resize(function () {
            if (self.Visualize && self.Visualize.mGraph) self.Visualize.mGraph.canvas.resize($(window).width(), $(window).height());
            
            // TODO move this into the metamaps repo
            //if ((Mapmaker.Active.Map || Mapmaker.Active.Topic) && Mapmaker.Famous && Mapmaker.Famous.maps.surf) Mapmaker.Famous.maps.reposition();
        });

			/*
				these events (using "Engine") are bad because they're not being contained to the container
			*/
			var mousedownHandler = function(event) {
				Handlers.mousedown.call(self, event);
			};
			Engine.on("mousedown", mousedownHandler);

			var mouseupHandler = function(event) {
				Handlers.mouseup.call(self, event);
			};
			Engine.on("mouseup", mouseupHandler);

			var mousemoveHandler = function(event) {
				Handlers.mousemove.call(self, event);
			};
			Engine.on("mousemove", mousemoveHandler);

			// subscribe to collection events
			var synapses = this.currentMap.get("synapseMappings");
			synapses.bind("add", this.addSynapseMappingView);
			synapses.bind("remove", this.removeSynapseMappingView);

			var topics = this.currentMap.get("topicMappings");
			topics.bind("add", this.addTopicMappingView);
			topics.bind("remove", this.removeTopicMappingView);

			// for JuntoView
			$(document).on(Mapmaker.JuntoView.events.turnOn, function(event) {
				
			});
			$(document).on(Mapmaker.JuntoView.events.turnOff, function(event) {
				
			});

			// for FilterView
			$(document).on(Mapmaker.FilterView.events.change, function(event) {
				
			});

			// for NewTopicView
			$(document).on(Mapmaker.NewTopicView.events.create, function(event, data) {
				
			});

			// for NewSynapseView
			$(document).on(Mapmaker.NewSynapseView.events.create, function(event, data) {
				
			});	

			// for TopicMappingView
			$(document).on(Mapmaker.TopicMappingView.events.mousedown, function(event) {
				Handlers.topicMousedown.call(self);
			});
			$(document).on(Mapmaker.TopicMappingView.events.mouseup, function(event, topicMappingView) {
				Handlers.topicMouseup.call(self, topicMappingView);
			});
			$(document).on(Mapmaker.TopicMappingView.events.doubleClick, function(event, topicMappingView) {
				Handlers.topicDoubleClick.call(self, topicMappingView);
			});
			$(document).on(Mapmaker.TopicMappingView.events.dragEnd, function(event) {
				Handlers.topicDragEnd.call(self);
			});

      // for video feeds
      $(document).on(Mapmaker.VideoView.events.mousedown, function(event) {
        Handlers.videoMousedown.call(self);
      });
      $(document).on(Mapmaker.VideoView.events.mouseup, function(event, videoView) {
        Handlers.videoMouseup.call(self, videoView);
      });
      $(document).on(Mapmaker.VideoView.events.dragEnd, function(event) {
        Handlers.videoDragEnd.call(self);
      });
		},
		loadGraph: function() {
			var self = this;

      // draw the synapses first
      var synapses = this.currentMap.get("synapseMappings");
      //self.addSynapseMappingView(synapses.models[0]);
      synapses.each(function(synapseMapping) {
        self.addSynapseMappingView(synapseMapping);
      });
      
			// draw the topics second
			var topics = this.currentMap.get("topicMappings");
			topics.each(function(topicMapping) {
				self.addTopicMappingView(topicMapping);
				/*
				// animating
				self.topics[topicMapping.cid].mod.setTransform(Transform.translate(0,0,0));
				self.topics[topicMapping.cid].mod.setTransform(
					Transform.translate(topicMapping.get("xloc"),topicMapping.get("yloc"),0),
	            	{curve: Easing.inOutCubic, duration: 1000}
	           	);*/
			});

      Engine.on('prerender', function() {
        Object.keys(self.synapses).forEach(function(key) {
          self.synapses[key].updateDisplay();
        });
      });
		},
		getMetacodes: function(path) {
			var self = this;

			var start = function(data) {
				self.metacodes = new Mapmaker.MetacodeCollection(data);

        var
          set = new Mapmaker.MetacodeCollection(data.slice(0, 20));
        self.newTopic.initializeCarousel(set);
				Private.loadGraph.call(self);
			};

			$.ajax({
				url: path,
				success: start
			});
		}
	};

	var Handlers = {
		mousedown: function(event) {
			this.mouseIsDown = true;
		},
		mouseup: function(event) {
			this.mouseIsDown = false;
		},
		canvasDoubleClick: function(event) {

		},
		mousemove: function(event) {
			var newTransform;

			if (this.mouseIsDown && !this.draggingTopic && !this.draggingVideo) {
				this.translateX = this.translateX + event.movementX;
				this.translateY = this.translateY + event.movementY;
				newTransform = Transform.translate(this.translateX, this.translateY, 0);
				this.translateModifier.setTransform(newTransform);
			}
		},
		topicMousedown: function() {
			this.draggingTopic = true;
		},
		topicMouseup: function(topicMappingView) {
			
		},
		topicDoubleClick: function(topicMappingView) {
			var topic = topicMappingView.topic;

			// display a topic card
			if (!this.topicCards[topic.id]) {
				this.topicCards[topic.id] = new Mapmaker.TopicCardView({
					model: topic,
					mapView: this
				});
			}
			this.topicCards[topic.id].show();
		},
		topicDragEnd: function() {
			this.draggingTopic = false;
		},
    videoMousedown: function() {
      this.draggingVideo = true;
    },
    videoMouseup: function() {
      
    },
    videoDragEnd: function() {
      this.draggingVideo = false;
    }
	};

	/**
	 * Object providing an interface to drawing to the screen
	 * @class Mapmaker.MapView
	 * @param {Mapmaker.Map} map The map to create a view for
	 * @param {Object} config Configuration options, must be at least an empty
	 * object {@link Mapmaker.MapView#defaultConfig}
	 * @param {jQuery} $parent Jquery object pointing to the 'parent' element
	 * in the dom, and UI DOM elements created will be rooted here.
	 */
	var mapView = function(map, config, $parent) {
		var self = this;

		/**
		 * representation of the parent DOM element
		 * @property {jQuery}
		 */
		this.$parent = $parent;
		this.parseConfig(config);
		/**
		 * The current map
		 * @property {Mapmaker.Map}
		 */
		this.currentMap = map;

    function makeid() {
        var text = "";
        var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

        for( var i=0; i < 5; i++ )
            text += possible.charAt(Math.floor(Math.random() * possible.length));

        return text;
    }
    /**
     * The current map
     * @property {Mapmaker.Mapper}
     */
    this.currentMapper = new Mapmaker.Mapper({
      id: Math.floor(Math.random() * 20),
      name: makeid(),
      permission: 'commons',
      image: 'http://www.fitness-training-at-home.com/image-files/zflowericon.gif'
    });

		/**
		 * The collection of metacodes to use
		 * @property {Mapmaker.MetacodeCollection}
		 */
		this.metacodes = null;

		// these use the id of the topic or synapse as keys
		this.topicCards = {};
		this.synapseCards = {};

		// these store the topicMappingView and synapseMappingView views
		this.topics = {};
		this.synapses = {};

		this.mouseIsDown = false;
		this.draggingTopic = false;
    this.draggingVideo = false;

		this.Touch = {
		    touchPos: null, // this stores the x and y values of a current touch event 
		    touchDragNode: null // this stores a reference to a JIT node that is being dragged
		};

		this.Mouse = {
		    didPan: false,
		    didBoxZoom: false,
		    changeInX: 0,
		    changeInY: 0,
		    edgeHoveringOver: false,
		    boxStartCoordinates: false,
		    boxEndCoordinates: false,
		    synapseStartCoordinates: [],
		    synapseEndCoordinates: null,
		    lastNodeClick: 0,
		    lastCanvasClick: 0,
		    DOUBLE_CLICK_TOLERANCE: 300
		};

		this.Selected = {
		    reset: function () {
		        self.Selected.Nodes = [];
		        self.Selected.Edges = [];
		    },
		    Nodes: [],
		    Edges: []
		};

    Private.createGraphContainer.call(this);
		Private.createViews.call(this);
		Private.addModules.call(this);
		Private.getMetacodes.call(this, this.config.paths.metacodes);
		Private.subscribeEvents.call(this);
	};

	/**
	 * Parses and sets current configuration
	 * @param {Object} config The configration object, defaults will be applied.
	 * See {@link Mapmaker.MapView#defaultConfig}
	 */
	mapView.prototype.parseConfig = function(config) {
		Mapmaker.Utility.extendIf(config, defaultConfig);
		this.config = config;
	};


	mapView.prototype.addTopicMappingView = function(mapping) {
		var view = new Mapmaker.TopicMappingView(this, mapping);
		this.topics[mapping.cid] = view;
	};

	mapView.prototype.removeTopicMappingView = function(mapping) {
		this.topics[mapping.cid].remove();
		delete this.topics[mapping.cid];
	};

	mapView.prototype.addSynapseMappingView = function(mapping) {
		var view = new Mapmaker.SynapseMappingView(this, mapping);
		this.synapses[mapping.cid] = view;
	};

	mapView.prototype.removeSynapseMappingView = function(mapping) {
		this.synapses[mapping.cid].remove();
		delete this.synapses[mapping.cid];
	};

	return mapView;
}(jQuery, famous));

/**
 * @class
 * @static
 */
Mapmaker.MapView.events = {
	mappingSelected: "Mapmaker:MapView:mappingSelected"
};

Mapmaker.Mapper = (function() {

	return Backbone.Model.extend({
		urlRoot: '/users',
		blacklist: ['created_at', 'updated_at'],
		toJSON: function(options) {
			return _.omit(this.attributes, this.blacklist);
		},
		prepareLiForFilter: function() {
			var li = '';
			li += '<li data-id="' + this.id.toString() + '">';      
			li += '<img src="' + this.get("image") + '" data-id="' + this.id.toString() + '"';
			li += ' alt="' + this.get('name') + '" />';      
			li += '<p>' + this.get('name') + '</p></li>';
			return li;
		}
	});

}());

if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.Control = (function ($) {

    var control = function (mapView) {
        this.mapView = mapView;
    }

    control.prototype.init = function () {

    }

    control.prototype.selectNode = function (node,e) {
        var filtered = node.getData('alpha') === 0;

        if (filtered || this.mapView.Selected.Nodes.indexOf(node) != -1) return;
        node.selected = true;
        node.setData('dim', 30, 'current');
        this.mapView.Selected.Nodes.push(node);
    }

    control.prototype.deselectAllNodes = function () {
        var l = this.mapView.Selected.Nodes.length;
        for (var i = l - 1; i >= 0; i -= 1) {
            var node = this.mapView.Selected.Nodes[i];
            this.mapView.Control.deselectNode(node);
        }
        this.mapView.Visualize.mGraph.plot();
    }

    control.prototype.deselectNode = function (node) {
        delete node.selected;
        node.setData('dim', 25, 'current');

        //remove the node
        this.mapView.Selected.Nodes.splice(
        this.mapView.Selected.Nodes.indexOf(node), 1);
    }

    control.prototype.deleteSelected = function () {

        if (!this.mapView.Active.Map) return;
        
        var n = this.mapView.Selected.Nodes.length;
        var e = this.mapView.Selected.Edges.length;
        var ntext = n == 1 ? "1 topic" : n + " topics";
        var etext = e == 1 ? "1 synapse" : e + " synapses";
        var text = "You have " + ntext + " and " + etext + " selected. ";

        var authorized = this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        if (!authorized) {
            this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
            return;
        }

        var r = confirm(text + "Are you sure you want to permanently delete them all? This will remove them from all maps they appear on.");
        if (r == true) {
            this.mapView.Control.deleteSelectedEdges();
            this.mapView.Control.deleteSelectedNodes();
        }
    } 

    control.prototype.deleteSelectedNodes = function () { // refers to deleting topics permanently

        if (!this.mapView.Active.Map) return;

        var authorized = this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        if (!authorized) {
            this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
            return;
        }

        var l = this.mapView.Selected.Nodes.length;
        for (var i = l - 1; i >= 0; i -= 1) {
            var node = this.mapView.Selected.Nodes[i];
            this.mapView.Control.deleteNode(node.id);
        }
    } 

    control.prototype.deleteNode = function (nodeid) { // refers to deleting topics permanently
        
        if (!this.mapView.Active.Map) return;

        var authorized = this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        if (!authorized) {
            this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
            return;
        }

        var node = this.mapView.Visualize.mGraph.graph.getNode(nodeid);
        var topic = node.getData('topic');
        var topicid = topic.id;
        var mapping = node.getData('mapping');
        topic.destroy();
        this.mapView.Mappings.remove(mapping);
        $(document).trigger(this.mapView.JIT.events.deleteTopic, [{
            topicid: topicid
        }]);
        this.mapView.Control.hideNode(nodeid);
    } 

    control.prototype.removeSelectedNodes = function () { // refers to removing topics permanently from a map

        if (!this.mapView.Active.Map) return;

        var l = this.mapView.Selected.Nodes.length,
            i,
            node,
            authorized = this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        if (!authorized) {
            this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
            return;
        }

        for (i = l - 1; i >= 0; i -= 1) {
            node = this.mapView.Selected.Nodes[i];
            this.mapView.Control.removeNode(node.id);
        }
    }

    control.prototype.removeNode = function (nodeid) { // refers to removing topics permanently from a map

        if (!this.mapView.Active.Map) return;

        var authorized = this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);
        var node = this.mapView.Visualize.mGraph.graph.getNode(nodeid);

        if (!authorized) {
            this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
            return;
        }

        var topic = node.getData('topic');
        var topicid = topic.id;
        var mapping = node.getData('mapping');
        mapping.destroy();
        this.mapView.Topics.remove(topic);
        $(document).trigger(this.mapView.JIT.events.removeTopic, [{
            topicid: topicid
        }]);
        this.mapView.Control.hideNode(nodeid);
    }

    control.prototype.hideSelectedNodes = function () {
        var l = this.mapView.Selected.Nodes.length,
            i,
            node;

        for (i = l - 1; i >= 0; i -= 1) {
            node = this.mapView.Selected.Nodes[i];
            this.mapView.Control.hideNode(node.id);
        }
    }

    control.prototype.hideNode = function (nodeid) {
        var node = this.mapView.Visualize.mGraph.graph.getNode(nodeid);
        var graph = this.mapView.Visualize.mGraph;
        if (nodeid == this.mapView.Visualize.mGraph.root) { // && this.mapView.Visualize.type === "RGraph"
            var newroot = _.find(graph.graph.nodes, function(n){ return n.id !== nodeid; });
            graph.root = newroot ? newroot.id : null;
        }

        this.mapView.Control.deselectNode(node);

        node.setData('alpha', 0, 'end');
        node.eachAdjacency(function (adj) {
            adj.setData('alpha', 0, 'end');
        });
        this.mapView.Visualize.mGraph.fx.animate({
            modes: ['node-property:alpha',
            'edge-property:alpha'
        ],
            duration: 500
        });
        setTimeout(function () {
            this.mapView.Visualize.mGraph.graph.removeNode(nodeid);
        }, 500);
        this.mapView.Filter.checkMetacodes();
        this.mapView.Filter.checkMappers();
    }

    control.prototype.selectEdge = function (edge) {
        var filtered = edge.getData('alpha') === 0; // don't select if the edge is filtered

        if (filtered || this.mapView.Selected.Edges.indexOf(edge) != -1) return;

        var width = this.mapView.Mouse.edgeHoveringOver === edge ? 4 : 2;
        edge.setDataset('current', {
            showDesc: true,
            lineWidth: width,
            color: this.mapView.Settings.colors.synapses.selected
        });
        this.mapView.Visualize.mGraph.plot();

        this.mapView.Selected.Edges.push(edge);
    }

    control.prototype.deselectAllEdges = function () {
        var l = this.mapView.Selected.Edges.length;
        for (var i = l - 1; i >= 0; i -= 1) {
            var edge = this.mapView.Selected.Edges[i];
            this.mapView.Control.deselectEdge(edge);
        }
        this.mapView.Visualize.mGraph.plot();
    }

    control.prototype.deselectEdge = function (edge) {
        edge.setData('showDesc', false, 'current');
        
        edge.setDataset('current', {
            lineWidth: 2,
            color: this.mapView.Settings.colors.synapses.normal
        });

        if (this.mapView.Mouse.edgeHoveringOver == edge) {
            edge.setDataset('current', {
                showDesc: true,
                lineWidth: 4
            });
        }

        this.mapView.Visualize.mGraph.plot();

        //remove the edge
        this.mapView.Selected.Edges.splice(
        this.mapView.Selected.Edges.indexOf(edge), 1);
    }

    control.prototype.deleteSelectedEdges = function () { // refers to deleting topics permanently
        var edge,
            l = this.mapView.Selected.Edges.length;

        if (!this.mapView.Active.Map) return;

        var authorized = this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        if (!authorized) {
            this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
            return;
        }

        for (var i = l - 1; i >= 0; i -= 1) {
            edge = this.mapView.Selected.Edges[i];
            this.mapView.Control.deleteEdge(edge);
        }
    }

    control.prototype.deleteEdge = function (edge) {

        if (!this.mapView.Active.Map) return;

        var authorized = this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        if (!authorized) {
            this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
            return;
        }

        if (edge.getData("synapses").length - 1 === 0) {
            this.mapView.Control.hideEdge(edge);
        }

        var index = edge.getData("displayIndex") ? edge.getData("displayIndex") : 0;

        var synapse = edge.getData("synapses")[index];
        var mapping = edge.getData("mappings")[index];
        var synapseid = synapse.id;
        synapse.destroy();

        // the server will destroy the mapping, we just need to remove it here
        this.mapView.Mappings.remove(mapping);
        edge.getData("mappings").splice(index, 1);
        edge.getData("synapses").splice(index, 1);
        if (edge.getData("displayIndex")) {
            delete edge.data.$displayIndex;
        }
        $(document).trigger(this.mapView.JIT.events.deleteSynapse, [{
            synapseid: synapseid
        }]);
    }

    control.prototype.removeSelectedEdges = function () {
        var l = this.mapView.Selected.Edges.length,
            i,
            edge;

        if (!this.mapView.Active.Map) return;

        var authorized = this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        if (!authorized) {
            this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
            return;
        }

        for (i = l - 1; i >= 0; i -= 1) {
            edge = this.mapView.Selected.Edges[i];
            this.mapView.Control.removeEdge(edge);
        }
        this.mapView.Selected.Edges = new Array();
    }

    control.prototype.removeEdge = function (edge) {

        if (!this.mapView.Active.Map) return;

        var authorized = this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        if (!authorized) {
            this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
            return;
        }

        if (edge.getData("mappings").length - 1 === 0) {
            this.mapView.Control.hideEdge(edge);
        }

        var index = edge.getData("displayIndex") ? edge.getData("displayIndex") : 0;

        var synapse = edge.getData("synapses")[index];
        var mapping = edge.getData("mappings")[index];
        var synapseid = synapse.id;
        mapping.destroy();

        this.mapView.Synapses.remove(synapse);

        edge.getData("mappings").splice(index, 1);
        edge.getData("synapses").splice(index, 1);
        if (edge.getData("displayIndex")) {
            delete edge.data.$displayIndex;
        }
        $(document).trigger(this.mapView.JIT.events.removeSynapse, [{
            synapseid: synapseid
        }]);
    }

    control.prototype.hideSelectedEdges = function () {
        var edge,
            l = this.mapView.Selected.Edges.length,
            i;
        for (i = l - 1; i >= 0; i -= 1) {
            edge = this.mapView.Selected.Edges[i];
            this.mapView.Control.hideEdge(edge);
        }
        this.mapView.Selected.Edges = new Array();
    }

    control.prototype.hideEdge = function (edge) {
        var from = edge.nodeFrom.id;
        var to = edge.nodeTo.id;
        edge.setData('alpha', 0, 'end');
        this.mapView.Control.deselectEdge(edge);
        this.mapView.Visualize.mGraph.fx.animate({
            modes: ['edge-property:alpha'],
            duration: 500
        });
        setTimeout(function () {
            this.mapView.Visualize.mGraph.graph.removeAdjacence(from, to);
        }, 500);
        this.mapView.Filter.checkSynapses();
        this.mapView.Filter.checkMappers();
    }

    control.prototype.updateSelectedPermissions = function (permission) {

        var edge, synapse, node, topic;

        this.mapView.GlobalUI.notifyUser('Working...');

        // variables to keep track of how many nodes and synapses you had the ability to change the permission of
        var nCount = 0,
            sCount = 0;

        // change the permission of the selected synapses, if logged in user is the original creator
        var l = this.mapView.Selected.Edges.length;
        for (var i = l - 1; i >= 0; i -= 1) {
            edge = this.mapView.Selected.Edges[i];
            synapse = edge.getData('synapses')[0];

            if (synapse.authorizePermissionChange(this.mapView.Active.Mapper)) {
                synapse.save({
                    permission: permission
                });
                sCount++;
            }
        }

        // change the permission of the selected topics, if logged in user is the original creator
        var l = this.mapView.Selected.Nodes.length;
        for (var i = l - 1; i >= 0; i -= 1) {
            node = this.mapView.Selected.Nodes[i];
            topic = node.getData('topic');

            if (topic.authorizePermissionChange(this.mapView.Active.Mapper)) {
                topic.save({
                    permission: permission
                });
                nCount++;
            }
        }

        var nString = nCount == 1 ? (nCount.toString() + ' topic and ') : (nCount.toString() + ' topics and ');
        var sString = sCount == 1 ? (sCount.toString() + ' synapse') : (sCount.toString() + ' synapses');

        var message = nString + sString + ' you created updated to ' + permission;
        this.mapView.GlobalUI.notifyUser(message);
    }

    control.prototype.updateSelectedMetacodes = function (metacode_id) {

        var node, topic;

        this.mapView.GlobalUI.notifyUser('Working...');

        var metacode = this.mapView.Metacodes.get(metacode_id);

        // variables to keep track of how many nodes and synapses you had the ability to change the permission of
        var nCount = 0;

        // change the permission of the selected topics, if logged in user is the original creator
        var l = this.mapView.Selected.Nodes.length;
        for (var i = l - 1; i >= 0; i -= 1) {
            node = this.mapView.Selected.Nodes[i];
            topic = node.getData('topic');

            if (topic.authorizeToEdit(this.mapView.Active.Mapper)) {
                topic.save({
                    'metacode_id': metacode_id
                });
                nCount++;
            }
        }

        var nString = nCount == 1 ? (nCount.toString() + ' topic') : (nCount.toString() + ' topics');

        var message = nString + ' you can edit updated to ' + metacode.get('name');
        this.mapView.GlobalUI.notifyUser(message);
        this.mapView.Visualize.mGraph.plot();
    }

    return control; 

}(jQuery));

if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.Create = (function ($) {

    var newTopic = function (mapView) {
        this.mapView = mapView;

        this.name = null;
        this.newId = 1;
        this.beingCreated = false;
        this.metacode = null;
        this.x = null;
        this.y = null;
        this.addSynapse = false;
    };

    newTopic.prototype.init = function () {
        var self = this;

        $('#topic_name').keyup(function () {
            self.name = $(this).val();
        });

        // initialize the autocomplete results for the metacode spinner
        $('#topic_name').typeahead([
            {
                name: 'topic_autocomplete',
                limit: 8,
                template: $('#topicAutocompleteTemplate').html(),
                remote: {
                    url: '/topics/autocomplete_topic?term=%QUERY'
                },
                engine: Hogan
              }
        ]);

        // tell the autocomplete to submit the form with the topic you clicked on if you pick from the autocomplete
        $('#topic_name').bind('typeahead:selected', function (event, datum, dataset) {
            this.mapView.Topic.getTopicFromAutocomplete(datum.id);
        });

        // initialize metacode spinner and then hide it
        $("#metacodeImg").CloudCarousel({
            titleBox: $('#metacodeImgTitle'),
            yRadius: 40,
            xRadius: 190,
            xPos: 170,
            yPos: 40,
            speed: 0.3,
            mouseWheel: true,
            bringToFront: true
        });
        $('.new_topic').hide();
    }

    newTopic.prototype.open = function () {
        $('#new_topic').fadeIn('fast', function () {
            $('#topic_name').focus();
        });
        this.beingCreated = true;
        this.name = "";
    } 

    newTopic.prototype.hide = function () {
        $('#new_topic').fadeOut('fast');
        $("#topic_name").typeahead('setQuery', '');
        this.beingCreated = false;
    }


    var newSynapse = function (mapView) {
        this.mapView = mapView;

        this.beingCreated = false;
        this.description = null;
        this.topic1id = null;
        this.topic2id = null;
        this.newSynapseId = null;
    };

    newSynapse.prototype.init = function () {
        var self = this;

        $('#synapse_desc').keyup(function () {
            this.newSynapse.description = $(this).val();
        });

        // initialize the autocomplete results for synapse creation
        $('#synapse_desc').typeahead([
            {
                name: 'synapse_autocomplete',
                template: "<div class='genericSynapseDesc'>{{label}}</div>",
                remote: {
                    url: '/search/synapses?term=%QUERY'
                },
                engine: Hogan
            },
            {
                name: 'existing_synapses',
                limit: 50,
                template: $('#synapseAutocompleteTemplate').html(),
                remote: {
                    url: '/search/synapses',
                    replace: function () {
                        return self.getSearchQuery();
                    }
                },
                engine: Hogan,
                header: "<h3>Existing synapses</h3>"
            }
      ]);

        $('#synapse_desc').bind('typeahead:selected', function (event, datum, dataset) {
            if (datum.id) { // if they clicked on an existing synapse get it
                this.mapView.Synapse.getSynapseFromAutocomplete(datum.id);
            }
            else {
                self.description = datum.value;
                this.mapView.Synapse.createSynapseLocally();
            }
        });
    }

    newSynapse.prototype.open = function () {
        $('#new_synapse').fadeIn('fast', function () {
            $('#synapse_desc').focus();
        });
        this.beingCreated = true;
    }

    newSynapse.prototype.hide = function () {
        $('#new_synapse').fadeOut('fast');
        $("#synapse_desc").typeahead('setQuery', '');
        this.newSynapse.beingCreated = false;
        this.newTopic.addSynapse = false;
        this.topic1id = 0;
        this.topic2id = 0;
        this.mapView.Mouse.synapseStartCoordinates = [];
        this.mapView.Visualize.mGraph.plot();
    }

    newSynapse.prototype.getSearchQuery = function () {
        var self = this.newSynapse;

        if (this.mapView.Selected.Nodes.length < 2) {
            return '/search/synapses?topic1id=' + self.topic1id + '&topic2id=' + self.topic2id;
        } else return '';
    }

    var create = function (mapView) {
        this.mapView = mapView;

        this.isSwitchingSet = false; // indicates whether the metacode set switch lightbox is open
        this.selectedMetacodeSet = null;
        this.selectedMetacodeSetIndex = null;
        this.selectedMetacodeNames = [];
        this.newSelectedMetacodeNames = [];
        this.selectedMetacodes = [];
        this.newSelectedMetacodes = [];

        this.newTopic = new newTopic(this.mapView);
        this.newSynapse = new newSynapse(this.mapView);
    }

    create.prototype.init = function () {
        var self = this;
        self.newTopic.init();
        self.newSynapse.init();

        //////
        //////
        //// SWITCHING METACODE SETS

        $('#metacodeSwitchTabs').tabs({
            selected: self.selectedMetacodeSetIndex
        }).addClass("ui-tabs-vertical ui-helper-clearfix");
        $("#metacodeSwitchTabs .ui-tabs-nav li").removeClass("ui-corner-top").addClass("ui-corner-left");
        $('.customMetacodeList li').click(self.toggleMetacodeSelected); // within the custom metacode set tab
    }

    create.prototype.toggleMetacodeSelected = function () {
        var self = this;

        if ($(this).attr('class') != 'toggledOff') {
            $(this).addClass('toggledOff');
            var value_to_remove = $(this).attr('id');
            var name_to_remove = $(this).attr('data-name');
            self.newSelectedMetacodes.splice(self.newSelectedMetacodes.indexOf(value_to_remove), 1);
            self.newSelectedMetacodeNames.splice(self.newSelectedMetacodeNames.indexOf(name_to_remove), 1);
        } else if ($(this).attr('class') == 'toggledOff') {
            $(this).removeClass('toggledOff');
            self.newSelectedMetacodes.push($(this).attr('id'));
            self.newSelectedMetacodeNames.push($(this).attr('data-name'));
        }
    }

    create.prototype.updateMetacodeSet = function (set, index, custom) {

        if (custom && this.newSelectedMetacodes.length == 0) {
            alert('Please select at least one metacode to use!');
            return false;
        }

        var codesToSwitchToIds;
        var metacodeModels = new this.mapView.Backbone.MetacodeCollection();
        this.selectedMetacodeSetIndex = index;
        this.selectedMetacodeSet = "metacodeset-" + set;

        if (!custom) {
            codesToSwitchToIds = $('#metacodeSwitchTabs' + set).attr('data-metacodes').split(',');
            $('.customMetacodeList li').addClass('toggledOff');
            this.selectedMetacodes = [];
            this.selectedMetacodeNames = [];
            this.newSelectedMetacodes = [];
            this.newSelectedMetacodeNames = [];
        }
        else if (custom) {
            // uses .slice to avoid setting the two arrays to the same actual array
            this.selectedMetacodes = this.newSelectedMetacodes.slice(0);
            this.selectedMetacodeNames = this.newSelectedMetacodeNames.slice(0);
            codesToSwitchToIds = this.selectedMetacodes.slice(0);
        }

        // sort by name
        for (var i = 0; i < codesToSwitchToIds.length; i++) {
            metacodeModels.add( this.mapView.Metacodes.get(codesToSwitchToIds[i]) );
        };
        metacodeModels.sort();

        $('#metacodeImg, #metacodeImgTitle').empty();
        $('#metacodeImg').removeData('cloudcarousel');
        var newMetacodes = "";
        metacodeModels.each(function(metacode){
            newMetacodes += '<img class="cloudcarousel" width="40" height="40" src="' + metacode.get('icon') + '" data-id="' + metacode.id + '" title="' + metacode.get('name') + '" alt="' + metacode.get('name') + '"/>';
        });
            
        $('#metacodeImg').empty().append(newMetacodes).CloudCarousel({
            titleBox: $('#metacodeImgTitle'),
            yRadius: 40,
            xRadius: 190,
            xPos: 170,
            yPos: 40,
            speed: 0.3,
            mouseWheel: true,
            bringToFront: true
        });

        this.mapView.GlobalUI.closeLightbox();
        $('#topic_name').focus();

        var mdata = {
            "metacodes": {
                "value": custom ? this.selectedMetacodes.toString() : this.selectedMetacodeSet
            }
        };
        $.ajax({
            type: "POST",
            dataType: 'json',
            url: "/user/updatemetacodes",
            data: mdata,
            success: function (data) {
                console.log('selected metacodes saved');
            },
            error: function () {
                console.log('failed to save selected metacodes');
            }
        });
    }

    create.prototype.cancelMetacodeSetSwitch = function () {
        var self = this;
        self.isSwitchingSet = false;

        if (self.selectedMetacodeSet != "metacodeset-custom") {
            $('.customMetacodeList li').addClass('toggledOff');
            self.selectedMetacodes = [];
            self.selectedMetacodeNames = [];
            self.newSelectedMetacodes = [];
            self.newSelectedMetacodeNames = [];
        } else { // custom set is selected
            // reset it to the current actual selection
            $('.customMetacodeList li').addClass('toggledOff');
            for (var i = 0; i < self.selectedMetacodes.length; i++) {
                $('#' + self.selectedMetacodes[i]).removeClass('toggledOff');
            };
            // uses .slice to avoid setting the two arrays to the same actual array
            self.newSelectedMetacodeNames = self.selectedMetacodeNames.slice(0);
            self.newSelectedMetacodes = self.selectedMetacodes.slice(0);
        }
        $('#metacodeSwitchTabs').tabs("select", self.selectedMetacodeSetIndex);
        $('#topic_name').focus();
    }

    return create;
}(jQuery));

if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.JIT = (function ($) {

var graphObjects = {
    ForceDirected: {
        animateSavedLayout: {
            modes: ['linear'],
            transition: $jit.Trans.Quad.easeInOut,
            duration: 800,
            onComplete: function () {
                this.mapView.Visualize.mGraph.busy = false;
                $(document).trigger(this.events.animationDone);
            }
        },
        animateFDLayout: {
            modes: ['linear'],
            transition: $jit.Trans.Elastic.easeOut,
            duration: 800,
            onComplete: function () {
                this.mapView.Visualize.mGraph.busy = false;
            }
        },
        graphSettings: {
            //id of the visualization container
            injectInto: 'infovis',
            //Enable zooming and panning
            //by scrolling and DnD
            Navigation: {
                enable: true,
                //Enable panning events only if we're dragging the empty
                //canvas (and not a node).
                panning: 'avoid nodes',
                zooming: 28 //zoom speed. higher is more sensible
            },
            //background: {
            //    type: 'this.mapView'
            //},
            //NodeStyles: {  
            //  enable: true,  
            //  type: 'Native',  
            //  stylesHover: {  
            //    dim: 30  
            //  },  
            //  duration: 300  
            //},
            // Change node and edge styles such as
            // color and width.
            // These properties are also set per node
            // with dollar prefixed data-properties in the
            // JSON structure.
            Node: {
                overridable: true,
                color: '#2D6A5D',
                type: 'customNode',
                dim: 25
            },
            Edge: {
                overridable: true,
                color: '#123', //this.mapView.Settings.colors.synapses.normal,
                type: 'customEdge',
                lineWidth: 2,
                alpha: 1
            },
            //Native canvas text styling
            Label: {
                type: 'Native', //Native or HTML
                size: 20,
                family: 'arial',
                textBaseline: 'alphabetic',
                color: '#123' //this.mapView.Settings.colors.labels.text
            },
            //Add Tips
            Tips: {
                enable: false,
                onShow: function (tip, node) {}
            },
            // Add node events
            Events: {
                enable: true,
                enableForEdges: true,
                onMouseMove: function (node, eventInfo, e) {
                    this.onMouseMoveHandler(node, eventInfo, e);
                    //console.log('called mouse move handler');
                },
                //Update node positions when dragged
                onDragMove: function (node, eventInfo, e) {
                    this.onDragMoveTopicHandler(node, eventInfo, e);
                    //console.log('called drag move handler');
                },
                onDragEnd: function (node, eventInfo, e) {
                    this.onDragEndTopicHandler(node, eventInfo, e, false);
                    //console.log('called drag end handler');
                },
                onDragCancel: function (node, eventInfo, e) {
                    this.onDragCancelHandler(node, eventInfo, e, false);
                },
                //Implement the same handler for touchscreens
                onTouchStart: function (node, eventInfo, e) {
                    //$jit.util.event.stop(e); //stop default touchmove event
                    //this.mapView.Visualize.mGraph.events.onMouseDown(e, null, eventInfo);
                    this.mapView.Visualize.mGraph.events.touched = true;
                    this.mapView.Touch.touchPos = eventInfo.getPos();
                    var canvas = this.mapView.Visualize.mGraph.canvas,
                        ox = canvas.translateOffsetX;
                    oy = canvas.translateOffsetY,
                    sx = canvas.scaleOffsetX,
                    sy = canvas.scaleOffsetY;
                    this.mapView.Touch.touchPos.x *= sx;
                    this.mapView.Touch.touchPos.y *= sy;
                    this.mapView.Touch.touchPos.x += ox;
                    this.mapView.Touch.touchPos.y += oy;

                    touchDragNode = node;
                },
                //Implement the same handler for touchscreens
                onTouchMove: function (node, eventInfo, e) {
                    if (this.mapView.Touch.touchDragNode) this.onDragMoveTopicHandler(this.mapView.Touch.touchDragNode, eventInfo, e);
                    else {
                        this.touchPanZoomHandler(eventInfo, e);
                    }
                },
                //Implement the same handler for touchscreens
                onTouchEnd: function (node, eventInfo, e) {

                },
                //Implement the same handler for touchscreens
                onTouchCancel: function (node, eventInfo, e) {

                },
                //Add also a click handler to nodes
                onClick: function (node, eventInfo, e) {

                    // remove the rightclickmenu
                    $('.rightclickmenu').remove();

                    if (this.mapView.Mouse.boxStartCoordinates) {
                        if(e.ctrlKey){
                            this.mapView.Visualize.mGraph.busy = false;
                            this.mapView.Mouse.boxEndCoordinates = eventInfo.getPos();

                            var bS = this.mapView.Mouse.boxStartCoordinates;
                            var bE = this.mapView.Mouse.boxEndCoordinates;
                            if (Math.abs(bS.x - bE.x) > 20 && Math.abs(bS.y - bE.y) > 20) {
                                this.zoomToBox(e);
                                return;
                            }
                            else {
                                this.mapView.Mouse.boxStartCoordinates = null;
                                this.mapView.Mouse.boxEndCoordinates = null;
                            }
                            //console.log('called zoom to box');
                        }
                        
                        if (e.shiftKey) {
                            this.mapView.Visualize.mGraph.busy = false;
                            this.mapView.Mouse.boxEndCoordinates = eventInfo.getPos();
                            this.selectWithBox(e);
                            //console.log('called select with box');
                            return;
                        };
                    }

                    if (e.target.id != "infovis-canvas") return false;

                    //clicking on a edge, node, or clicking on blank part of canvas?
                    if (node.nodeFrom) {
                        this.selectEdgeOnClickHandler(node, e);
                        //console.log('called selectEdgeOnClickHandler');
                    } else if (node && !node.nodeFrom) {
                        this.selectNodeOnClickHandler(node, e);
                        //console.log('called selectNodeOnClickHandler');
                    } else {
                        this.canvasClickHandler(eventInfo.getPos(), e);
                        //console.log('called canvasClickHandler');
                    } //if
                },
                //Add also a click handler to nodes
                onRightClick: function (node, eventInfo, e) {

                    // remove the rightclickmenu
                    $('.rightclickmenu').remove();

                    if (this.mapView.Mouse.boxStartCoordinates) {
                        this.mapView.Visualize.mGraph.busy = false;
                        this.mapView.Mouse.boxEndCoordinates = eventInfo.getPos();
                        this.selectWithBox(e);
                        return;
                    }

                    if (e.target.id != "infovis-canvas") return false;

                    //clicking on a edge, node, or clicking on blank part of canvas?
                    if (node.nodeFrom) {
                        this.selectEdgeOnRightClickHandler(node, e);
                    } else if (node && !node.nodeFrom) {
                        this.selectNodeOnRightClickHandler(node, e);
                    } else {
                        //console.log('right clicked on open space');
                    } 
                }
            },
            //Number of iterations for the FD algorithm
            iterations: 200,
            //Edge length
            levelDistance: 200,
        },
        nodeSettings: {
            customNode: {
                render: function (node, canvas) {
                    var pos = node.pos.getc(true),
                        dim = node.getData('dim'),
                        topic = node.getData('topic'),
                        metacode = topic ? topic.getMetacode() : false,
                        ctx = canvas.getCtx();

                    // if the topic is selected draw a circle around it
                    if (!canvas.denySelected && node.selected) {
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, dim + 3, 0, 2 * Math.PI, false);
                        ctx.strokeStyle = this.mapView.Settings.colors.topics.selected;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    if (!metacode ||
                        !metacode.get('image') ||
                        !metacode.get('image').complete ||
                        (typeof metacode.get('image').naturalWidth !== "undefined" &&
                            metacode.get('image').naturalWidth === 0)) {
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, dim, 0, 2 * Math.PI, false);
                        ctx.fillStyle = '#B6B2FD';
                        ctx.fill();
                    } else {
                        ctx.drawImage(metacode.get('image'), pos.x - dim, pos.y - dim, dim * 2, dim * 2);
                    }

                    // if the topic has a link, draw a small image to indicate that
                    var hasLink = topic && topic.get('link') !== "" && topic.get('link') !== null;
                    var linkImage = this.topicLinkImage;
                    var linkImageLoaded = linkImage.complete ||
                        (typeof linkImage.naturalWidth !== "undefined" &&
                            linkImage.naturalWidth !== 0)
                    if (hasLink && linkImageLoaded) {
                        ctx.drawImage(linkImage, pos.x - dim - 8, pos.y - dim - 8, 16, 16);
                    }

                    // if the topic has a desc, draw a small image to indicate that
                    var hasDesc = topic && topic.get('desc') !== "" && topic.get('desc') !== null;
                    var descImage = this.topicDescImage;
                    var descImageLoaded = descImage.complete ||
                        (typeof descImage.naturalWidth !== "undefined" &&
                            descImage.naturalWidth !== 0)
                    if (hasDesc && descImageLoaded) {
                        ctx.drawImage(descImage, pos.x + dim - 8, pos.y - dim - 8, 16, 16);
                    }
                },
                contains: function (node, pos) {
                    var npos = node.pos.getc(true),
                        dim = node.getData('dim'),
                        arrayOfLabelLines = this.mapView.Util.splitLine(node.name, 30).split('\n'),
                        ctx = this.mapView.Visualize.mGraph.canvas.getCtx();

                    var height = 25 * arrayOfLabelLines.length;

                    var index, lineWidths = [];
                    for (index = 0; index < arrayOfLabelLines.length; ++index) {
                        lineWidths.push(ctx.measureText(arrayOfLabelLines[index]).width)
                    }
                    var width = Math.max.apply(null, lineWidths) + 8;
                    var labely = npos.y + node.getData("height") + 5 + height / 2;

                    var overLabel = this.nodeHelper.rectangle.contains({
                        x: npos.x,
                        y: labely
                    }, pos, width, height);

                    return this.nodeHelper.circle.contains(npos, pos, dim) || overLabel;
                }
            }
        },
        edgeSettings: {
            customEdge: {
                render: function (adj, canvas) {
                    this.edgeRender(adj, canvas)
                },
                contains: function (adj, pos) {
                    var from = adj.nodeFrom.pos.getc(),
                        to = adj.nodeTo.pos.getc();
                    
                    // this fixes an issue where when edges are perfectly horizontal or perfectly vertical
                    // it becomes incredibly difficult to hover over them
                    if (-1 < pos.x && pos.x < 1) pos.x = 0;
                    if (-1 < pos.y && pos.y < 1) pos.y = 0;
                    
                    return $jit.Graph.Plot.edgeHelper.line.contains(from, to, pos, adj.Edge.epsilon + 5);
                }
            }
        }
    }, // ForceDirected
    RGraph: {
        animate: {
            modes: ['polar'],
            duration: 800,
            onComplete: function () {
                this.mapView.Visualize.mGraph.busy = false;
            }
        },
        // this will just be used to patch the ForceDirected graphsettings with the few things which actually differ
        background: {
                //type: 'this.mapView',
                levelDistance: 200,
                numberOfCircles: 4,
                CanvasStyles: {
                    strokeStyle: '#333',
                    lineWidth: 1.5
                }
        },
        levelDistance: 200
    }
};


    var jit = function (mapView) {
        this.mapView = mapView;

        this.vizData = []; // contains the visualization-compatible graph

        Mapmaker.Utility.extendIf(this, graphObjects);
    }
    
    /**
     * This method will bind the event handlers it is interested and initialize the class.
     */
    jit.prototype.init = function () {
        var self = this;

        $(".zoomIn").click(self.zoomIn);
        $(".zoomOut").click(self.zoomOut);

        var zoomExtents = function (event) {
            self.zoomExtents(event, this.mapView.Visualize.mGraph.canvas);
        };
        $(".zoomExtents").click(zoomExtents);

        $(".takeScreenshot").click(this.mapView.Map.exportImage);

        self.topicDescImage = new Image();
        self.topicDescImage.src = '/assets/topic_description_signifier.png';

        self.topicLinkImage = new Image();
        self.topicLinkImage.src = '/assets/topic_link_signifier.png';
    }

    /**
     * convert our topic JSON into something JIT can use
     */
    jit.prototype.convertModelsToJIT = function(topics, synapses) {
        var jitReady = [];

        var synapsesToRemove = [];
        var topic;
        var mapping;
        var node;
        var nodes = {};
        var existingEdge;
        var edge;
        var edges = [];

        topics.each(function (t) {
            node = t.createNode();
            nodes[node.id] = node;
        });
        synapses.each(function (s) {
            edge = s.createEdge();

            if (topics.get(s.get('node1_id')) === undefined || topics.get(s.get('node2_id')) === undefined) {
                // this means it's an invalid synapse
                synapsesToRemove.push(s);
            } 
            else if (nodes[edge.nodeFrom] && nodes[edge.nodeTo]) {

                existingEdge = _.findWhere(edges, {
                    nodeFrom: edge.nodeFrom,
                    nodeTo: edge.nodeTo
                }) ||
                    _.findWhere(edges, {
                        nodeFrom: edge.nodeTo,
                        nodeTo: edge.nodeFrom
                    });

                if (existingEdge) {
                    // for when you're dealing with multiple relationships between the same two topics
                    if (this.mapView.Active.Map) {
                        mapping = s.getMapping();
                        existingEdge.data['$mappingIDs'].push(mapping.id);
                    }
                    existingEdge.data['$synapseIDs'].push(s.id);
                } else {
                    // for when you're dealing with a topic that has relationships to many different nodes
                    nodes[edge.nodeFrom].adjacencies.push(edge);
                    edges.push(edge);
                }
            }
        });

        _.each(nodes, function (node) {
            jitReady.push(node);
        });

        return [jitReady, synapsesToRemove];
    }

    jit.prototype.prepareVizData = function () {
        var self = this;
        var mapping;

        // reset/empty vizData
        self.vizData = [];
        this.mapView.Visualize.loadLater = false;

        var results = self.convertModelsToJIT(this.mapView.Topics, this.mapView.Synapses);

        self.vizData = results[0];

        // clean up the synapses array in case of any faulty data
        _.each(results[1], function (synapse) {
            mapping = synapse.getMapping();
            this.mapView.Synapses.remove(synapse);
            this.mapView.Mappings.remove(mapping);
        });

        if (self.vizData.length == 0) {
            this.mapView.Famous.viz.showInstructions();
            this.mapView.Visualize.loadLater = true;
        }
        else this.mapView.Famous.viz.hideInstructions();

        this.mapView.Visualize.render();
    } // prepareVizData

    jit.prototype.edgeRender = function (adj, canvas) {
        //get nodes cartesian coordinates 
        var pos = adj.nodeFrom.pos.getc(true);
        var posChild = adj.nodeTo.pos.getc(true);

        var synapse;
        if(adj.getData("displayIndex")) {
            synapse = adj.getData("synapses")[adj.getData("displayIndex")];
            if (!synapse) {
                delete adj.data.$displayIndex;
                synapse = adj.getData("synapses")[0];
            }
        }
        else {
            synapse = adj.getData("synapses")[0];
        }

        if (!synapse) return; // this means there are no corresponding synapses for
        // this edge, don't render it

        var directionCat = synapse.get("category");

        //label placement on edges
        if (canvas.denySelected) {
            var color = this.mapView.Settings.colors.synapses.normal;
            canvas.getCtx().fillStyle = canvas.getCtx().strokeStyle = color;
        }
        this.renderEdgeArrows($jit.Graph.Plot.edgeHelper, adj, synapse, canvas);

        //check for edge label in data  
        var desc = synapse.get("desc");

        var showDesc = adj.getData("showDesc");

        var drawSynapseCount = function (context, x, y, count) {
            /*
            circle size: 16x16px
            positioning: overlay and center on top right corner of synapse label - 8px left and 8px down
            color: #dab539
            border color: #424242
            border size: 1.5px
            font: DIN medium
            font-size: 14pt
            font-color: #424242
            */
            context.beginPath();
            context.arc(x, y, 8, 0, 2 * Math.PI, false);
            context.fillStyle = '#DAB539';
            context.strokeStyle = '#424242';
            context.lineWidth = 1.5;
            context.closePath();
            context.fill();
            context.stroke();

            // add the synapse count
            context.fillStyle = '#424242';
            context.textAlign = 'center';
            context.font = '14px din-medium';

            context.fillText(count, x, y + 5);
        };

        if (!canvas.denySelected && desc != "" && showDesc) {
            // '&amp;' to '&'
            desc = this.mapView.Util.decodeEntities(desc);

            //now adjust the label placement 
            var ctx = canvas.getCtx();
            ctx.font = 'bold 14px arial';
            ctx.fillStyle = '#FFF';
            ctx.textBaseline = 'alphabetic';

            var arrayOfLabelLines = this.mapView.Util.splitLine(desc, 30).split('\n');
            var index, lineWidths = [];
            for (index = 0; index < arrayOfLabelLines.length; ++index) {
                lineWidths.push(ctx.measureText(arrayOfLabelLines[index]).width)
            }
            var width = Math.max.apply(null, lineWidths) + 16;
            var height = (16 * arrayOfLabelLines.length) + 8;

            var x = (pos.x + posChild.x - width) / 2;
            var y = ((pos.y + posChild.y) / 2) - height / 2;

            var radius = 5;

            //render background
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();

            // get number of synapses
            var synapseNum = adj.getData("synapses").length;

            //render text
            ctx.fillStyle = '#424242';
            ctx.textAlign = 'center';
            for (index = 0; index < arrayOfLabelLines.length; ++index) {
                ctx.fillText(arrayOfLabelLines[index], x + (width / 2), y + 18 + (16 * index));
            }

            if (synapseNum > 1) {
                drawSynapseCount(ctx, x + width, y, synapseNum);
            }
        }
        else if (!canvas.denySelected && showDesc) {
            // get number of synapses
            var synapseNum = adj.getData("synapses").length;

            if (synapseNum > 1) {
                var ctx = canvas.getCtx();
                var x = (pos.x + posChild.x) / 2;
                var y = (pos.y + posChild.y) / 2;
                drawSynapseCount(ctx, x, y, synapseNum);
            }
        }

    } // edgeRender

    jit.prototype.onMouseEnter = function (edge) {
        var filtered = edge.getData('alpha') === 0;

        // don't do anything if the edge is filtered
        // or if the canvas is animating        
        if (filtered || this.mapView.Visualize.mGraph.busy) return; 

        $('canvas').css('cursor', 'pointer');
        var edgeIsSelected = this.mapView.Selected.Edges.indexOf(edge);
        //following if statement only executes if the edge being hovered over is not selected
        if (edgeIsSelected == -1) {
            edge.setData('showDesc', true, 'current');
        }

        edge.setDataset('end', {
            lineWidth: 4
        });
        this.mapView.Visualize.mGraph.fx.animate({
            modes: ['edge-property:lineWidth'],
            duration: 100
        });
        this.mapView.Visualize.mGraph.plot();
    } // onMouseEnter
    
    jit.prototype.onMouseLeave = function (edge) {
        if (edge.getData('alpha') === 0) return; // don't do anything if the edge is filtered
        $('canvas').css('cursor', 'default');
        var edgeIsSelected = this.mapView.Selected.Edges.indexOf(edge);
        //following if statement only executes if the edge being hovered over is not selected
        if (edgeIsSelected == -1) {
            edge.setData('showDesc', false, 'current');
        }

        edge.setDataset('end', {
            lineWidth: 2
        });
        this.mapView.Visualize.mGraph.fx.animate({
            modes: ['edge-property:lineWidth'],
            duration: 100
        });
        this.mapView.Visualize.mGraph.plot();
    } // onMouseLeave
    
    jit.prototype.onMouseMoveHandler = function (node, eventInfo, e) {

        var self = this;

        if (this.mapView.Visualize.mGraph.busy) return;

        var node = eventInfo.getNode();
        var edge = eventInfo.getEdge();

        //if we're on top of a node object, act like there aren't edges under it
        if (node != false) {
            if (this.mapView.Mouse.edgeHoveringOver) {
                self.onMouseLeave(this.mapView.Mouse.edgeHoveringOver);
            }
            $('canvas').css('cursor', 'pointer');
            return;
        }

        if (edge == false && this.mapView.Mouse.edgeHoveringOver != false) {
            //mouse not on an edge, but we were on an edge previously
            self.onMouseLeave(this.mapView.Mouse.edgeHoveringOver);
        } else if (edge != false && this.mapView.Mouse.edgeHoveringOver == false) {
            //mouse is on an edge, but there isn't a stored edge
            self.onMouseEnter(edge);
        } else if (edge != false && this.mapView.Mouse.edgeHoveringOver != edge) {
            //mouse is on an edge, but a different edge is stored
            self.onMouseLeave(this.mapView.Mouse.edgeHoveringOver)
            self.onMouseEnter(edge);
        }

        //could be false
        this.mapView.Mouse.edgeHoveringOver = edge;

        if (!node && !edge) {
            $('canvas').css('cursor', 'default');
        }
    } // onMouseMoveHandler

    jit.prototype.enterKeyHandler = function () {
        /*var creatingMap = this.mapView.GlobalUI.lightbox;
        if (creatingMap === "newmap" || creatingMap === "forkmap") {
            this.mapView.GlobalUI.CreateMap.submit();
        }
        // this is to submit new topic creation
        else if (this.mapView.Create.newTopic.beingCreated) {
            this.mapView.Topic.createTopicLocally();
        }
        // to submit new synapse creation 
        else if (this.mapView.Create.newSynapse.beingCreated) {
            this.mapView.Synapse.createSynapseLocally();
        }*/
    } //enterKeyHandler
    
    jit.prototype.escKeyHandler = function () {
        this.mapView.Control.deselectAllEdges();
        this.mapView.Control.deselectAllNodes();
    } //escKeyHandler

    jit.prototype.touchPanZoomHandler = function (eventInfo, e) {
        if (e.touches.length == 1) {
            var thispos = this.mapView.Touch.touchPos,
                currentPos = eventInfo.getPos(),
                canvas = this.mapView.Visualize.mGraph.canvas,
                ox = canvas.translateOffsetX,
                oy = canvas.translateOffsetY,
                sx = canvas.scaleOffsetX,
                sy = canvas.scaleOffsetY;
            currentPos.x *= sx;
            currentPos.y *= sy;
            currentPos.x += ox;
            currentPos.y += oy;
            //var x = currentPos.x - thispos.x,
            //    y = currentPos.y - thispos.y;
            var x = currentPos.x - thispos.x,
                y = currentPos.y - thispos.y;
            this.mapView.Touch.touchPos = currentPos;
            this.mapView.Visualize.mGraph.canvas.translate(x * 1 / sx, y * 1 / sy);
        } else if (e.touches.length == 2) {
            var touch1 = e.touches[0];
            var touch2 = e.touches[1];

            var dist = this.mapView.Util.getDistance({
                x: touch1.clientX,
                y: touch1.clientY
            }, {
                x: touch2.clientX,
                y: touch2.clientY
            });

            if (!lastDist) {
                lastDist = dist;
            }

            var scale = dist / lastDist;

            if (8 >= this.mapView.Visualize.mGraph.canvas.scaleOffsetX * scale && this.mapView.Visualize.mGraph.canvas.scaleOffsetX * scale >= 1) {
                this.mapView.Visualize.mGraph.canvas.scale(scale, scale);
            }
            if (this.mapView.Visualize.mGraph.canvas.scaleOffsetX < 0.5) {
                this.mapView.Visualize.mGraph.canvas.viz.labels.hideLabels(true);
            } else if (this.mapView.Visualize.mGraph.canvas.scaleOffsetX > 0.5) {
                this.mapView.Visualize.mGraph.canvas.viz.labels.hideLabels(false);
            }
            lastDist = dist;
        }

    } // touchPanZoomHandler

    jit.prototype.onDragMoveTopicHandler = function (node, eventInfo, e) {

        var self = this;

        // this is used to send nodes that are moving to 
        // other realtime collaborators on the same map
        var positionsToSend = {};
        var topic;

        var authorized = this.mapView.Active.Map && this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        if (node && !node.nodeFrom) {
            var pos = eventInfo.getPos();
            // if it's a left click, or a touch, move the node
            if (e.touches || (e.button == 0 && !e.altKey && !e.ctrlKey && !e.shiftKey && (e.buttons == 0 || e.buttons == 1 || e.buttons == undefined))) {
                //if the node dragged isn't already selected, select it
                var whatToDo = self.handleSelectionBeforeDragging(node, e);
                if (node.pos.rho || node.pos.rho === 0) {
                    // this means we're in topic view
                    var rho = Math.sqrt(pos.x * pos.x + pos.y * pos.y);
                    var theta = Math.atan2(pos.y, pos.x);
                    node.pos.setp(theta, rho);
                } else if (whatToDo == 'only-drag-this-one') {
                    node.pos.setc(pos.x, pos.y);

                    if (this.mapView.Active.Map) {
                        topic = node.getData('topic');
                        // we use the topic ID not the node id
                        // because we can't depend on the node id
                        // to be the same as on other collaborators
                        // maps
                        positionsToSend[topic.id] = pos;
                        $(document).trigger(this.events.topicDrag, [positionsToSend]);
                    }
                } else {
                    var len = this.mapView.Selected.Nodes.length;

                    //first define offset for each node
                    var xOffset = new Array();
                    var yOffset = new Array();
                    for (var i = 0; i < len; i += 1) {
                        var n = this.mapView.Selected.Nodes[i];
                        xOffset[i] = n.pos.x - node.pos.x;
                        yOffset[i] = n.pos.y - node.pos.y;
                    } //for

                    for (var i = 0; i < len; i += 1) {
                        var n = this.mapView.Selected.Nodes[i];
                        var x = pos.x + xOffset[i];
                        var y = pos.y + yOffset[i];
                        n.pos.setc(x, y);

                        if (this.mapView.Active.Map) {
                            topic = n.getData('topic');
                            // we use the topic ID not the node id
                            // because we can't depend on the node id
                            // to be the same as on other collaborators
                            // maps
                            positionsToSend[topic.id] = n.pos;
                        }
                    } //for

                    if (this.mapView.Active.Map) {
                        $(document).trigger(this.events.topicDrag, [positionsToSend]);
                    }
                } //if

                if (whatToDo == 'deselect') {
                    this.mapView.Control.deselectNode(node);
                }
                this.mapView.Visualize.mGraph.plot();
            }
            // if it's a right click or holding down alt, start synapse creation  ->third option is for firefox
            else if ((e.button == 2 || (e.button == 0 && e.altKey) || e.buttons == 2) && authorized) {
                if (tempInit == false) {
                    tempNode = node;
                    tempInit = true;

                    this.mapView.Create.newTopic.hide();
                    this.mapView.Create.newSynapse.hide();
                    // set the draw synapse start positions
                    var l = this.mapView.Selected.Nodes.length;
                    if (l > 0) {
                        for (var i = l - 1; i >= 0; i -= 1) {
                            var n = this.mapView.Selected.Nodes[i];
                            this.mapView.Mouse.synapseStartCoordinates.push({
                                x: n.pos.getc().x,
                                y: n.pos.getc().y
                            });
                        }
                    } else {
                        this.mapView.Mouse.synapseStartCoordinates = [{
                            x: tempNode.pos.getc().x,
                            y: tempNode.pos.getc().y
                        }];
                    }
                    this.mapView.Mouse.synapseEndCoordinates = {
                        x: pos.x,
                        y: pos.y
                    };
                }
                //
                temp = eventInfo.getNode();
                if (temp != false && temp.id != node.id && this.mapView.Selected.Nodes.indexOf(temp) == -1) { // this means a Node has been returned
                    tempNode2 = temp;
                    
                    this.mapView.Mouse.synapseEndCoordinates = {
                        x: tempNode2.pos.getc().x,
                        y: tempNode2.pos.getc().y
                    };

                    // before making the highlighted one bigger, make sure all the others are regular size
                    this.mapView.Visualize.mGraph.graph.eachNode(function (n) {
                        n.setData('dim', 25, 'current');
                    });
                    temp.setData('dim', 35, 'current');
                    this.mapView.Visualize.mGraph.plot();
                } else if (!temp) {
                    tempNode2 = null;
                    this.mapView.Visualize.mGraph.graph.eachNode(function (n) {
                        n.setData('dim', 25, 'current');
                    });
                    //pop up node creation :)
                    var myX = e.clientX - 110;
                    var myY = e.clientY - 30;
                    $('#new_topic').css('left', myX + "px");
                    $('#new_topic').css('top', myY + "px");
                    this.mapView.Create.newTopic.x = eventInfo.getPos().x;
                    this.mapView.Create.newTopic.y = eventInfo.getPos().y;
                    this.mapView.Visualize.mGraph.plot();

                    this.mapView.Mouse.synapseEndCoordinates = {
                        x: pos.x,
                        y: pos.y
                    };
                }
            }
            else if ((e.button == 2 || (e.button == 0 && e.altKey) || e.buttons == 2) && this.mapView.Active.Topic) {
                this.mapView.GlobalUI.notifyUser("Cannot create in Topic view.");
            }
            else if ((e.button == 2 || (e.button == 0 && e.altKey) || e.buttons == 2) && !authorized) {
                this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
            }
        }
    } // onDragMoveTopicHandler
    
    jit.prototype.onDragCancelHandler = function (node, eventInfo, e) {
        tempNode = null;
        if (tempNode2) tempNode2.setData('dim', 25, 'current');
        tempNode2 = null;
        tempInit = false;
        // reset the draw synapse positions to false
        this.mapView.Mouse.synapseStartCoordinates = [];
        this.mapView.Mouse.synapseEndCoordinates = null;
        this.mapView.Visualize.mGraph.plot();
    } // onDragCancelHandler
    
    jit.prototype.onDragEndTopicHandler = function (node, eventInfo, e) {
        var midpoint = {}, pixelPos, mapping;

        if (tempInit && tempNode2 == null) {
            // this means you want to add a new topic, and then a synapse
            this.mapView.Create.newTopic.addSynapse = true;
            this.mapView.Create.newTopic.open();
        } else if (tempInit && tempNode2 != null) {
            // this means you want to create a synapse between two existing topics
            this.mapView.Create.newTopic.addSynapse = false;
            this.mapView.Create.newSynapse.topic1id = tempNode.getData('topic').id;
            this.mapView.Create.newSynapse.topic2id = tempNode2.getData('topic').id;
            tempNode2.setData('dim', 25, 'current');
            this.mapView.Visualize.mGraph.plot();
            midpoint.x = tempNode.pos.getc().x + (tempNode2.pos.getc().x - tempNode.pos.getc().x) / 2;
            midpoint.y = tempNode.pos.getc().y + (tempNode2.pos.getc().y - tempNode.pos.getc().y) / 2;
            pixelPos = this.mapView.Util.coordsToPixels(midpoint);
            $('#new_synapse').css('left', pixelPos.x + "px");
            $('#new_synapse').css('top', pixelPos.y + "px");
            this.mapView.Create.newSynapse.open();
            tempNode = null;
            tempNode2 = null;
            tempInit = false;
        } else if (!tempInit && node && !node.nodeFrom) {
            // this means you dragged an existing node, autosave that to the database

            // check whether to save mappings
            var checkWhetherToSave = function() {
                var map = this.mapView.Active.Map;

                if (!map) return false;

                var mapper = this.mapView.Active.Mapper;
                // this case
                // covers when it is a public map owned by you
                // and also when it's a private map
                var activeMappersMap = map.authorizePermissionChange(mapper); 
                var commonsMap = map.get('permission') === 'commons';
                var realtimeOn = this.mapView.Realtime.status;

                // don't save if commons map, and you have realtime off, 
                // even if you're map creator
                return map && mapper && ((commonsMap && realtimeOn) || (activeMappersMap && !commonsMap));
            }

            if (checkWhetherToSave()) {
                mapping = node.getData('mapping');
                mapping.save({
                    xloc: node.getPos().x,
                    yloc: node.getPos().y
                });
                // also save any other selected nodes that also got dragged along
                var l = this.mapView.Selected.Nodes.length;
                for (var i = l - 1; i >= 0; i -= 1) {
                    var n = this.mapView.Selected.Nodes[i];
                    if (n !== node) {
                        mapping = n.getData('mapping');
                        mapping.save({
                            xloc: n.getPos().x,
                            yloc: n.getPos().y
                        });
                    }
                };
            }
        }
    } //onDragEndTopicHandler
   
    jit.prototype.canvasClickHandler = function (canvasLoc, e) {
        //grab the location and timestamp of the click 
        var storedTime = this.mapView.Mouse.lastCanvasClick;
        var now = Date.now(); //not compatible with IE8 FYI 
        this.mapView.Mouse.lastCanvasClick = now;

        var authorized = this.mapView.Active.Map && this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        if (now - storedTime < this.mapView.Mouse.DOUBLE_CLICK_TOLERANCE && !this.mapView.Mouse.didPan) {
            if (this.mapView.Active.Map && !authorized) {
                this.mapView.GlobalUI.notifyUser("Cannot edit Public map.");
                return;
            }
            else if (this.mapView.Active.Topic) {
                this.mapView.GlobalUI.notifyUser("Cannot create in Topic view.");
                return;
            }
            // DOUBLE CLICK
            //pop up node creation :) 
            this.mapView.Create.newTopic.addSynapse = false;
            this.mapView.Create.newTopic.x = canvasLoc.x;
            this.mapView.Create.newTopic.y = canvasLoc.y;
            $('#new_topic').css('left', e.clientX + "px");
            $('#new_topic').css('top', e.clientY + "px");
            this.mapView.Create.newTopic.open();
        } else if (!this.mapView.Mouse.didPan) {
            // SINGLE CLICK, no pan
            this.mapView.Filter.close();
            this.mapView.TopicCard.hideCard();
            this.mapView.SynapseCard.hideCard();
            this.mapView.Create.newTopic.hide();
            this.mapView.Create.newSynapse.hide();
            $('.rightclickmenu').remove();
            // reset the draw synapse positions to false
            this.mapView.Mouse.synapseStartCoordinates = [];
            this.mapView.Mouse.synapseEndCoordinates = null;
            tempInit = false;
            tempNode = null;
            tempNode2 = null;
            if (!e.ctrlKey && !e.shiftKey) {
                this.mapView.Control.deselectAllEdges();
                this.mapView.Control.deselectAllNodes();
            }
        }
    } //canvasClickHandler 
    
    jit.prototype.nodeDoubleClickHandler = function (node, e) {

        this.mapView.TopicCard.showCard(node);

    } // nodeDoubleClickHandler
    
    jit.prototype.edgeDoubleClickHandler = function (adj, e) {

        this.mapView.SynapseCard.showCard(adj, e);

    } // nodeDoubleClickHandler
    
    jit.prototype.nodeWasDoubleClicked = function () {
        //grab the timestamp of the click 
        var storedTime = this.mapView.Mouse.lastNodeClick;
        var now = Date.now(); //not compatible with IE8 FYI 
        this.mapView.Mouse.lastNodeClick = now;

        if (now - storedTime < this.mapView.Mouse.DOUBLE_CLICK_TOLERANCE) {
            return true;
        } else {
            return false;
        }
    } //nodeWasDoubleClicked;
    
    jit.prototype.handleSelectionBeforeDragging = function (node, e) {
        // four cases:
        // 1 nothing is selected, so pretend you aren't selecting
        // 2 others are selected only and shift, so additionally select this one
        // 3 others are selected only, no shift: drag only this one
        // 4 this node and others were selected, so drag them (just return false)
        //return value: deselect node again after?
        if (this.mapView.Selected.Nodes.length == 0) {
         return 'only-drag-this-one';
        }
        if (this.mapView.Selected.Nodes.indexOf(node) == -1) {
            if (e.shiftKey) {
                this.mapView.Control.selectNode(node,e);
                return 'nothing';
            } else {
                return 'only-drag-this-one';
            }
        }
        return 'nothing'; //case 4?
    } //  handleSelectionBeforeDragging
    
    jit.prototype.selectWithBox = function (e) {

        var sX = this.mapView.Mouse.boxStartCoordinates.x,
            sY = this.mapView.Mouse.boxStartCoordinates.y,
            eX = this.mapView.Mouse.boxEndCoordinates.x,
            eY = this.mapView.Mouse.boxEndCoordinates.y;
    
        if(!e.shiftKey){
          this.mapView.Control.deselectAllNodes();
          this.mapView.Control.deselectAllEdges();
        }

        //select all nodes that are within the box
        this.mapView.Visualize.mGraph.graph.eachNode(function (n) {
            var x = n.pos.x,
                y = n.pos.y;

            if ((sX < x && x < eX && sY < y && y < eY) || (sX > x && x > eX && sY > y && y > eY) || (sX > x && x > eX && sY < y && y < eY) || (sX < x && x < eX && sY > y && y > eY)) {
                if(e.shiftKey){
          if(n.selected){
            this.mapView.Control.deselectNode(n);
          }
          else{
            this.mapView.Control.selectNode(n,e);
          }
        }
        else{
          this.mapView.Control.selectNode(n,e);
        }
            }
        });

    //Convert selection box coordinates to traditional coordinates (+,+) in upper right
    sY = -1 * sY;
    eY = -1 * eY

        var edgesToToggle = [];
        this.mapView.Synapses.each(function(synapse) {
            var e = synapse.get('edge');
            if (edgesToToggle.indexOf(e) === -1) {
                edgesToToggle.push(e);
            }
        });
    edgesToToggle.forEach(function(edge) {
      var fromNodeX = edge.nodeFrom.pos.x;
      var fromNodeY = -1 * edge.nodeFrom.pos.y;
      var toNodeX = edge.nodeTo.pos.x;
      var toNodeY = -1 * edge.nodeTo.pos.y;

            var maxX = fromNodeX;
      var maxY = fromNodeY;
      var minX = fromNodeX;
      var minY = fromNodeY;
      
      //Correct maxX, MaxY values
      (toNodeX > maxX) ? (maxX = toNodeX):(minX = toNodeX);
      (toNodeY > maxY) ? (maxY = toNodeY):(minY = toNodeY);
      
      var maxBoxX = sX;
      var maxBoxY = sY;
      var minBoxX = sX;
      var minBoxY = sY;
      
      //Correct maxBoxX, maxBoxY values
      (eX > maxBoxX) ? (maxBoxX = eX):(minBoxX = eX);
      (eY > maxBoxY) ? (maxBoxY = eY):(minBoxY = eY);
      
      //Find the slopes from the synapse fromNode to the 4 corners of the selection box
      var slopes = [];
      slopes.push( (sY - fromNodeY) / (sX - fromNodeX) );
      slopes.push( (sY - fromNodeY) / (eX - fromNodeX) );
      slopes.push( (eY - fromNodeY) / (eX - fromNodeX) );
      slopes.push( (eY - fromNodeY) / (sX - fromNodeX) );
      
      var minSlope = slopes[0];
      var maxSlope = slopes[0];
      slopes.forEach(function(entry){
        if(entry > maxSlope) maxSlope = entry;
        if(entry < minSlope) minSlope = entry;          
      });
      
      //Find synapse-in-question's slope
      var synSlope = (toNodeY - fromNodeY) / (toNodeX - fromNodeX);
      var b = fromNodeY - synSlope * fromNodeX;

            //Use the selection box edges as test cases for synapse intersection
      var testX = sX;
      var testY = synSlope * testX + b;

            var selectTest;
      
      if(testX >= minX && testX <= maxX && testY >= minY && testY <= maxY && testY >= minBoxY && testY <= maxBoxY){
        selectTest = true;
      }
      
      testX = eX;
      testY = synSlope * testX + b;
      
      if(testX >= minX && testX <= maxX && testY >= minY && testY <= maxY && testY >= minBoxY && testY <= maxBoxY){
        selectTest = true;
      }
      
      testY = sY;
      testX = (testY - b)/synSlope;
      
      if(testX >= minX && testX <= maxX && testY >= minY && testY <= maxY && testX >= minBoxX && testX <= maxBoxX){
        selectTest = true;
      }
      
      testY = eY;
      testX = (testY - b)/synSlope;
      
      if(testX >= minX && testX <= maxX && testY >= minY && testY <= maxY && testX >= minBoxX && testX <= maxBoxX){
        selectTest = true;
      }

            //Case where the synapse is wholly enclosed in the seldction box
            if(fromNodeX >= minBoxX && fromNodeX <= maxBoxX && fromNodeY >= minBoxY && fromNodeY <= maxBoxY && toNodeX >= minBoxX && toNodeX <= maxBoxX && toNodeY >= minBoxY && toNodeY <= maxBoxY){
                selectTest = true;
            }     
      
            //The test synapse was selected!

            if(selectTest){
                // shiftKey = toggleSelect, otherwise 
        if(e.shiftKey){
          if(this.mapView.Selected.Edges.indexOf(edge) != -1 ){
            this.mapView.Control.deselectEdge(edge);
          }
          else{
            this.mapView.Control.selectEdge(edge);
          }
        }
        else{
          this.mapView.Control.selectEdge(edge);
        }
      }
    });
        this.mapView.Mouse.boxStartCoordinates = false;
        this.mapView.Mouse.boxEndCoordinates = false;
        this.mapView.Visualize.mGraph.plot();
    } // selectWithBox
    
    jit.prototype.drawSelectBox = function (eventInfo, e) {
        var ctx = this.mapView.Visualize.mGraph.canvas.getCtx();

        var startX = this.mapView.Mouse.boxStartCoordinates.x,
            startY = this.mapView.Mouse.boxStartCoordinates.y,
            currX = eventInfo.getPos().x,
            currY = eventInfo.getPos().y;

        this.mapView.Visualize.mGraph.canvas.clear();
        this.mapView.Visualize.mGraph.plot();

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(startX, currY);
        ctx.lineTo(currX, currY);
        ctx.lineTo(currX, startY);
        ctx.lineTo(startX, startY);
        ctx.strokeStyle = "black";
        ctx.stroke();
    } // drawSelectBox
    
    jit.prototype.selectNodeOnClickHandler = function (node, e) {
        if (this.mapView.Visualize.mGraph.busy) return;

        var self = this;

        // catch right click on mac, which is often like ctrl+click
        if (navigator.platform.indexOf("Mac") != -1 && e.ctrlKey) {
            self.selectNodeOnRightClickHandler(node, e)
            return;
        }

        // if on a topic page, let alt+click center you on a new topic
        if (this.mapView.Active.Topic && e.altKey) {
            this.mapView.RGraph.centerOn(node.id);
            return;
        }

        var check = self.nodeWasDoubleClicked();
        if (check) {
            self.nodeDoubleClickHandler(node, e);
            return;
        } else {
            // wait a certain length of time, then check again, then run this code
            setTimeout(function () {
                if (!this.nodeWasDoubleClicked()) {

                    var nodeAlreadySelected = node.selected;

                    if (!e.shiftKey) {
                        this.mapView.Control.deselectAllNodes();
                        this.mapView.Control.deselectAllEdges();
                    }
                    
                    if (nodeAlreadySelected) {
                        this.mapView.Control.deselectNode(node);
                    } else {
                        this.mapView.Control.selectNode(node,e);
                    }
                    
                    //trigger animation to final styles
                    this.mapView.Visualize.mGraph.fx.animate({
                        modes: ['edge-property:lineWidth:color:alpha'],
                        duration: 500
                    });
                    this.mapView.Visualize.mGraph.plot();
                }
            }, this.mapView.Mouse.DOUBLE_CLICK_TOLERANCE);
        }
    } //selectNodeOnClickHandler
    
    jit.prototype.selectNodeOnRightClickHandler = function (node, e) {
        // the 'node' variable is a JIT node, the one that was clicked on
        // the 'e' variable is the click event

        e.preventDefault();
        e.stopPropagation();

        if (this.mapView.Visualize.mGraph.busy) return;

        // select the node
        this.mapView.Control.selectNode(node, e);

        // delete old right click menu
        $('.rightclickmenu').remove();
        // create new menu for clicked on node
        var rightclickmenu = document.createElement("div");
        rightclickmenu.className = "rightclickmenu";
        // add the proper options to the menu
        var menustring = '<ul>';

        var authorized = this.mapView.Active.Map && this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        var disabled = authorized ? "" : "disabled";

        if (this.mapView.Active.Map) menustring += '<li class="rc-hide"><div class="rc-icon"></div>Hide until refresh<div class="rc-keyboard">Ctrl+H</div></li>';
        if (this.mapView.Active.Map && this.mapView.Active.Mapper) menustring += '<li class="rc-remove ' + disabled + '"><div class="rc-icon"></div>Remove from map<div class="rc-keyboard">Ctrl+M</div></li>';
        if (this.mapView.Active.Map && this.mapView.Active.Mapper) menustring += '<li class="rc-delete ' + disabled + '"><div class="rc-icon"></div>Delete<div class="rc-keyboard">Ctrl+D</div></li>';
        

        if (this.mapView.Active.Topic) {
            menustring += '<li class="rc-center"><div class="rc-icon"></div>Center this topic</li>';
        }
        menustring += '<li class="rc-popout"><div class="rc-icon"></div>Open in new tab</li>';
        if (this.mapView.Active.Mapper) {
            var options = '<ul><li class="changeP toCommons"><div class="rc-perm-icon"></div>commons</li> \
                         <li class="changeP toPublic"><div class="rc-perm-icon"></div>public</li> \
                         <li class="changeP toPrivate"><div class="rc-perm-icon"></div>private</li> \
                     </ul>';

            menustring += '<li class="rc-spacer"></li>';

            menustring += '<li class="rc-permission"><div class="rc-icon"></div>Change permissions' + options + '<div class="expandLi"></div></li>';

            var metacodeOptions = $('#metacodeOptions').html();

            menustring += '<li class="rc-metacode"><div class="rc-icon"></div>Change metacode' + metacodeOptions + '<div class="expandLi"></div></li>';
        }
        if (this.mapView.Active.Topic) {

            if (!this.mapView.Active.Mapper) {
                menustring += '<li class="rc-spacer"></li>';
            }

            // set up the get sibling menu as a "lazy load"
            // only fill in the submenu when they hover over the get siblings list item
            var siblingMenu = '<ul id="fetchSiblingList"> \
                                <li class="fetchAll">All</li> \
                                <li id="loadingSiblings"></li> \
                            </ul>';
            menustring += '<li class="rc-siblings"><div class="rc-icon"></div>Get siblings' + siblingMenu + '<div class="expandLi"></div></li>';
        }

        menustring += '</ul>';
        rightclickmenu.innerHTML = menustring;

        // position the menu where the click happened
        var position = {};
        var RIGHTCLICK_WIDTH = 300;
        var RIGHTCLICK_HEIGHT = 144; // this does vary somewhat, but we can use static
        var SUBMENUS_WIDTH = 256;
        var MAX_SUBMENU_HEIGHT = 270;
        var windowWidth = $(window).width();
        var windowHeight = $(window).height();

        if (windowWidth - e.clientX < SUBMENUS_WIDTH) {
            position.right = windowWidth - e.clientX;  
            $(rightclickmenu).addClass('moveMenusToLeft');
        }
        else if (windowWidth - e.clientX < RIGHTCLICK_WIDTH) {
            position.right = windowWidth - e.clientX;
        }
        else if (windowWidth - e.clientX < RIGHTCLICK_WIDTH + SUBMENUS_WIDTH) {
            position.left = e.clientX; 
            $(rightclickmenu).addClass('moveMenusToLeft');
        }
        else position.left = e.clientX;

        if (windowHeight - e.clientY < MAX_SUBMENU_HEIGHT) {
            position.bottom = windowHeight - e.clientY;
            $(rightclickmenu).addClass('moveMenusUp');
        }
        else if (windowHeight - e.clientY < RIGHTCLICK_HEIGHT + MAX_SUBMENU_HEIGHT) {
            position.top = e.clientY;
            $(rightclickmenu).addClass('moveMenusUp');
        }
        else position.top = e.clientY;

        $(rightclickmenu).css(position);
        //add the menu to the page
        $('#wrapper').append(rightclickmenu);

        // attach events to clicks on the list items

        // delete the selected things from the database
        if (authorized) {
            $('.rc-delete').click(function () {
                $('.rightclickmenu').remove();
                this.mapView.Control.deleteSelected();
            });
        }

        // remove the selected things from the map
        if (authorized) {
            $('.rc-remove').click(function () {
                $('.rightclickmenu').remove();
                this.mapView.Control.removeSelectedEdges();
                this.mapView.Control.removeSelectedNodes();
            });
        }

        // hide selected nodes and synapses until refresh
        $('.rc-hide').click(function () {
            $('.rightclickmenu').remove();
            this.mapView.Control.hideSelectedEdges();
            this.mapView.Control.hideSelectedNodes();
        }); 

        // when in radial, center on the topic you picked
        $('.rc-center').click(function () {
            $('.rightclickmenu').remove();
            this.mapView.Topic.centerOn(node.id);
        });

        // open the entity in a new tab
        $('.rc-popout').click(function () {
            $('.rightclickmenu').remove();
            var win = window.open('/topics/' + node.id, '_blank');
            win.focus();
        });

        // change the permission of all the selected nodes and synapses that you were the originator of
        $('.rc-permission li').click(function () {
            $('.rightclickmenu').remove();
            // $(this).text() will be 'commons' 'public' or 'private'
            this.mapView.Control.updateSelectedPermissions($(this).text());
        });

        // change the metacode of all the selected nodes that you have edit permission for
        $('.rc-metacode li li').click(function () {
            $('.rightclickmenu').remove();
            //
            this.mapView.Control.updateSelectedMetacodes($(this).attr('data-id'));
        });


        // fetch relatives
        var fetched = false;
        $('.rc-siblings').hover(function () {
            if (!fetched) {
                this.populateRightClickSiblings(node);
                fetched = true;
            }
        });
        $('.rc-siblings .fetchAll').click(function () {
            $('.rightclickmenu').remove();
            // data-id is a metacode id
            this.mapView.Topic.fetchRelatives(node);
        });
    } //selectNodeOnRightClickHandler,
    
    jit.prototype.populateRightClickSiblings = function(node) {
        var self = this;

        // depending on how many topics are selected, do different things
        /*if (this.mapView.Selected.Nodes.length > 1) {
            // we don't bother filling the submenu with 
            // specific numbers, because there are too many topics
            // selected to find those numbers
            $('#loadingSiblings').remove();
            return;
        }*/

        var topic = node.getData('topic');

        // add a loading icon for now
        var loader = new CanvasLoader('loadingSiblings');
        loader.setColor('#4FC059'); // default is '#000000'
        loader.setDiameter(15); // default is 40
        loader.setDensity(41); // default is 40
        loader.setRange(0.9); // default is 1.3
        loader.show(); // Hidden by default

        var topics = this.mapView.Topics.map(function(t){ return t.id });
        var topics_string = topics.join();

        var successCallback = function(data) {
            $('#loadingSiblings').remove();

            for (var key in data) {
                var string = this.mapView.Metacodes.get(key).get('name') + ' (' + data[key] + ')';
                $('#fetchSiblingList').append('<li class="getSiblings" data-id="' + key + '">' + string + '</li>');
            }

            $('.rc-siblings .getSiblings').click(function () {
                $('.rightclickmenu').remove();
                // data-id is a metacode id
                this.mapView.Topic.fetchRelatives(node, $(this).attr('data-id'));
            });
        };

        $.ajax({
            type: "Get",
            url: "/topics/" + topic.id + "/relative_numbers.json?network=" + topics_string,
            success: successCallback,
            error: function () {
                
            }
        });
    }

    jit.prototype.selectEdgeOnClickHandler = function (adj, e) {
        if (this.mapView.Visualize.mGraph.busy) return;

        var self = this;

        // catch right click on mac, which is often like ctrl+click
        if (navigator.platform.indexOf("Mac") != -1 && e.ctrlKey) {
            self.selectEdgeOnRightClickHandler(adj, e)
            return;
        }

        var check = self.nodeWasDoubleClicked();
        if (check) {
            self.edgeDoubleClickHandler(adj, e);
            return;
        } else {
            // wait a certain length of time, then check again, then run this code
            setTimeout(function () {
                if (!this.nodeWasDoubleClicked()) {

                    var edgeAlreadySelected = this.mapView.Selected.Edges.indexOf(adj) !== -1;

                    if (!e.shiftKey) {
                        this.mapView.Control.deselectAllNodes();
                        this.mapView.Control.deselectAllEdges();
                    }

                    if (edgeAlreadySelected) {
                        this.mapView.Control.deselectEdge(adj);
                    } else {
                        this.mapView.Control.selectEdge(adj);
                    }

                    this.mapView.Visualize.mGraph.plot();
                }
            }, this.mapView.Mouse.DOUBLE_CLICK_TOLERANCE);
        }
    } //selectEdgeOnClickHandler

    jit.prototype.selectEdgeOnRightClickHandler = function (adj, e) {
        // the 'node' variable is a JIT node, the one that was clicked on
        // the 'e' variable is the click event

        if (adj.getData('alpha') === 0) return; // don't do anything if the edge is filtered

        var authorized;

        e.preventDefault();
        e.stopPropagation();

        if (this.mapView.Visualize.mGraph.busy) return;

        this.mapView.Control.selectEdge(adj);

        // delete old right click menu
        $('.rightclickmenu').remove();
        // create new menu for clicked on node
        var rightclickmenu = document.createElement("div");
        rightclickmenu.className = "rightclickmenu";

        // add the proper options to the menu
        var menustring = '<ul>';

        var authorized = this.mapView.Active.Map && this.mapView.Active.Map.authorizeToEdit(this.mapView.Active.Mapper);

        var disabled = authorized ? "" : "disabled";

        if (this.mapView.Active.Map) menustring += '<li class="rc-hide"><div class="rc-icon"></div>Hide until refresh<div class="rc-keyboard">Ctrl+H</div></li>';
        if (this.mapView.Active.Map && this.mapView.Active.Mapper) menustring += '<li class="rc-remove ' + disabled + '"><div class="rc-icon"></div>Remove from map<div class="rc-keyboard">Ctrl+M</div></li>';
        if (this.mapView.Active.Map && this.mapView.Active.Mapper) menustring += '<li class="rc-delete ' + disabled + '"><div class="rc-icon"></div>Delete<div class="rc-keyboard">Ctrl+D</div></li>';

        if (this.mapView.Active.Map && this.mapView.Active.Mapper) menustring += '<li class="rc-spacer"></li>';

        if (this.mapView.Active.Mapper) {
            var permOptions = '<ul><li class="changeP toCommons"><div class="rc-perm-icon"></div>commons</li> \
                         <li class="changeP toPublic"><div class="rc-perm-icon"></div>public</li> \
                         <li class="changeP toPrivate"><div class="rc-perm-icon"></div>private</li> \
                     </ul>';

            menustring += '<li class="rc-permission"><div class="rc-icon"></div>Change permissions' + permOptions + '<div class="expandLi"></div></li>';
        }

        menustring += '</ul>';
        rightclickmenu.innerHTML = menustring;

        // position the menu where the click happened
        var position = {};
        var RIGHTCLICK_WIDTH = 300;
        var RIGHTCLICK_HEIGHT = 144; // this does vary somewhat, but we can use static
        var SUBMENUS_WIDTH = 256;
        var MAX_SUBMENU_HEIGHT = 270;
        var windowWidth = $(window).width();
        var windowHeight = $(window).height();

        if (windowWidth - e.clientX < SUBMENUS_WIDTH) {
            position.right = windowWidth - e.clientX;  
            $(rightclickmenu).addClass('moveMenusToLeft');
        }
        else if (windowWidth - e.clientX < RIGHTCLICK_WIDTH) {
            position.right = windowWidth - e.clientX;
        }
        else position.left = e.clientX;

        if (windowHeight - e.clientY < MAX_SUBMENU_HEIGHT) {
            position.bottom = windowHeight - e.clientY;
            $(rightclickmenu).addClass('moveMenusUp');
        }
        else if (windowHeight - e.clientY < RIGHTCLICK_HEIGHT + MAX_SUBMENU_HEIGHT) {
            position.top = e.clientY;
            $(rightclickmenu).addClass('moveMenusUp');
        }
        else position.top = e.clientY;

        $(rightclickmenu).css(position);

        //add the menu to the page
        $('#wrapper').append(rightclickmenu);


        // attach events to clicks on the list items

        // delete the selected things from the database
        if (authorized) {
            $('.rc-delete').click(function () {
                $('.rightclickmenu').remove();
                this.mapView.Control.deleteSelected();
            });
        }

        // remove the selected things from the map
        if (authorized) {
            $('.rc-remove').click(function () {
                $('.rightclickmenu').remove();
                this.mapView.Control.removeSelectedEdges();
                this.mapView.Control.removeSelectedNodes();
            });
        }

        // hide selected nodes and synapses until refresh
        $('.rc-hide').click(function () {
            $('.rightclickmenu').remove();
            this.mapView.Control.hideSelectedEdges();
            this.mapView.Control.hideSelectedNodes();
        });

        // change the permission of all the selected nodes and synapses that you were the originator of
        $('.rc-permission li').click(function () {
            $('.rightclickmenu').remove();
            // $(this).text() will be 'commons' 'public' or 'private'
            this.mapView.Control.updateSelectedPermissions($(this).text());
        });

    } //selectEdgeOnRightClickHandler

    jit.prototype.SmoothPanning = function () {

        var sx = this.mapView.Visualize.mGraph.canvas.scaleOffsetX,
            sy = this.mapView.Visualize.mGraph.canvas.scaleOffsetY,
            y_velocity = this.mapView.Mouse.changeInY, // initial y velocity
            x_velocity = this.mapView.Mouse.changeInX, // initial x velocity
            easing = 1; // frictional value

        easing = 1;
        window.clearInterval(panningInt)
        panningInt = setInterval(function () {
            myTimer()
        }, 1);

        function myTimer() {
            this.mapView.Visualize.mGraph.canvas.translate(x_velocity * easing * 1 / sx, y_velocity * easing * 1 / sy);
            $(document).trigger(this.events.pan);
            easing = easing * 0.75;

            if (easing < 0.1) window.clearInterval(panningInt);
        }
    } // SmoothPanning

    jit.prototype.renderMidArrow = function (from, to, dim, swap, canvas, placement, newSynapse) {
        var ctx = canvas.getCtx();
        // invert edge direction 
        if (swap) {
            var tmp = from;
            from = to;
            to = tmp;
        }
        // vect represents a line from tip to tail of the arrow 
        var vect = new $jit.Complex(to.x - from.x, to.y - from.y);
        // scale it 
        vect.$scale(dim / vect.norm());
        // compute the midpoint of the edge line 
        var newX = (to.x - from.x) * placement + from.x;
        var newY = (to.y - from.y) * placement + from.y;
        var midPoint = new $jit.Complex(newX, newY);

        // move midpoint by half the "length" of the arrow so the arrow is centered on the midpoint 
        var arrowPoint = new $jit.Complex((vect.x / 0.7) + midPoint.x, (vect.y / 0.7) + midPoint.y);
        // compute the tail intersection point with the edge line 
        var intermediatePoint = new $jit.Complex(arrowPoint.x - vect.x, arrowPoint.y - vect.y);
        // vector perpendicular to vect 
        var normal = new $jit.Complex(-vect.y / 2, vect.x / 2);
        var v1 = intermediatePoint.add(normal);
        var v2 = intermediatePoint.$add(normal.$scale(-1));

        if (newSynapse) {
            ctx.strokeStyle = "#4fc059";
            ctx.lineWidth = 2;
            ctx.globalAlpha = 1;
        }
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(v1.x, v1.y);
        ctx.lineTo(arrowPoint.x, arrowPoint.y);
        ctx.lineTo(v2.x, v2.y);
        ctx.stroke();
    } // renderMidArrow
    
    jit.prototype.renderEdgeArrows = function (edgeHelper, adj, synapse, canvas) {

        var self = this;

        var directionCat = synapse.get('category');
        var direction = synapse.getDirection();

        var pos = adj.nodeFrom.pos.getc(true);
        var posChild = adj.nodeTo.pos.getc(true);

        //plot arrow edge 
        if (directionCat == "none") {
            edgeHelper.line.render({
                x: pos.x,
                y: pos.y
            }, {
                x: posChild.x,
                y: posChild.y
            }, canvas);
        } else if (directionCat == "both") {
            self.renderMidArrow({
                x: pos.x,
                y: pos.y
            }, {
                x: posChild.x,
                y: posChild.y
            }, 13, true, canvas, 0.7);
            self.renderMidArrow({
                x: pos.x,
                y: pos.y
            }, {
                x: posChild.x,
                y: posChild.y
            }, 13, false, canvas, 0.7);
        } else if (directionCat == "from-to") {
            var inv = (direction[0] != adj.nodeFrom.id);
            self.renderMidArrow({
                x: pos.x,
                y: pos.y
            }, {
                x: posChild.x,
                y: posChild.y
            }, 13, inv, canvas, 0.7);
            self.renderMidArrow({
                x: pos.x,
                y: pos.y
            }, {
                x: posChild.x,
                y: posChild.y
            }, 13, inv, canvas, 0.3);
        }
    } //renderEdgeArrows
    
    jit.prototype.zoomIn = function (event) {
        this.mapView.Visualize.mGraph.canvas.scale(1.25,1.25);
        $(document).trigger(this.events.zoom, [event]);
    }

    jit.prototype.zoomOut = function (event) {
        this.mapView.Visualize.mGraph.canvas.scale(0.8,0.8);
        $(document).trigger(this.events.zoom, [event]);
    }

    jit.prototype.centerMap = function (canvas) {
        var offsetScale = canvas.scaleOffsetX;
                
        canvas.scale(1/offsetScale,1/offsetScale);

        var offsetX = canvas.translateOffsetX;
        var offsetY = canvas.translateOffsetY;

        canvas.translate(-1*offsetX,-1*offsetY);
    }

    jit.prototype.zoomToBox = function (event) {
        var sX = this.mapView.Mouse.boxStartCoordinates.x,
            sY = this.mapView.Mouse.boxStartCoordinates.y,
            eX = this.mapView.Mouse.boxEndCoordinates.x,
            eY = this.mapView.Mouse.boxEndCoordinates.y;

        var canvas = this.mapView.Visualize.mGraph.canvas;
        this.centerMap(canvas);

        var height = $(document).height(),
            width = $(document).width();

        var spanX = Math.abs(sX - eX);
        var spanY = Math.abs(sY - eY);
        var ratioX = width / spanX;
        var ratioY = height / spanY;

        var newRatio = Math.min(ratioX,ratioY);

        if(canvas.scaleOffsetX *newRatio<= 5 && canvas.scaleOffsetX*newRatio >= 0.2){
            canvas.scale(newRatio,newRatio);
        }
        else if(canvas.scaleOffsetX * newRatio > 5){
            newRatio = 5/ canvas.scaleOffsetX;
            canvas.scale(newRatio,newRatio);
        }
        else{
            newRatio = 0.2/ canvas.scaleOffsetX;
            canvas.scale(newRatio,newRatio);
        } 

        var cogX = (sX + eX)/2;
        var cogY = (sY + eY)/2;

        canvas.translate(-1* cogX, -1* cogY);
        $(document).trigger(this.events.zoom, [event]); 

        this.mapView.Mouse.boxStartCoordinates = false;
        this.mapView.Mouse.boxEndCoordinates = false;
        this.mapView.Visualize.mGraph.plot();
        
    }

    jit.prototype.zoomExtents = function (event, canvas, denySelected) {
        this.centerMap(canvas);
        var height = canvas.getSize().height,
            width = canvas.getSize().width,
            maxX, minX, maxY, minY, counter = 0;

        
        if (!denySelected && this.mapView.Selected.Nodes.length > 0) {
            var nodes = this.mapView.Selected.Nodes;
        }
        else {
            var nodes = _.values(this.mapView.Visualize.mGraph.graph.nodes);
        }

        if(nodes.length > 1){
            nodes.forEach(function (n) {
                var x = n.pos.x,
                    y = n.pos.y;

                if (counter == 0 && n.getData('alpha') == 1){
                    maxX = x;
                    minX = x; 
                    maxY = y;
                    minY = y; 
                }

                var arrayOfLabelLines = this.mapView.Util.splitLine(n.name, 30).split('\n'),
                    dim = n.getData('dim'),
                    ctx = canvas.getCtx();

                var height = 25 * arrayOfLabelLines.length;

                var index, lineWidths = [];
                for (index = 0; index < arrayOfLabelLines.length; ++index) {
                    lineWidths.push(ctx.measureText(arrayOfLabelLines[index]).width)
                }
                var width = Math.max.apply(null, lineWidths) + 8;

                // only adjust these values if the node is not filtered
                if (n.getData('alpha') == 1) {
                    maxX = Math.max(x + width /2,maxX);
                    maxY = Math.max(y + n.getData("height") + 5 + height,maxY);
                    minX = Math.min(x - width /2,minX);
                    minY = Math.min(y - dim,minY);

                    counter++;
                }
            });

            var spanX = maxX - minX;
            var spanY = maxY - minY;
            var ratioX = spanX / width;
            var ratioY = spanY / height;

            var cogX = (maxX + minX)/2;
            var cogY = (maxY + minY)/2;

            canvas.translate(-1* cogX, -1* cogY);

            var newRatio = Math.max(ratioX,ratioY);
            var scaleMultiplier = 1/newRatio*0.9;

            if(canvas.scaleOffsetX *scaleMultiplier<= 3 && canvas.scaleOffsetX*scaleMultiplier >= 0.2){
                canvas.scale(scaleMultiplier,scaleMultiplier);
            }
            else if(canvas.scaleOffsetX * scaleMultiplier > 3){
                scaleMultiplier = 3/ canvas.scaleOffsetX;
                canvas.scale(scaleMultiplier,scaleMultiplier);
            }
            else{
                scaleMultiplier = 0.2/ canvas.scaleOffsetX;
                canvas.scale(scaleMultiplier,scaleMultiplier);
            }
            
            $(document).trigger(this.events.zoom, [event]);
        }
        else if(nodes.length == 1){
            nodes.forEach(function (n) {
                var x = n.pos.x,
                    y = n.pos.y;

                canvas.translate(-1* x, -1* y);
                $(document).trigger(this.events.zoom, [event]); 
            });
        }
    }

    return jit;

}(jQuery));

/*
 * @static
 */
Mapmaker.JIT.events = {
    topicDrag: 'this.mapView:JIT:events:topicDrag', 
    newTopic: 'this.mapView:JIT:events:newTopic', 
    deleteTopic: 'this.mapView:JIT:events:deleteTopic', 
    removeTopic: 'this.mapView:JIT:events:removeTopic', 
    newSynapse: 'this.mapView:JIT:events:newSynapse', 
    deleteSynapse: 'this.mapView:JIT:events:deleteSynapse', 
    removeSynapse: 'this.mapView:JIT:events:removeSynapse', 
    pan: 'this.mapView:JIT:events:pan',
    zoom: 'this.mapView:JIT:events:zoom',
    animationDone: 'this.mapView:JIT:events:animationDone',
};


if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.Realtime = (function ($) {

    var realtime = function (mapView) {
        this.mapView = mapView;

        this.$parent = mapView.$parent;

        this.$myVideo = $('<video id="video-wrapper"></video>');
        this.myVideo = new Mapmaker.VideoView(this.$myVideo[0], this.mapView, 'me', true);

        this.messages = this.mapView.currentMap.get('messages');
        var
          mapper = this.mapView.currentMapper;
        this.chat = new Mapmaker.ChatView(this.mapView, this.messages, mapper);

        this.webRtcUrl = 'http://localhost:5002';

        this.stringForLocalhost = 'http://localhost:5002';
        this.stringForMetamaps = 'http://metamaps.cc:5001';
        this.stringForHeroku = 'http://gentle-savannah-1303.herokuapp.com';
        this.socket = null;
        this.isOpen = false;
        this.changing = false;
        this.mappersOnMap = {};
        this.videos = {};
        this.status = true; // stores whether realtime is True/On or False/Off
    }

    realtime.prototype.init = function () {
        var self = this;

        var reenableRealtime = function () {
            self.reenableRealtime();
        };
        var turnOff = function () {
            self.turnOff();
        };
        $(".rtOn").click(reenableRealtime);
        $(".rtOff").click(turnOff);

        $('.sidebarCollaborateIcon').click(self.toggleBox);
        $('.sidebarCollaborateBox').click(function(event){ 
            event.stopPropagation();
        });
        $('body').click(self.close);

        var railsEnv = 'development';
        var whichToConnect = railsEnv === 'development' ? self.stringForLocalhost : self.stringForHeroku;
        self.socket = io.connect(whichToConnect);
        self.socket.on('connect', function () {
            self.startActiveMap();
        });

        this.initVideo();
    }

    realtime.prototype.initVideo = function () {
      var self = this;

      this.webrtc = new SimpleWebRTC({
          localVideoEl: this.$myVideo.attr('id'),
          remoteVideosEl: '',
          url: this.webRtcUrl,
          detectSpeakingEvents: true,
          autoAdjustMic: false,
          autoRequestMedia: true,
          localVideo: {
              autoplay: true,
              mirror: true,
              muted: true
          },
          media: {
            video: true,
            audio: true
          }
      });

      // we have to wait until it's ready
      this.webrtc.on('readyToCall', function () {
          // you can name it anything
          self.webrtc.joinRoom('map' + self.mapView.currentMap.id, function (err, roomDescription) {
            if (err) console.log(err);
            else console.log('we joined the room!');
          });
      });

      this.webrtc.createRoom('map' + self.mapView.currentMap.id, function (err, roomName) {
          if (err) console.log('room already created');
          else console.log('created room: ' + roomName);
      });

      this.webrtc.on('videoAdded', this.addVideo.bind(this));

      this.webrtc.on('videoRemoved', this.removeVideo.bind(this));
    }

    realtime.prototype.addVideo = function (video, peer) {

        var id = this.webrtc.getDomId(peer),
         v = this.videos[id] = new Mapmaker.VideoView(video, this.mapView, id);

        this.$parent.append(v.$container);

        // random position for now
        var top = Math.floor((Math.random() * (this.$parent.height() - 100)) + 1);
        var left = Math.floor((Math.random() * (this.$parent.width() - 100)) + 1);
        v.$container.css({
            top: top + 'px',
            left: left + 'px'
        });
    }

    realtime.prototype.removeVideo = function (video, peer) {
        var id = this.webrtc.getDomId(peer);
        this.videos[id].remove();
        delete this.videos[id];
    }

    realtime.prototype.toggleBox = function (event) {
        var self = this;

        if (self.isOpen) self.close();
        else self.open();

        event.stopPropagation();
    }

    realtime.prototype.open = function () {
        var self = this;

        this.mapView.GlobalUI.Account.close();
        this.mapView.Filter.close();
        $('.sidebarCollaborateIcon div').addClass('hide');

        if (!self.isOpen && !self.changing) {
            self.changing = true;
            $('.sidebarCollaborateBox').fadeIn(200, function () {
                self.changing = false;
                self.isOpen = true;
            });
        }
    }

    realtime.prototype.close = function () {
        var self = this;
        $(".sidebarCollaborateIcon div").removeClass('hide');
        if (!self.changing) {
            self.changing = true;
            $('.sidebarCollaborateBox').fadeOut(200, function () {
                self.changing = false;
                self.isOpen = false;
            });
        }
    }

    realtime.prototype.startActiveMap = function () {
        var self = this;

        if (this.mapView.currentMap && this.mapView.currentMapper) {
            var commonsMap = this.mapView.currentMap.get('permission') === 'commons';
            var publicMap = this.mapView.currentMap.get('permission') === 'public';

            if (commonsMap) {
                self.turnOn();
                self.setupSocket();
            }
            else if (publicMap) {
                self.attachMapListener();
            }
        }
    }

    realtime.prototype.endActiveMap = function () {
        var self = this;

        $(document).off('mousemove');
        self.socket.removeAllListeners();
        self.socket.emit('endMapperNotify');
        $(".collabCompass").remove();
        self.status = false;
    }

    realtime.prototype.reenableRealtime = function() {
        var confirmString = "The layout of your map has fallen out of sync with the saved copy. ";
        confirmString += "To save your changes without overwriting the map, hit 'Cancel' and ";
        confirmString += "then use 'Save to new map'. ";
        confirmString += "Do you want to discard your changes and enable realtime?";
        var c = confirm(confirmString);
        if (c) {
            this.mapView.Router.maps(this.mapView.currentMap.id);
        }
    }

    realtime.prototype.turnOn = function (notify) {
        var self = this;

        if (notify) self.sendRealtimeOn();
        $(".rtMapperSelf").removeClass('littleRtOff').addClass('littleRtOn');
        $('.rtOn').addClass('active');
        $('.rtOff').removeClass('active');
        self.status = true;
        $(".sidebarCollaborateIcon").addClass("blue");
        $(".collabCompass").show();
    }

    realtime.prototype.turnOff = function (silent) {
        var self = this;

        if (self.status) {
            if (!silent) self.sendRealtimeOff();
            $(".rtMapperSelf").removeClass('littleRtOn').addClass('littleRtOff');
            $('.rtOn').removeClass('active');
            $('.rtOff').addClass('active');
            self.status = false;
            $(".sidebarCollaborateIcon").removeClass("blue");
            $(".collabCompass").hide();
        }
    }

    realtime.prototype.setupSocket = function () {
        var self = this;
        var socket = this.socket;
        var myId = this.mapView.currentMapper.id;
        
        socket.emit('newMapperNotify', {
            userid: myId,
            username: this.mapView.currentMapper.get("name"),
            userimage: this.mapView.currentMapper.get("image"),
            mapid: this.mapView.currentMap.id
        });

        // if you're the 'new guy' update your list with who's already online
        socket.on(myId + '-' + this.mapView.currentMap.id + '-UpdateMapperList', self.updateMapperList.bind(self));

        // receive word that there's a new mapper on the map
        socket.on('maps-' + this.mapView.currentMap.id + '-newmapper', self.newPeerOnMap.bind(self));

        // receive word that a mapper left the map
        socket.on('maps-' + this.mapView.currentMap.id + '-lostmapper', self.lostPeerOnMap.bind(self));

        // receive word that there's a mapper turned on realtime
        socket.on('maps-' + this.mapView.currentMap.id + '-newrealtime', self.newCollaborator.bind(self));

        // receive word that there's a mapper turned on realtime
        socket.on('maps-' + this.mapView.currentMap.id + '-lostrealtime', self.lostCollaborator.bind(self));

        //
        socket.on('maps-' + this.mapView.currentMap.id + '-topicDrag', self.topicDrag.bind(self));

        //
        socket.on('maps-' + this.mapView.currentMap.id + '-newTopic', self.newTopic.bind(self));

        //
        socket.on('maps-' + this.mapView.currentMap.id + '-removeTopic', self.removeTopic.bind(self));

        //
        socket.on('maps-' + this.mapView.currentMap.id + '-newSynapse', self.newSynapse.bind(self));

        //
        socket.on('maps-' + this.mapView.currentMap.id + '-removeSynapse', self.removeSynapse.bind(self));

        // update mapper compass position
        socket.on('maps-' + this.mapView.currentMap.id + '-updatePeerCoords', self.updatePeerCoords.bind(self));

        socket.on('maps-' + this.mapView.currentMap.id + '-chatMessage', function (data) {
            self.messages.add(data);
        });        

        // deletions
        socket.on('deleteTopicFromServer', self.removeTopic);
        socket.on('deleteSynapseFromServer', self.removeSynapse);

        socket.on('topicChangeFromServer', self.topicChange);
        socket.on('synapseChangeFromServer', self.synapseChange);
        self.attachMapListener();
    
        // local event listeners that trigger events
        var sendCoords = function (event) {
            var pixels = {
                x: event.pageX,
                y: event.pageY
            };
            var coords = Mapmaker.Utility.pixelsToCoords(pixels, self.mapView);
            self.sendCoords(coords);
        };
        $(document).mousemove(sendCoords);

        var zoom = function (event, e) {
            if (e) {
                var pixels = {
                    x: e.pageX,
                    y: e.pageY
                };
                var coords = Mapmaker.Utility.pixelsToCoords(pixels, self.mapView);
                self.sendCoords(coords);
            }
            self.positionPeerIcons();
        };
        $(document).on(Mapmaker.JIT.events.zoom, zoom);

        $(document).on(Mapmaker.JIT.events.pan, self.positionPeerIcons);

        var sendTopicDrag = function (event, positions) {
            self.sendTopicDrag(positions);
        };
        $(document).on(Mapmaker.JIT.events.topicDrag, sendTopicDrag);

        var sendNewTopic = function (event, data) {
            self.sendNewTopic(data);
        };
        $(document).on(Mapmaker.JIT.events.newTopic, sendNewTopic);

        var sendDeleteTopic = function (event, data) {
            self.sendDeleteTopic(data);
        };
        $(document).on(Mapmaker.JIT.events.deleteTopic, sendDeleteTopic);

        var sendRemoveTopic = function (event, data) {
            self.sendRemoveTopic(data);
        };
        $(document).on(Mapmaker.JIT.events.removeTopic, sendRemoveTopic);

        var sendNewSynapse = function (event, data) {
            self.sendNewSynapse(data);
        };
        $(document).on(Mapmaker.JIT.events.newSynapse, sendNewSynapse);

        var sendDeleteSynapse = function (event, data) {
            self.sendDeleteSynapse(data);
        };
        $(document).on(Mapmaker.JIT.events.deleteSynapse, sendDeleteSynapse);

        var sendRemoveSynapse = function (event, data) {
            self.sendRemoveSynapse(data);
        };
        $(document).on(Mapmaker.JIT.events.removeSynapse, sendRemoveSynapse);

        var sendChatMessage = function (event, data) {
            self.sendChatMessage(data);
        };
        $(document).on(Mapmaker.ChatView.events.message, sendChatMessage);
    }

    realtime.prototype.attachMapListener = function(){
        var self = this;
        var socket = this.socket;

        socket.on('mapChangeFromServer', self.mapChange);
    }

    realtime.prototype.sendRealtimeOn = function () {
        var self = this;
        var socket = this.socket;

        // send this new mapper back your details, and the awareness that you're online
        var update = {
            username: this.mapView.currentMapper.get("name"),
            userid: this.mapView.currentMapper.id,
            mapid: this.mapView.currentMap.id
        };
        socket.emit('notifyStartRealtime', update);
    }

    realtime.prototype.sendRealtimeOff = function () {
        var self = this;
        var socket = this.socket;

        // send this new mapper back your details, and the awareness that you're online
        var update = {
            username: this.mapView.currentMapper.get("name"),
            userid: this.mapView.currentMapper.id,
            mapid: this.mapView.currentMap.id
        };
        socket.emit('notifyStopRealtime', update);
    }

    realtime.prototype.updateMapperList = function (data) {
        var self = this;
        var socket = this.socket;

        // data.userid
        // data.username
        // data.userimage
        // data.userrealtime

        self.mappersOnMap[data.userid] = {
            name: data.username,
            image: data.userimage,
            color: Mapmaker.Utility.getPastelColor(),
            realtime: data.userrealtime,
            coords: {
                x: 0, 
                y: 0
            },
        };

        var onOff = data.userrealtime ? "On" : "Off";
        var mapperListItem = '<li id="mapper';
        mapperListItem += data.userid;
        mapperListItem += '" class="rtMapper littleRt';
        mapperListItem += onOff;
        mapperListItem += '">';
        mapperListItem += '<img style="border: 2px solid ' + self.mappersOnMap[data.userid].color + ';"';
        mapperListItem += ' src="' + data.userimage + '" width="24" height="24" class="rtUserImage" />';
        mapperListItem += data.username;
        mapperListItem += '<div class="littleJuntoIcon"></div>';
        mapperListItem += '</li>';

        if (data.userid !== this.mapView.currentMapper.id) {
            $('#mapper' + data.userid).remove();
            $('.realtimeMapperList ul').append(mapperListItem);

            // create a div for the collaborators compass
            self.createCompass(data.username, data.userid, data.userimage, self.mappersOnMap[data.userid].color, !self.status);
        }
    }

    realtime.prototype.newPeerOnMap = function (data) {
        var self = this;
        var socket = this.socket;

        // data.userid
        // data.username
        // data.userimage
        // data.coords

        self.mappersOnMap[data.userid] = {
            name: data.username,
            image: data.userimage,
            color: Mapmaker.Utility.getPastelColor(),
            realtime: true,
            coords: {
                x: 0, 
                y: 0
            },
        };

        // create an item for them in the realtime box
        if (data.userid !== this.mapView.currentMapper.id && self.status) {
            var mapperListItem = '<li id="mapper' + data.userid + '" class="rtMapper littleRtOn">';
            mapperListItem += '<img style="border: 2px solid ' + self.mappersOnMap[data.userid].color + ';"';
            mapperListItem += ' src="' + data.userimage + '" width="24" height="24" class="rtUserImage" />';
            mapperListItem += data.username;
            mapperListItem += '<div class="littleJuntoIcon"></div>';
            mapperListItem += '</li>';
            $('#mapper' + data.userid).remove();
            $('.realtimeMapperList ul').append(mapperListItem);

            // create a div for the collaborators compass
            self.createCompass(data.username, data.userid, data.userimage, self.mappersOnMap[data.userid].color, !self.status);
            
            console.log(data.username + ' just joined the map');

            // send this new mapper back your details, and the awareness that you've loaded the map
            var update = {
                userToNotify: data.userid,
                username: this.mapView.currentMapper.get("name"),
                userimage: this.mapView.currentMapper.get("image"),
                userid: this.mapView.currentMapper.id,
                userrealtime: self.status,
                mapid: this.mapView.currentMap.id
            };
            socket.emit('updateNewMapperList', update);
        }
    }

    realtime.prototype.createCompass = function (name, id, image, color, hide) {
        var str =  '<img width="28" height="28" src="'+image+'" /><p>'+name+'</p>';
        str += '<div id="compassArrow'+id+'" class="compassArrow"></div>';
        $('#compass' + id).remove();
        $('<div/>', {
            id: 'compass' + id,
            class: 'collabCompass'
        }).html(str).appendTo(this.mapView.$parent);
        if (hide) {
            $('#compass' + id).hide();
        }
        $('#compass' + id + ' img').css({
            'border': '2px solid ' + color
        });
        $('#compass' + id + ' p').css({
            'background-color': color
        });
    }

    realtime.prototype.lostPeerOnMap = function (data) {
        var self = this;
        var socket = this.socket;

        // data.userid
        // data.username

        delete self.mappersOnMap[data.userid];

        $('#mapper' + data.userid).remove();
        $('#compass' + data.userid).remove();

        console.log(data.username + ' just left the map');
    }

    realtime.prototype.newCollaborator = function (data) {
        var self = this;
        var socket = this.socket;

        // data.userid
        // data.username

        self.mappersOnMap[data.userid].realtime = true;

        $('#mapper' + data.userid).removeClass('littleRtOff').addClass('littleRtOn');
        $('#compass' + data.userid).show();

        console.log(data.username + ' just turned on realtime');
    }

    realtime.prototype.lostCollaborator = function (data) {
        var self = this;
        var socket = this.socket;

        // data.userid
        // data.username

        self.mappersOnMap[data.userid].realtime = false;

        $('#mapper' + data.userid).removeClass('littleRtOn').addClass('littleRtOff');
        $('#compass' + data.userid).hide();

        console.log(data.username + ' just turned off realtime');
    }

    realtime.prototype.updatePeerCoords = function (data) {
        var self = this;
        var socket = this.socket;

        if (self.mappersOnMap[data.userid]) {
            self.mappersOnMap[data.userid].coords={x: data.usercoords.x,y:data.usercoords.y};
            self.positionPeerIcon(data.userid);
        }
    }

    realtime.prototype.positionPeerIcons = function () {
        var self = this;
        var socket = this.socket;

        if (self.status) { // if i have realtime turned on
            for (var key in self.mappersOnMap) {
                var mapper = self.mappersOnMap[key];
                if (mapper.realtime) {
                    self.positionPeerIcon(key);
                }
            }
        }
    }

    realtime.prototype.positionPeerIcon = function (id) {
        var self = this;
        var socket = this.socket;

        var mapper = self.mappersOnMap[id];
        var xMax=$(document).width();
        var yMax=$(document).height();
        var compassDiameter=56;
        var compassArrowSize=24;
        
        var origPixels = Mapmaker.Utility.coordsToPixels(mapper.coords, self.mapView);
        var pixels = self.limitPixelsToScreen(origPixels);
        $('#compass' + id).css({
            left: pixels.x + 'px',
            top: pixels.y + 'px'
        });
        /* showing the arrow if the collaborator is off of the viewport screen */
        if (origPixels.x !== pixels.x || origPixels.y !== pixels.y) {

            var dy = origPixels.y - pixels.y; //opposite
            var dx = origPixels.x - pixels.x; // adjacent
            var ratio = dy / dx;
            var angle = Math.atan2(dy, dx);
            
            $('#compassArrow' + id).show().css({
                transform: 'rotate(' + angle + 'rad)',
                "-webkit-transform": 'rotate(' + angle + 'rad)',
            });
            
            if (dx > 0) {
                $('#compass' + id).addClass('labelLeft');
            }
        } else {
            $('#compassArrow' + id).hide();
            $('#compass' + id).removeClass('labelLeft');
        }
    }

    realtime.prototype.limitPixelsToScreen = function (pixels) {
        var self = this;
        var socket = this.socket;

        var xLimit, yLimit;
        var xMax=this.mapView.$parent.width();
        var yMax=this.mapView.$parent.height();
        var compassDiameter=56;
        var compassArrowSize=24;
        
        xLimit = Math.max(0 + compassArrowSize, pixels.x);
        xLimit = Math.min(xLimit, xMax - compassDiameter);
        yLimit = Math.max(0 + compassArrowSize, pixels.y);
        yLimit = Math.min(yLimit, yMax - compassDiameter);
        
        return {x:xLimit,y:yLimit};
    }

    realtime.prototype.sendCoords = function (coords) {
        var self = this;
        var socket = this.socket;

        var map = this.mapView.currentMap;
        var mapper = this.mapView.currentMapper;

        if (self.status && map.authorizeToEdit(mapper) && socket) {
            var update = {
                usercoords: coords,
                userid: this.mapView.currentMapper.id,
                mapid: this.mapView.currentMap.id
            };
            socket.emit('updateMapperCoords', update);
        }
    }

    realtime.prototype.sendTopicDrag = function (positions) {
        var self = this;
        var socket = self.socket;

        if (this.mapView.currentMap && self.status) {
            positions.mapid = this.mapView.currentMap.id;
            socket.emit('topicDrag', positions);
        }
    }

    realtime.prototype.topicDrag = function (positions) {
        var self = this;
        var socket = self.socket;

        var topic;
        var node;

        if (this.mapView.currentMap && self.status) {
            for (var key in positions) {
                topic = this.mapView.Topics.get(key);
                if (topic) node = topic.get('node');
                if (node) node.pos.setc(positions[key].x, positions[key].y);
            } //for
            this.mapView.Visualize.mGraph.plot();
        }
    }

    realtime.prototype.sendTopicChange = function (topic) {
        var self = this;
        var socket = self.socket;

        var data = {
            topicId: topic.id
        }

        socket.emit('topicChangeFromClient', data);
    }

    realtime.prototype.topicChange = function (data) {
        var topic = this.mapView.Topics.get(data.topicId);
        if (topic) {
            var node = topic.get('node');
            topic.fetch({
                success: function (model) {
                    model.set({ node: node });
                    model.trigger('changeByOther');
                }
            });
        }
    }

    realtime.prototype.sendSynapseChange = function (synapse) {
        var self = this;
        var socket = self.socket;

        var data = {
            synapseId: synapse.id
        }

        socket.emit('synapseChangeFromClient', data);
    }

    realtime.prototype.synapseChange = function (data) {
        var synapse = this.mapView.Synapses.get(data.synapseId);
        if (synapse) {
            // edge reset necessary because fetch causes model reset
            var edge = synapse.get('edge');
            synapse.fetch({
                success: function (model) {
                    model.set({ edge: edge });
                    model.trigger('changeByOther');
                }
            });
        }
    }

    realtime.prototype.sendMapChange = function (map) {
        var self = this;
        var socket = self.socket;

        var data = {
            mapId: map.id
        }

        socket.emit('mapChangeFromClient', data);
    }

    realtime.prototype.mapChange = function (data) {
        var map = this.mapView.currentMap;
        var isActiveMap = map && data.mapId === map.id;
        if (isActiveMap) {
            var permBefore = map.get('permission');
            var idBefore = map.id;
            map.fetch({
                success: function (model, response) {

                    var idNow = model.id;
                    var permNow = model.get('permission');
                    if (idNow !== idBefore) {
                        this.mapView.Map.leavePrivateMap(); // this means the map has been changed to private
                    }
                    else if (permNow === 'public' && permBefore === 'commons') {
                        this.mapView.Map.commonsToPublic();
                    }
                    else if (permNow === 'commons' && permBefore === 'public') {
                        this.mapView.Map.publicToCommons();
                    }
                    else {
                        model.fetchContained();
                        model.trigger('changeByOther');
                    }
                }
            });
        }
    }

    // newTopic
    realtime.prototype.sendNewTopic = function (data) {
        var self = this;
        var socket = self.socket;

        if (this.mapView.currentMap && self.status) {
            data.mapperid = this.mapView.currentMapper.id;
            data.mapid = this.mapView.currentMap.id;
            socket.emit('newTopic', data);
        }
    }

    realtime.prototype.newTopic = function (data) {
        var topic, mapping, mapper, mapperCallback, cancel;

        var self = this;
        var socket = self.socket;

        if (!self.status) return;

        function test() {
            if (topic && mapping && mapper) {
                this.mapView.Topic.renderTopic(mapping, topic, false, false);
            }
            else if (!cancel) {
                setTimeout(test, 10);
            }
        }

        mapper = this.mapView.Mappers.get(data.mapperid);
        if (mapper === undefined) {
            mapperCallback = function (m) {
                this.mapView.Mappers.add(m);
                mapper = m;
            };
            this.mapView.Mapper.get(data.mapperid, mapperCallback);
        }
        $.ajax({
            url: "/topics/" + data.topicid + ".json",
            success: function (response) {
                this.mapView.Topics.add(response);
                topic = this.mapView.Topics.get(response.id);
            },
            error: function () {
                cancel = true;
            }
        });
        $.ajax({
            url: "/mappings/" + data.mappingid + ".json",
            success: function (response) {
                this.mapView.Mappings.add(response);
                mapping = this.mapView.Mappings.get(response.id);
            },
            error: function () {
                cancel = true;
            }
        });

        test();
    }
    
    // removeTopic
    realtime.prototype.sendDeleteTopic = function (data) {
        var self = this;
        var socket = self.socket;

        if (this.mapView.currentMap) {
            socket.emit('deleteTopicFromClient', data);
        }
    }
    
    // removeTopic
    realtime.prototype.sendRemoveTopic = function (data) {
        var self = this;
        var socket = self.socket;

        if (this.mapView.currentMap) {
            data.mapid = this.mapView.currentMap.id;
            socket.emit('removeTopic', data);
        }
    }

    realtime.prototype.removeTopic = function (data) {
        var self = this;
        var socket = self.socket;

        if (!self.status) return;

        var topic = this.mapView.Topics.get(data.topicid);
        if (topic) {
            var node = topic.get('node');
            var mapping = topic.getMapping();
            this.mapView.Control.hideNode(node.id);
            this.mapView.Topics.remove(topic);
            this.mapView.Mappings.remove(mapping);
        }
    }
    
    // newSynapse
    realtime.prototype.sendNewSynapse = function (data) {
        var self = this;
        var socket = self.socket;

        if (this.mapView.currentMap) {
            data.mapperid = this.mapView.currentMapper.id;
            data.mapid = this.mapView.currentMap.id;
            socket.emit('newSynapse', data);
        }
    }

    realtime.prototype.newSynapse = function (data) {
        var topic1, topic2, node1, node2, synapse, mapping, cancel;

        var self = this;
        var socket = self.socket;

        if (!self.status) return;

        function test() {
            if (synapse && mapping && mapper) {
                topic1 = synapse.getTopic1();
                node1 = topic1.get('node');
                topic2 = synapse.getTopic2();
                node2 = topic2.get('node');

                this.mapView.Synapse.renderSynapse(mapping, synapse, node1, node2, false);
            }
            else if (!cancel) {
                setTimeout(test, 10);
            }
        }

        mapper = this.mapView.Mappers.get(data.mapperid);
        if (mapper === undefined) {
            mapperCallback = function (m) {
                this.mapView.Mappers.add(m);
                mapper = m;
            };
            this.mapView.Mapper.get(data.mapperid, mapperCallback);
        }
        $.ajax({
            url: "/synapses/" + data.synapseid + ".json",
            success: function (response) {
                this.mapView.Synapses.add(response);
                synapse = this.mapView.Synapses.get(response.id);
            },
            error: function () {
                cancel = true;
            }
        });
        $.ajax({
            url: "/mappings/" + data.mappingid + ".json",
            success: function (response) {
                this.mapView.Mappings.add(response);
                mapping = this.mapView.Mappings.get(response.id);
            },
            error: function () {
                cancel = true;
            }
        });
        test();
    }

    // deleteSynapse
    realtime.prototype.sendDeleteSynapse = function (data) {
        var self = this;
        var socket = self.socket;

        if (this.mapView.currentMap) {
            data.mapid = this.mapView.currentMap.id;
            socket.emit('deleteSynapseFromClient', data);
        }
    }

    // removeSynapse
    realtime.prototype.sendRemoveSynapse = function (data) {
        var self = this;
        var socket = self.socket;

        if (this.mapView.currentMap) {
            data.mapid = this.mapView.currentMap.id;
            socket.emit('removeSynapse', data);
        }
    }

    realtime.prototype.removeSynapse = function (data) {
        var self = this;
        var socket = self.socket;

        if (!self.status) return;

        var synapse = this.mapView.Synapses.get(data.synapseid);
        if (synapse) {
            var edge = synapse.get('edge');
            var mapping = synapse.getMapping();
            if (edge.getData("mappings").length - 1 === 0) {
                this.mapView.Control.hideEdge(edge);
            }
            
            var index = _.indexOf(edge.getData("synapses"), synapse);
            edge.getData("mappings").splice(index, 1);
            edge.getData("synapses").splice(index, 1);
            if (edge.getData("displayIndex")) {
                delete edge.data.$displayIndex;
            }
            this.mapView.Synapses.remove(synapse);
            this.mapView.Mappings.remove(mapping);
        }
    }

    realtime.prototype.sendChatMessage = function (data) {
        var self = this;
        var socket = self.socket;
        var message = {
            mapid: this.mapView.currentMap.id,
            message: data
        };
        socket.emit('chatMessage', message);
    }

    return realtime;

}(jQuery));
if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.Visualize = (function ($) {

    var vis = function (mapView) {
        this.mapView = mapView;

        this.mGraph = null; // a reference to the graph object.
        this.cameraPosition = null; // stores the camera position when using a 3D visualization
        this.type = "ForceDirected"; // the type of graph we're building, could be "RGraph", "ForceDirected", or "ForceDirected3D"
        this.loadLater = false; // indicates whether there is JSON that should be loaded right in the offset, or whether to wait till the first topic is created
    }
    
    vis.prototype.init = function () {
        var self = this;
        // disable awkward dragging of the canvas element that would sometimes happen
        $('#infovis-canvas').on('dragstart', function (event) {
            event.preventDefault();
        });

        // prevent touch events on the canvas from default behaviour
        $("#infovis-canvas").bind('touchstart', function (event) {
            event.preventDefault();
            self.mGraph.events.touched = true;
        });

        // prevent touch events on the canvas from default behaviour
        $("#infovis-canvas").bind('touchmove', function (event) {
            //this.mapView.JIT.touchPanZoomHandler(event);
        });

        // prevent touch events on the canvas from default behaviour
        $("#infovis-canvas").bind('touchend touchcancel', function (event) {
            lastDist = 0;
            if (!self.mGraph.events.touchMoved && !self.mapView.Touch.touchDragNode) self.mapView.TopicCard.hideCurrentCard();
            self.mGraph.events.touched = self.mGraph.events.touchMoved = false;
            self.mapView.Touch.touchDragNode = false;
        });
    }

    vis.prototype.computePositions = function () {
        var self = this,
            mapping;

        if (self.type == "RGraph") {
            var i, l, startPos, endPos, topic, synapse;

            self.mGraph.graph.eachNode(function (n) {
                topic = self.mapView.Topics.get(n.id);
                topic.set({ node: n }, { silent: true });
                topic.updateNode();

                n.eachAdjacency(function (edge) {
                    if(!edge.getData('init')) {
                        edge.setData('init', true);

                        l = edge.getData('synapseIDs').length;
                        for (i = 0; i < l; i++) {
                            synapse = self.mapView.Synapses.get(edge.getData('synapseIDs')[i]);
                            synapse.set({ edge: edge }, { silent: true });
                            synapse.updateEdge();
                        }
                    }
                });
                
                var pos = n.getPos();
                pos.setc(-200, -200);
            });
            self.mGraph.compute('end');
        } else if (self.type == "ForceDirected") {
            var i, l, startPos, endPos, topic, synapse;

            self.mGraph.graph.eachNode(function (n) {
                topic = self.mapView.Topics.get(n.id);
                topic.set({ node: n }, { silent: true });
                topic.updateNode();
                mapping = topic.getMapping();

                n.eachAdjacency(function (edge) {
                    if(!edge.getData('init')) {
                        edge.setData('init', true);

                        l = edge.getData('synapseIDs').length;
                        for (i = 0; i < l; i++) {
                            synapse = self.mapView.Synapses.get(edge.getData('synapseIDs')[i]);
                            synapse.set({ edge: edge }, { silent: true });
                            synapse.updateEdge();
                        }
                    }
                });

                startPos = new $jit.Complex(0, 0);
                endPos = new $jit.Complex(mapping.get('xloc'), mapping.get('yloc'));
                n.setPos(startPos, 'start');
                n.setPos(endPos, 'end');
            });
        } else if (self.type == "ForceDirected3D") {
            self.mGraph.compute();
        }
    }

    /**
     * render does the heavy lifting of creating the engine that renders the graph with the properties we desire
     *
     */
    vis.prototype.render = function () {
        var self = this, RGraphSettings, FDSettings;

        if (self.type == "RGraph" && (!self.mGraph || self.mGraph instanceof $jit.ForceDirected)) {

            RGraphSettings = $.extend(true, {}, this.mapView.JIT.ForceDirected.graphSettings);

            $jit.RGraph.Plot.NodeTypes.implement(this.mapView.JIT.ForceDirected.nodeSettings);
            $jit.RGraph.Plot.EdgeTypes.implement(this.mapView.JIT.ForceDirected.edgeSettings);
            
            RGraphSettings.width = $(document).width();
            RGraphSettings.height = $(document).height();
            RGraphSettings.background = this.mapView.JIT.RGraph.background;
            RGraphSettings.levelDistance = this.mapView.JIT.RGraph.levelDistance;
            
            self.mGraph = new $jit.RGraph(RGraphSettings);

        } else if (self.type == "ForceDirected" && (!self.mGraph || self.mGraph instanceof $jit.RGraph)) {

            FDSettings = $.extend(true, {}, this.mapView.JIT.ForceDirected.graphSettings);

            $jit.ForceDirected.Plot.NodeTypes.implement(this.mapView.JIT.ForceDirected.nodeSettings);
            $jit.ForceDirected.Plot.EdgeTypes.implement(this.mapView.JIT.ForceDirected.edgeSettings);
            
            FDSettings.width = $(document).width();
            FDSettings.height = $(document).height();

            self.mGraph = new $jit.ForceDirected(FDSettings);

        } else if (self.type == "ForceDirected3D" && !self.mGraph) {
            // init ForceDirected3D
            self.mGraph = new $jit.ForceDirected3D(this.mapView.JIT.ForceDirected3D.graphSettings);
            self.cameraPosition = self.mGraph.canvas.canvases[0].camera.position;
        }
        else {
            self.mGraph.graph.empty();
        }

        this.mapView.Loading.hide();
        // load JSON data, if it's not empty
        if (!self.loadLater) {
            //load JSON data.
            var rootIndex = 0;
            if (this.mapView.Active.Topic) {
                var node = _.find(this.mapView.JIT.vizData, function(node){
                    return node.id === this.mapView.Active.Topic.id;
                });
                rootIndex = _.indexOf(this.mapView.JIT.vizData, node);
            }
            self.mGraph.loadJSON(this.mapView.JIT.vizData, rootIndex);
            //compute positions and plot.
            self.computePositions();
            self.mGraph.busy = true;
            if (self.type == "RGraph") {
                self.mGraph.fx.animate(this.mapView.JIT.RGraph.animate);
            } else if (self.type == "ForceDirected") {
                self.mGraph.animate(this.mapView.JIT.ForceDirected.animateSavedLayout);
            } else if (self.type == "ForceDirected3D") {
                self.mGraph.animate(this.mapView.JIT.ForceDirected.animateFDLayout);
            }
        }

        // update the url now that the map is ready
        setTimeout(function(){
            var m = self.mapView.Active.Map;
            var t = self.mapView.Active.Topic;

            if (m && window.location.pathname !== "/maps/" + m.id) {
                self.mapView.Router.navigate("/maps/" + m.id);
            }
            else if (t && window.location.pathname !== "/topics/" + t.id) {
                self.mapView.Router.navigate("/topics/" + t.id);
            }
        }, 800);

    }

    return vis;

}(jQuery));

if (typeof Mapmaker === 'undefined') Mapmaker = {};

Mapmaker.Maker = (function($) {

	/**
	 * The public interface for the map maker component
	 * @class Mapmaker.Maker
	 * @param {Mapmaker.MapView} view
	 * @param {Object} room
	 */
	var Maker = function(view, map) {
		/**
		 * The view object associated with the maker
		 * @property {Object}
		 */
		this.view = view;
		/**
		 * The renderer's current map
		 * @property {Mapmaker.Map}
		 */
		this.map = map;
	};

	Maker.prototype.launch = function (id) {
      var bb = Mapmaker.Backbone;
      var start = function (data) {
          Mapmaker.Active.Map = new bb.Map(data.map);
          Mapmaker.Mappers = new bb.MapperCollection(data.mappers);
          Mapmaker.Topics = new bb.TopicCollection(data.topics);
          Mapmaker.Synapses = new bb.SynapseCollection(data.synapses);
          Mapmaker.Mappings = new bb.MappingCollection(data.mappings);
          Mapmaker.Backbone.attachCollectionEvents();

          var map = Mapmaker.Active.Map;
          var mapper = Mapmaker.Active.Mapper;

          // add class to .wrapper for specifying whether you can edit the map
          if (map.authorizeToEdit(mapper)) {
              $('.wrapper').addClass('canEditMap');
          }

          // add class to .wrapper for specifying if the map can
          // be collaborated on
          if (map.get('permission') === 'commons') {
              $('.wrapper').addClass('commonsMap');
          }

          // set filter mapper H3 text
          $('#filter_by_mapper h3').html('MAPPERS');

          // build and render the visualization
          Mapmaker.Visualize.type = "ForceDirected";
          Mapmaker.JIT.prepareVizData();

          // update filters
          Mapmaker.Filter.reset(); 

          // reset selected arrays
          Mapmaker.Selected.reset();

          // set the proper mapinfobox content
          Mapmaker.Map.InfoBox.load();

          // these three update the actual filter box with the right list items
          Mapmaker.Filter.checkMetacodes();
          Mapmaker.Filter.checkSynapses();
          Mapmaker.Filter.checkMappers();

          Mapmaker.Realtime.startActiveMap();
          Mapmaker.Loading.hide();
      }

      $.ajax({
          url: "/maps/" + id + "/contains.json",
          success: start
      });
  }

	Maker.prototype.exportImage = function() {

      var canvas = {};

      canvas.canvas = document.createElement("canvas");
      canvas.canvas.width  =  1880; // 960;
      canvas.canvas.height = 1260; // 630

      canvas.scaleOffsetX = 1;
      canvas.scaleOffsetY = 1;
      canvas.translateOffsetY = 0;
      canvas.translateOffsetX = 0;
      canvas.denySelected = true;

      canvas.getSize =  function() {
          if(this.size) return this.size;
          var canvas = this.canvas;
          return this.size = {
              width: canvas.width,
              height: canvas.height
          };
      };
      canvas.scale = function(x, y) {
          var px = this.scaleOffsetX * x,
              py = this.scaleOffsetY * y;
          var dx = this.translateOffsetX * (x -1) / px,
              dy = this.translateOffsetY * (y -1) / py;
          this.scaleOffsetX = px;
          this.scaleOffsetY = py;
          this.getCtx().scale(x, y);
          this.translate(dx, dy);
      };
      canvas.translate = function(x, y) {
          var sx = this.scaleOffsetX,
              sy = this.scaleOffsetY;
          this.translateOffsetX += x*sx;
          this.translateOffsetY += y*sy;
          this.getCtx().translate(x, y); 
      };
      canvas.getCtx = function() {
        return this.canvas.getContext("2d");
      };
      // center it
      canvas.getCtx().translate(1880/2, 1260/2);

      var mGraph = this.view.Visualize.mGraph;

      var id = mGraph.root;
      var root = mGraph.graph.getNode(id);
      var T = !!root.visited;

      // pass true to avoid basing it on a selection
      this.view.JIT.zoomExtents(null, canvas, true);

      var c = canvas.canvas,
          ctx = canvas.getCtx(),
          scale = canvas.scaleOffsetX;

      // draw a grey background
      ctx.fillStyle = '#d8d9da';
      var xPoint = (-(c.width/scale)/2) - (canvas.translateOffsetX/scale),
      yPoint = (-(c.height/scale)/2) - (canvas.translateOffsetY/scale);
      ctx.fillRect(xPoint,yPoint,c.width/scale,c.height/scale);

      // draw the graph
      mGraph.graph.eachNode(function(node) {
         var nodeAlpha = node.getData('alpha');
         node.eachAdjacency(function(adj) {
           var nodeTo = adj.nodeTo;
           if(!!nodeTo.visited === T && node.drawn && nodeTo.drawn) {
             mGraph.fx.plotLine(adj, canvas);
           }
         });
         if(node.drawn) {
           mGraph.fx.plotNode(node, canvas);
         }
         if(!mGraph.labelsHidden) {
           if(node.drawn && nodeAlpha >= 0.95) {
             mGraph.labels.plotLabel(canvas, node);
           } else {
             mGraph.labels.hideLabel(node, false);
           }
         }
         node.visited = !T;
       });
      
      var imageData = {
          encoded_image: canvas.canvas.toDataURL()
      };

      var map = this.map;

      var today = new Date();
      var dd = today.getDate();
      var mm = today.getMonth()+1; //January is 0!
      var yyyy = today.getFullYear();
      if(dd<10) {
          dd='0'+dd
      } 
      if(mm<10) {
          mm='0'+mm
      }
      today = mm+'/'+dd+'/'+yyyy;

      var mapName = map.get("name").split(" ").join([separator = '-']);
      var downloadMessage = "";
      downloadMessage += "Captured map screenshot! ";
      downloadMessage += "<a href='" + imageData.encoded_image + "' ";
      downloadMessage += "download='metamap-" + map.id + "-" + mapName + "-" + today + ".png'>DOWNLOAD</a>";
      // TODO Mapmaker.GlobalUI.notifyUser(downloadMessage);

      $.ajax({
          type: "POST",
          dataType: 'json',
          url: "/maps/" + this.map.id + "/upload_screenshot",
          data: imageData,
          success: function (data) {
              console.log('successfully uploaded map screenshot');
          },
          error: function () {
              console.log('failed to save map screenshot');
          }
      });
  }

  Maker.prototype.export = function() {
    var object = {};

    object.map = this.map.toJSON();
    delete object.map.arranged;
    delete object.map.featured;

    object.messages = this.map.get('messages').models;
    object.messages = object.messages.map(function (message) { return message.attributes; });
    object.mappings = this.map.get('topicMappings').models.concat(this.map.get('synapseMappings').models);
    object.mappings = object.mappings.map(function (mapping) { return mapping.attributes; });
    object.topics = this.map.get('topics').models.map(function (topic) { return topic.attributes; });
    object.synapses = this.map.get('synapses').models.map(function (synapse) { return synapse.attributes; });
    return object;
  };

	return Maker;
}(jQuery));

/**
 * @class
 * @static
 */
Mapmaker.Maker.events = {
	/**
	 * Fired whenever the map definition changes
	 * @event
	 */
	mapChanged: "Mapmaker:mapChanged"
};

if (typeof Mapmaker === 'undefined') Mapmaker = {};

/**
 * @static
 */
Mapmaker.buildMaker = (function($) {
	return {
		/**
		 * Creates a maker and it's underlying mapView object
		 * @method create
		 * @static
		 * @param {HTMLElement} canvasEl The DOM node to create the whole app in
		 * @param {Object} config The configuration object,
		 * see {@link Mapmaker.MapView#defaultConfig}
		 * @param {Object} map The map to display
		 */
		create: function(canvasEl, config, map) {
			var canvas = $(canvasEl);
			/* jshint newcap: false */

			var mapView = new Mapmaker.MapView(map, config, canvas);
			var maker = new Mapmaker.Maker(mapView, map);
			var canvasPos = canvas.css("position");
			//The 'canvas' must have either relative or absolute positioning
			if (canvasPos !== "absolute" && canvasPos !== "relative") {
				canvas.css("position", "relative");
			}

			return maker;
		}
	};
}(jQuery));

Mapmaker.MetacodeCollection = Backbone.Collection.extend({
	model: Mapmaker.Metacode,
	url: "/metacodes",
	comparator: function(a, b) {
		a = a.get("name").toLowerCase();
		b = b.get("name").toLowerCase();
		return a > b ? 1 : a < b ? -1 : 0;
	}
});

Mapmaker.TopicCollection = Backbone.Collection.extend({
	model: Mapmaker.Topic,
	url: "/topics"
});

Mapmaker.SynapseCollection = Backbone.Collection.extend({
	model: Mapmaker.Synapse,
	url: "/synapses"
});

Mapmaker.MappingCollection = Backbone.Collection.extend({
	model: Mapmaker.Mapping,
	url: "/mappings"
});

Mapmaker.MapsCollection = Backbone.Collection.extend({
	model: Mapmaker.Map,
	initialize: function(models, options) {
		this.id = options.id;
		this.sortBy = options.sortBy;

		if (options.mapperId) {
			this.mapperId = options.mapperId;
		}

		// this.page represents the NEXT page to fetch
		this.page = models.length > 0 ? (models.length < 20 ? "loadedAll" : 2) : 1;
	},
	url: function() {
		if (!this.mapperId) {
			return "/explore/" + this.id + ".json";
		} else {
			return "/explore/mapper/" + this.mapperId + ".json";
		}
	},
	comparator: function(a, b) {
		a = a.get(this.sortBy);
		b = b.get(this.sortBy);
		var temp;
		if (this.sortBy === "name") {
			a = a ? a.toLowerCase() : "";
			b = b ? b.toLowerCase() : "";
		} else {
			// this is for updated_at and created_at
			temp = a;
			a = b;
			b = temp;
		}
		return a > b ? 1 : a < b ? -1 : 0;
	},
	getMaps: function() {
		var self = this;

		if (this.page != "loadedAll") {
			var numBefore = this.length;
			this.fetch({
				remove: false,
				data: {
					page: this.page
				},
				success: function(collection, response, options) {
					// you can pass additional options to the event you trigger here as well
					if (collection.length - numBefore < 20) self.page = "loadedAll";
					else self.page += 1;
					self.trigger("successOnFetch");
				},
				error: function(collection, response, options) {
					// you can pass additional options to the event you trigger here as well
					self.trigger("errorOnFetch");
				}
			});
		} else {
			self.trigger("successOnFetch");
		}
	}
});

Mapmaker.MapperCollection = Backbone.Collection.extend({
	model: Mapmaker.Mapper,
	url: "/users"
});
